/*
* Copyright (c) 2024-2025. caoccao.com Sam Cao
* All rights reserved.

* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at

* http://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

use anyhow::Result;
use jni::objects::{GlobalRef, JMethodID, JObject, JString};
use jni::JNIEnv;

use crate::enums::AstType;
use crate::jni_utils::*;
use crate::span_utils::{ByteToIndexMap, RegisterWithMap, ToJavaWithMap};

use deno_ast::swc::ast::*;
use deno_ast::swc::common::{Span, Spanned, SyntaxContext, DUMMY_SP};
use num_bigint::{BigInt as BigIntValue, BigUint, Sign};

use std::ptr::null_mut;

/*
 * This file is 99% code generated.
 * Do not edit this file unless you know what you are doing.
 */

impl ToJavaWithMap<ByteToIndexMap> for BigInt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_sign = self.value.sign().to_java(env)?;
    let optional_raw = self.raw.as_ref().map(|node| node.as_str().to_owned());
    let return_value =
      unsafe { JAVA_CLASS_BIG_INT.as_ref().unwrap() }.construct(env, &java_sign, &optional_raw, &java_span_ex);
    delete_local_ref!(env, java_sign);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

impl<'local> FromJava<'local> for BigInt {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, obj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_BIG_INT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_sign = java_class.get_sign(env, &obj)?;
    let sign = Sign::from_java(env, &java_sign)?;
    let sign = *sign;
    delete_local_ref!(env, java_sign);
    let java_optional_raw = java_class.get_raw(env, &obj)?;
    let optional_raw = if optional_is_present(env, &java_optional_raw)? {
      let java_raw = optional_get(env, &java_optional_raw)?;
      let raw: Result<String> = jstring_to_string!(env, java_raw.as_raw());
      let raw = raw?;
      delete_local_ref!(env, java_raw);
      Some(raw)
    } else {
      None
    };
    let data: BigUint = optional_raw
      .as_ref()
      .map_or_else(
        || Default::default(),
        |raw| {
          let mut raw = raw.to_owned();
          while raw.ends_with("n") {
            raw.truncate(raw.len() - 1);
          }
          BigUint::parse_bytes(&raw.as_bytes(), 10)
        },
      )
      .unwrap_or_else(|| Default::default());
    delete_local_ref!(env, java_optional_raw);
    let value = BigIntValue::from_biguint(sign, data);
    let value = Box::new(value);
    let raw = optional_raw.map(|raw| raw.into());
    Ok(Box::new(BigInt { span, value, raw }))
  }
}

impl ToJavaWithMap<ByteToIndexMap> for BindingIdent {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let span = if let Some(type_ann) = self.type_ann.as_ref() {
      Span {
        lo: self.id.span.lo,
        hi: type_ann.as_ref().span.hi,
      }
    } else {
      self.span()
    };
    let java_span_ex = map.get_span_ex_by_span(&span).to_java(env)?;
    let java_id = self.id.to_java_with_map(env, map)?;
    let java_optional_type_ann = self.type_ann.as_ref().map(|node| node.to_java_with_map(env, map));
    let java_optional_type_ann = match java_optional_type_ann {
      Some(java_optional_type_ann) => Some(java_optional_type_ann?),
      None=> None,
    };
    let return_value = unsafe { JAVA_CLASS_BINDING_IDENT.as_ref().unwrap() }.construct(
      env,
      &java_id,
      &java_optional_type_ann,
      &java_span_ex,
    );
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_ref!(env, java_id);
    delete_local_ref!(env, java_span_ex);
    return_value
  }
}

/* JNI Begin */
#[allow(dead_code)]
struct JavaISwc4jAst {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAst {}
unsafe impl Sync for JavaISwc4jAst {}

#[allow(dead_code)]
impl JavaISwc4jAst {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAst")
      .expect("Couldn't find class ISwc4jAst");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAst");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAst.getType");
    JavaISwc4jAst {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstAssignTarget {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstAssignTarget {}
unsafe impl Sync for JavaISwc4jAstAssignTarget {}

#[allow(dead_code)]
impl JavaISwc4jAstAssignTarget {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstAssignTarget")
      .expect("Couldn't find class ISwc4jAstAssignTarget");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstAssignTarget");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstAssignTarget.getType");
    JavaISwc4jAstAssignTarget {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstAssignTargetPat {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstAssignTargetPat {}
unsafe impl Sync for JavaISwc4jAstAssignTargetPat {}

#[allow(dead_code)]
impl JavaISwc4jAstAssignTargetPat {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstAssignTargetPat")
      .expect("Couldn't find class ISwc4jAstAssignTargetPat");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstAssignTargetPat");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstAssignTargetPat.getType");
    JavaISwc4jAstAssignTargetPat {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstBlockStmtOrExpr {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstBlockStmtOrExpr {}
unsafe impl Sync for JavaISwc4jAstBlockStmtOrExpr {}

#[allow(dead_code)]
impl JavaISwc4jAstBlockStmtOrExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstBlockStmtOrExpr")
      .expect("Couldn't find class ISwc4jAstBlockStmtOrExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstBlockStmtOrExpr");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstBlockStmtOrExpr.getType");
    JavaISwc4jAstBlockStmtOrExpr {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstCallee {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstCallee {}
unsafe impl Sync for JavaISwc4jAstCallee {}

#[allow(dead_code)]
impl JavaISwc4jAstCallee {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstCallee")
      .expect("Couldn't find class ISwc4jAstCallee");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstCallee");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstCallee.getType");
    JavaISwc4jAstCallee {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstClassMember {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstClassMember {}
unsafe impl Sync for JavaISwc4jAstClassMember {}

#[allow(dead_code)]
impl JavaISwc4jAstClassMember {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstClassMember")
      .expect("Couldn't find class ISwc4jAstClassMember");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstClassMember");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstClassMember.getType");
    JavaISwc4jAstClassMember {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstDecl {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstDecl {}
unsafe impl Sync for JavaISwc4jAstDecl {}

#[allow(dead_code)]
impl JavaISwc4jAstDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstDecl")
      .expect("Couldn't find class ISwc4jAstDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstDecl");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstDecl.getType");
    JavaISwc4jAstDecl {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstDefaultDecl {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstDefaultDecl {}
unsafe impl Sync for JavaISwc4jAstDefaultDecl {}

#[allow(dead_code)]
impl JavaISwc4jAstDefaultDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstDefaultDecl")
      .expect("Couldn't find class ISwc4jAstDefaultDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstDefaultDecl");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstDefaultDecl.getType");
    JavaISwc4jAstDefaultDecl {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstExportSpecifier {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstExportSpecifier {}
unsafe impl Sync for JavaISwc4jAstExportSpecifier {}

#[allow(dead_code)]
impl JavaISwc4jAstExportSpecifier {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExportSpecifier")
      .expect("Couldn't find class ISwc4jAstExportSpecifier");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstExportSpecifier");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstExportSpecifier.getType");
    JavaISwc4jAstExportSpecifier {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstExpr {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstExpr {}
unsafe impl Sync for JavaISwc4jAstExpr {}

#[allow(dead_code)]
impl JavaISwc4jAstExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr")
      .expect("Couldn't find class ISwc4jAstExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstExpr");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstExpr.getType");
    JavaISwc4jAstExpr {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstForHead {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstForHead {}
unsafe impl Sync for JavaISwc4jAstForHead {}

#[allow(dead_code)]
impl JavaISwc4jAstForHead {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstForHead")
      .expect("Couldn't find class ISwc4jAstForHead");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstForHead");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstForHead.getType");
    JavaISwc4jAstForHead {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstImportSpecifier {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstImportSpecifier {}
unsafe impl Sync for JavaISwc4jAstImportSpecifier {}

#[allow(dead_code)]
impl JavaISwc4jAstImportSpecifier {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstImportSpecifier")
      .expect("Couldn't find class ISwc4jAstImportSpecifier");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstImportSpecifier");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstImportSpecifier.getType");
    JavaISwc4jAstImportSpecifier {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstJsxAttrName {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstJsxAttrName {}
unsafe impl Sync for JavaISwc4jAstJsxAttrName {}

#[allow(dead_code)]
impl JavaISwc4jAstJsxAttrName {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxAttrName")
      .expect("Couldn't find class ISwc4jAstJsxAttrName");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstJsxAttrName");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstJsxAttrName.getType");
    JavaISwc4jAstJsxAttrName {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstJsxAttrOrSpread {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstJsxAttrOrSpread {}
unsafe impl Sync for JavaISwc4jAstJsxAttrOrSpread {}

#[allow(dead_code)]
impl JavaISwc4jAstJsxAttrOrSpread {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxAttrOrSpread")
      .expect("Couldn't find class ISwc4jAstJsxAttrOrSpread");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstJsxAttrOrSpread");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstJsxAttrOrSpread.getType");
    JavaISwc4jAstJsxAttrOrSpread {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstJsxAttrValue {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstJsxAttrValue {}
unsafe impl Sync for JavaISwc4jAstJsxAttrValue {}

#[allow(dead_code)]
impl JavaISwc4jAstJsxAttrValue {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxAttrValue")
      .expect("Couldn't find class ISwc4jAstJsxAttrValue");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstJsxAttrValue");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstJsxAttrValue.getType");
    JavaISwc4jAstJsxAttrValue {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstJsxElementChild {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstJsxElementChild {}
unsafe impl Sync for JavaISwc4jAstJsxElementChild {}

#[allow(dead_code)]
impl JavaISwc4jAstJsxElementChild {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxElementChild")
      .expect("Couldn't find class ISwc4jAstJsxElementChild");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstJsxElementChild");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstJsxElementChild.getType");
    JavaISwc4jAstJsxElementChild {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstJsxElementName {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstJsxElementName {}
unsafe impl Sync for JavaISwc4jAstJsxElementName {}

#[allow(dead_code)]
impl JavaISwc4jAstJsxElementName {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxElementName")
      .expect("Couldn't find class ISwc4jAstJsxElementName");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstJsxElementName");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstJsxElementName.getType");
    JavaISwc4jAstJsxElementName {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstJsxExpr {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstJsxExpr {}
unsafe impl Sync for JavaISwc4jAstJsxExpr {}

#[allow(dead_code)]
impl JavaISwc4jAstJsxExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxExpr")
      .expect("Couldn't find class ISwc4jAstJsxExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstJsxExpr");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstJsxExpr.getType");
    JavaISwc4jAstJsxExpr {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstJsxObject {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstJsxObject {}
unsafe impl Sync for JavaISwc4jAstJsxObject {}

#[allow(dead_code)]
impl JavaISwc4jAstJsxObject {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxObject")
      .expect("Couldn't find class ISwc4jAstJsxObject");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstJsxObject");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstJsxObject.getType");
    JavaISwc4jAstJsxObject {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstKey {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstKey {}
unsafe impl Sync for JavaISwc4jAstKey {}

#[allow(dead_code)]
impl JavaISwc4jAstKey {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstKey")
      .expect("Couldn't find class ISwc4jAstKey");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstKey");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstKey.getType");
    JavaISwc4jAstKey {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstLit {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstLit {}
unsafe impl Sync for JavaISwc4jAstLit {}

#[allow(dead_code)]
impl JavaISwc4jAstLit {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstLit")
      .expect("Couldn't find class ISwc4jAstLit");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstLit");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstLit.getType");
    JavaISwc4jAstLit {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstMemberProp {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstMemberProp {}
unsafe impl Sync for JavaISwc4jAstMemberProp {}

#[allow(dead_code)]
impl JavaISwc4jAstMemberProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstMemberProp")
      .expect("Couldn't find class ISwc4jAstMemberProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstMemberProp");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstMemberProp.getType");
    JavaISwc4jAstMemberProp {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstModuleDecl {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstModuleDecl {}
unsafe impl Sync for JavaISwc4jAstModuleDecl {}

#[allow(dead_code)]
impl JavaISwc4jAstModuleDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstModuleDecl")
      .expect("Couldn't find class ISwc4jAstModuleDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstModuleDecl");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstModuleDecl.getType");
    JavaISwc4jAstModuleDecl {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstModuleExportName {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstModuleExportName {}
unsafe impl Sync for JavaISwc4jAstModuleExportName {}

#[allow(dead_code)]
impl JavaISwc4jAstModuleExportName {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstModuleExportName")
      .expect("Couldn't find class ISwc4jAstModuleExportName");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstModuleExportName");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstModuleExportName.getType");
    JavaISwc4jAstModuleExportName {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstModuleItem {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstModuleItem {}
unsafe impl Sync for JavaISwc4jAstModuleItem {}

#[allow(dead_code)]
impl JavaISwc4jAstModuleItem {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstModuleItem")
      .expect("Couldn't find class ISwc4jAstModuleItem");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstModuleItem");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstModuleItem.getType");
    JavaISwc4jAstModuleItem {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstObjectPatProp {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstObjectPatProp {}
unsafe impl Sync for JavaISwc4jAstObjectPatProp {}

#[allow(dead_code)]
impl JavaISwc4jAstObjectPatProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstObjectPatProp")
      .expect("Couldn't find class ISwc4jAstObjectPatProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstObjectPatProp");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstObjectPatProp.getType");
    JavaISwc4jAstObjectPatProp {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstOptChainBase {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstOptChainBase {}
unsafe impl Sync for JavaISwc4jAstOptChainBase {}

#[allow(dead_code)]
impl JavaISwc4jAstOptChainBase {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstOptChainBase")
      .expect("Couldn't find class ISwc4jAstOptChainBase");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstOptChainBase");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstOptChainBase.getType");
    JavaISwc4jAstOptChainBase {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstParamOrTsParamProp {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstParamOrTsParamProp {}
unsafe impl Sync for JavaISwc4jAstParamOrTsParamProp {}

#[allow(dead_code)]
impl JavaISwc4jAstParamOrTsParamProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstParamOrTsParamProp")
      .expect("Couldn't find class ISwc4jAstParamOrTsParamProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstParamOrTsParamProp");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstParamOrTsParamProp.getType");
    JavaISwc4jAstParamOrTsParamProp {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstPat {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstPat {}
unsafe impl Sync for JavaISwc4jAstPat {}

#[allow(dead_code)]
impl JavaISwc4jAstPat {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat")
      .expect("Couldn't find class ISwc4jAstPat");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstPat");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstPat.getType");
    JavaISwc4jAstPat {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstProgram {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstProgram {}
unsafe impl Sync for JavaISwc4jAstProgram {}

#[allow(dead_code)]
impl JavaISwc4jAstProgram {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstProgram")
      .expect("Couldn't find class ISwc4jAstProgram");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstProgram");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstProgram.getType");
    JavaISwc4jAstProgram {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstProp {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstProp {}
unsafe impl Sync for JavaISwc4jAstProp {}

#[allow(dead_code)]
impl JavaISwc4jAstProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstProp")
      .expect("Couldn't find class ISwc4jAstProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstProp");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstProp.getType");
    JavaISwc4jAstProp {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstPropName {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstPropName {}
unsafe impl Sync for JavaISwc4jAstPropName {}

#[allow(dead_code)]
impl JavaISwc4jAstPropName {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName")
      .expect("Couldn't find class ISwc4jAstPropName");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstPropName");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstPropName.getType");
    JavaISwc4jAstPropName {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstPropOrSpread {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstPropOrSpread {}
unsafe impl Sync for JavaISwc4jAstPropOrSpread {}

#[allow(dead_code)]
impl JavaISwc4jAstPropOrSpread {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropOrSpread")
      .expect("Couldn't find class ISwc4jAstPropOrSpread");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstPropOrSpread");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstPropOrSpread.getType");
    JavaISwc4jAstPropOrSpread {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstSimpleAssignTarget {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstSimpleAssignTarget {}
unsafe impl Sync for JavaISwc4jAstSimpleAssignTarget {}

#[allow(dead_code)]
impl JavaISwc4jAstSimpleAssignTarget {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstSimpleAssignTarget")
      .expect("Couldn't find class ISwc4jAstSimpleAssignTarget");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstSimpleAssignTarget");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstSimpleAssignTarget.getType");
    JavaISwc4jAstSimpleAssignTarget {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstStmt {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstStmt {}
unsafe impl Sync for JavaISwc4jAstStmt {}

#[allow(dead_code)]
impl JavaISwc4jAstStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt")
      .expect("Couldn't find class ISwc4jAstStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstStmt");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstStmt.getType");
    JavaISwc4jAstStmt {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstSuperProp {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstSuperProp {}
unsafe impl Sync for JavaISwc4jAstSuperProp {}

#[allow(dead_code)]
impl JavaISwc4jAstSuperProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstSuperProp")
      .expect("Couldn't find class ISwc4jAstSuperProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstSuperProp");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstSuperProp.getType");
    JavaISwc4jAstSuperProp {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstTsEntityName {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstTsEntityName {}
unsafe impl Sync for JavaISwc4jAstTsEntityName {}

#[allow(dead_code)]
impl JavaISwc4jAstTsEntityName {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsEntityName")
      .expect("Couldn't find class ISwc4jAstTsEntityName");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstTsEntityName");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstTsEntityName.getType");
    JavaISwc4jAstTsEntityName {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstTsEnumMemberId {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstTsEnumMemberId {}
unsafe impl Sync for JavaISwc4jAstTsEnumMemberId {}

#[allow(dead_code)]
impl JavaISwc4jAstTsEnumMemberId {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsEnumMemberId")
      .expect("Couldn't find class ISwc4jAstTsEnumMemberId");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstTsEnumMemberId");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstTsEnumMemberId.getType");
    JavaISwc4jAstTsEnumMemberId {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstTsFnOrConstructorType {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstTsFnOrConstructorType {}
unsafe impl Sync for JavaISwc4jAstTsFnOrConstructorType {}

#[allow(dead_code)]
impl JavaISwc4jAstTsFnOrConstructorType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsFnOrConstructorType")
      .expect("Couldn't find class ISwc4jAstTsFnOrConstructorType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstTsFnOrConstructorType");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstTsFnOrConstructorType.getType");
    JavaISwc4jAstTsFnOrConstructorType {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstTsFnParam {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstTsFnParam {}
unsafe impl Sync for JavaISwc4jAstTsFnParam {}

#[allow(dead_code)]
impl JavaISwc4jAstTsFnParam {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsFnParam")
      .expect("Couldn't find class ISwc4jAstTsFnParam");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstTsFnParam");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstTsFnParam.getType");
    JavaISwc4jAstTsFnParam {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstTsLit {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstTsLit {}
unsafe impl Sync for JavaISwc4jAstTsLit {}

#[allow(dead_code)]
impl JavaISwc4jAstTsLit {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsLit")
      .expect("Couldn't find class ISwc4jAstTsLit");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstTsLit");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstTsLit.getType");
    JavaISwc4jAstTsLit {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstTsModuleName {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstTsModuleName {}
unsafe impl Sync for JavaISwc4jAstTsModuleName {}

#[allow(dead_code)]
impl JavaISwc4jAstTsModuleName {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsModuleName")
      .expect("Couldn't find class ISwc4jAstTsModuleName");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstTsModuleName");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstTsModuleName.getType");
    JavaISwc4jAstTsModuleName {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstTsModuleRef {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstTsModuleRef {}
unsafe impl Sync for JavaISwc4jAstTsModuleRef {}

#[allow(dead_code)]
impl JavaISwc4jAstTsModuleRef {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsModuleRef")
      .expect("Couldn't find class ISwc4jAstTsModuleRef");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstTsModuleRef");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstTsModuleRef.getType");
    JavaISwc4jAstTsModuleRef {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstTsNamespaceBody {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstTsNamespaceBody {}
unsafe impl Sync for JavaISwc4jAstTsNamespaceBody {}

#[allow(dead_code)]
impl JavaISwc4jAstTsNamespaceBody {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsNamespaceBody")
      .expect("Couldn't find class ISwc4jAstTsNamespaceBody");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstTsNamespaceBody");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstTsNamespaceBody.getType");
    JavaISwc4jAstTsNamespaceBody {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstTsParamPropParam {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstTsParamPropParam {}
unsafe impl Sync for JavaISwc4jAstTsParamPropParam {}

#[allow(dead_code)]
impl JavaISwc4jAstTsParamPropParam {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsParamPropParam")
      .expect("Couldn't find class ISwc4jAstTsParamPropParam");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstTsParamPropParam");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstTsParamPropParam.getType");
    JavaISwc4jAstTsParamPropParam {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstTsThisTypeOrIdent {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstTsThisTypeOrIdent {}
unsafe impl Sync for JavaISwc4jAstTsThisTypeOrIdent {}

#[allow(dead_code)]
impl JavaISwc4jAstTsThisTypeOrIdent {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsThisTypeOrIdent")
      .expect("Couldn't find class ISwc4jAstTsThisTypeOrIdent");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstTsThisTypeOrIdent");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstTsThisTypeOrIdent.getType");
    JavaISwc4jAstTsThisTypeOrIdent {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstTsType {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstTsType {}
unsafe impl Sync for JavaISwc4jAstTsType {}

#[allow(dead_code)]
impl JavaISwc4jAstTsType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType")
      .expect("Couldn't find class ISwc4jAstTsType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstTsType");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstTsType.getType");
    JavaISwc4jAstTsType {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstTsTypeElement {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstTsTypeElement {}
unsafe impl Sync for JavaISwc4jAstTsTypeElement {}

#[allow(dead_code)]
impl JavaISwc4jAstTsTypeElement {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsTypeElement")
      .expect("Couldn't find class ISwc4jAstTsTypeElement");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstTsTypeElement");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstTsTypeElement.getType");
    JavaISwc4jAstTsTypeElement {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstTsTypeQueryExpr {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstTsTypeQueryExpr {}
unsafe impl Sync for JavaISwc4jAstTsTypeQueryExpr {}

#[allow(dead_code)]
impl JavaISwc4jAstTsTypeQueryExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsTypeQueryExpr")
      .expect("Couldn't find class ISwc4jAstTsTypeQueryExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstTsTypeQueryExpr");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstTsTypeQueryExpr.getType");
    JavaISwc4jAstTsTypeQueryExpr {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstTsUnionOrIntersectionType {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstTsUnionOrIntersectionType {}
unsafe impl Sync for JavaISwc4jAstTsUnionOrIntersectionType {}

#[allow(dead_code)]
impl JavaISwc4jAstTsUnionOrIntersectionType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsUnionOrIntersectionType")
      .expect("Couldn't find class ISwc4jAstTsUnionOrIntersectionType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstTsUnionOrIntersectionType");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstTsUnionOrIntersectionType.getType");
    JavaISwc4jAstTsUnionOrIntersectionType {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaISwc4jAstVarDeclOrExpr {
  class: GlobalRef,
  method_get_type: JMethodID,
}
unsafe impl Send for JavaISwc4jAstVarDeclOrExpr {}
unsafe impl Sync for JavaISwc4jAstVarDeclOrExpr {}

#[allow(dead_code)]
impl JavaISwc4jAstVarDeclOrExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstVarDeclOrExpr")
      .expect("Couldn't find class ISwc4jAstVarDeclOrExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class ISwc4jAstVarDeclOrExpr");
    let method_get_type = env
      .get_method_id(
        &class,
        "getType",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstType;",
      )
      .expect("Couldn't find method ISwc4jAstVarDeclOrExpr.getType");
    JavaISwc4jAstVarDeclOrExpr {
      class,
      method_get_type,
    }
  }

  pub fn get_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type,
        &[],
        "Swc4jAstType get_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstArrayLit {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_elems: JMethodID,
}
unsafe impl Send for JavaSwc4jAstArrayLit {}
unsafe impl Sync for JavaSwc4jAstArrayLit {}

#[allow(dead_code)]
impl JavaSwc4jAstArrayLit {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstArrayLit")
      .expect("Couldn't find class Swc4jAstArrayLit");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstArrayLit");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstArrayLit::new");
    let method_get_elems = env
      .get_method_id(
        &class,
        "getElems",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstArrayLit.getElems");
    JavaSwc4jAstArrayLit {
      class,
      method_construct,
      method_get_elems,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    elems: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let elems = object_to_jvalue!(elems);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[elems, span],
        "Swc4jAstArrayLit construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_elems<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_elems,
        &[],
        "List get_elems()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstArrayPat {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_elems: JMethodID,
  method_get_type_ann: JMethodID,
  method_is_optional: JMethodID,
}
unsafe impl Send for JavaSwc4jAstArrayPat {}
unsafe impl Sync for JavaSwc4jAstArrayPat {}

#[allow(dead_code)]
impl JavaSwc4jAstArrayPat {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/pat/Swc4jAstArrayPat")
      .expect("Couldn't find class Swc4jAstArrayPat");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstArrayPat");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;ZLcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstArrayPat::new");
    let method_get_elems = env
      .get_method_id(
        &class,
        "getElems",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstArrayPat.getElems");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstArrayPat.getTypeAnn");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstArrayPat.isOptional");
    JavaSwc4jAstArrayPat {
      class,
      method_construct,
      method_get_elems,
      method_get_type_ann,
      method_is_optional,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    elems: &JObject<'_>,
    optional: bool,
    type_ann: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let elems = object_to_jvalue!(elems);
    let optional = boolean_to_jvalue!(optional);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[elems, optional, type_ann, span],
        "Swc4jAstArrayPat construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_elems<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_elems,
        &[],
        "List get_elems()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      )?;
    Ok(return_value)
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstArrowExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_ctxt: JMethodID,
  method_get_params: JMethodID,
  method_get_return_type: JMethodID,
  method_get_type_params: JMethodID,
  method_is_async: JMethodID,
  method_is_generator: JMethodID,
}
unsafe impl Send for JavaSwc4jAstArrowExpr {}
unsafe impl Sync for JavaSwc4jAstArrowExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstArrowExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstArrowExpr")
      .expect("Couldn't find class Swc4jAstArrowExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstArrowExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ILjava/util/List;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstBlockStmtOrExpr;ZZLcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstArrowExpr::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstBlockStmtOrExpr;",
      )
      .expect("Couldn't find method Swc4jAstArrowExpr.getBody");
    let method_get_ctxt = env
      .get_method_id(
        &class,
        "getCtxt",
        "()I",
      )
      .expect("Couldn't find method Swc4jAstArrowExpr.getCtxt");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstArrowExpr.getParams");
    let method_get_return_type = env
      .get_method_id(
        &class,
        "getReturnType",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstArrowExpr.getReturnType");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstArrowExpr.getTypeParams");
    let method_is_async = env
      .get_method_id(
        &class,
        "isAsync",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstArrowExpr.isAsync");
    let method_is_generator = env
      .get_method_id(
        &class,
        "isGenerator",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstArrowExpr.isGenerator");
    JavaSwc4jAstArrowExpr {
      class,
      method_construct,
      method_get_body,
      method_get_ctxt,
      method_get_params,
      method_get_return_type,
      method_get_type_params,
      method_is_async,
      method_is_generator,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    ctxt: SyntaxContext,
    params: &JObject<'_>,
    body: &JObject<'_>,
    is_async: bool,
    generator: bool,
    type_params: &Option<JObject>,
    return_type: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let ctxt = ctxt.as_u32() as i32;
    let ctxt = int_to_jvalue!(ctxt);
    let params = object_to_jvalue!(params);
    let body = object_to_jvalue!(body);
    let is_async = boolean_to_jvalue!(is_async);
    let generator = boolean_to_jvalue!(generator);
    let type_params = optional_object_to_jvalue!(type_params);
    let return_type = optional_object_to_jvalue!(return_type);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[ctxt, params, body, is_async, generator, type_params, return_type, span],
        "Swc4jAstArrowExpr construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "ISwc4jAstBlockStmtOrExpr get_body()"
      )?;
    Ok(return_value)
  }

  pub fn get_ctxt<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<i32>
  {
    let return_value = call_as_int!(
        env,
        obj,
        self.method_get_ctxt,
        &[],
        "int get_ctxt()"
      )?;
    Ok(return_value)
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      )?;
    Ok(return_value)
  }

  pub fn get_return_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_return_type,
        &[],
        "Optional get_return_type()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      )?;
    Ok(return_value)
  }

  pub fn is_async<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_async,
        &[],
        "boolean is_async()"
      )?;
    Ok(return_value)
  }

  pub fn is_generator<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_generator,
        &[],
        "boolean is_generator()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstAssignExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_left: JMethodID,
  method_get_op: JMethodID,
  method_get_right: JMethodID,
}
unsafe impl Send for JavaSwc4jAstAssignExpr {}
unsafe impl Sync for JavaSwc4jAstAssignExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstAssignExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstAssignExpr")
      .expect("Couldn't find class Swc4jAstAssignExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstAssignExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstAssignOp;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstAssignTarget;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstAssignExpr::new");
    let method_get_left = env
      .get_method_id(
        &class,
        "getLeft",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstAssignTarget;",
      )
      .expect("Couldn't find method Swc4jAstAssignExpr.getLeft");
    let method_get_op = env
      .get_method_id(
        &class,
        "getOp",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstAssignOp;",
      )
      .expect("Couldn't find method Swc4jAstAssignExpr.getOp");
    let method_get_right = env
      .get_method_id(
        &class,
        "getRight",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstAssignExpr.getRight");
    JavaSwc4jAstAssignExpr {
      class,
      method_construct,
      method_get_left,
      method_get_op,
      method_get_right,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    op: &JObject<'_>,
    left: &JObject<'_>,
    right: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let op = object_to_jvalue!(op);
    let left = object_to_jvalue!(left);
    let right = object_to_jvalue!(right);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[op, left, right, span],
        "Swc4jAstAssignExpr construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_left<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_left,
        &[],
        "ISwc4jAstAssignTarget get_left()"
      )?;
    Ok(return_value)
  }

  pub fn get_op<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_op,
        &[],
        "Swc4jAstAssignOp get_op()"
      )?;
    Ok(return_value)
  }

  pub fn get_right<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_right,
        &[],
        "ISwc4jAstExpr get_right()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstAssignPat {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_left: JMethodID,
  method_get_right: JMethodID,
}
unsafe impl Send for JavaSwc4jAstAssignPat {}
unsafe impl Sync for JavaSwc4jAstAssignPat {}

#[allow(dead_code)]
impl JavaSwc4jAstAssignPat {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/pat/Swc4jAstAssignPat")
      .expect("Couldn't find class Swc4jAstAssignPat");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstAssignPat");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstAssignPat::new");
    let method_get_left = env
      .get_method_id(
        &class,
        "getLeft",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;",
      )
      .expect("Couldn't find method Swc4jAstAssignPat.getLeft");
    let method_get_right = env
      .get_method_id(
        &class,
        "getRight",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstAssignPat.getRight");
    JavaSwc4jAstAssignPat {
      class,
      method_construct,
      method_get_left,
      method_get_right,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    left: &JObject<'_>,
    right: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let left = object_to_jvalue!(left);
    let right = object_to_jvalue!(right);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[left, right, span],
        "Swc4jAstAssignPat construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_left<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_left,
        &[],
        "ISwc4jAstPat get_left()"
      )?;
    Ok(return_value)
  }

  pub fn get_right<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_right,
        &[],
        "ISwc4jAstExpr get_right()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstAssignPatProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_key: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstAssignPatProp {}
unsafe impl Sync for JavaSwc4jAstAssignPatProp {}

#[allow(dead_code)]
impl JavaSwc4jAstAssignPatProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/pat/Swc4jAstAssignPatProp")
      .expect("Couldn't find class Swc4jAstAssignPatProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstAssignPatProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/pat/Swc4jAstBindingIdent;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstAssignPatProp::new");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/pat/Swc4jAstBindingIdent;",
      )
      .expect("Couldn't find method Swc4jAstAssignPatProp.getKey");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstAssignPatProp.getValue");
    JavaSwc4jAstAssignPatProp {
      class,
      method_construct,
      method_get_key,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    value: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let value = optional_object_to_jvalue!(value);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, value, span],
        "Swc4jAstAssignPatProp construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "Swc4jAstBindingIdent get_key()"
      )?;
    Ok(return_value)
  }

  pub fn get_value<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "Optional get_value()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstAssignProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_key: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstAssignProp {}
unsafe impl Sync for JavaSwc4jAstAssignProp {}

#[allow(dead_code)]
impl JavaSwc4jAstAssignProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstAssignProp")
      .expect("Couldn't find class Swc4jAstAssignProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstAssignProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstAssignProp::new");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstAssignProp.getKey");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstAssignProp.getValue");
    JavaSwc4jAstAssignProp {
      class,
      method_construct,
      method_get_key,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    value: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let value = object_to_jvalue!(value);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, value, span],
        "Swc4jAstAssignProp construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "Swc4jAstIdent get_key()"
      )?;
    Ok(return_value)
  }

  pub fn get_value<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "ISwc4jAstExpr get_value()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstAutoAccessor {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_accessibility: JMethodID,
  method_get_decorators: JMethodID,
  method_get_key: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_value: JMethodID,
  method_is_abstract: JMethodID,
  method_is_definite: JMethodID,
  method_is_override: JMethodID,
  method_is_static: JMethodID,
}
unsafe impl Send for JavaSwc4jAstAutoAccessor {}
unsafe impl Sync for JavaSwc4jAstAutoAccessor {}

#[allow(dead_code)]
impl JavaSwc4jAstAutoAccessor {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstAutoAccessor")
      .expect("Couldn't find class Swc4jAstAutoAccessor");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstAutoAccessor");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstKey;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;ZLjava/util/List;Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstAccessibility;ZZZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstAutoAccessor::new");
    let method_get_accessibility = env
      .get_method_id(
        &class,
        "getAccessibility",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstAutoAccessor.getAccessibility");
    let method_get_decorators = env
      .get_method_id(
        &class,
        "getDecorators",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstAutoAccessor.getDecorators");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstKey;",
      )
      .expect("Couldn't find method Swc4jAstAutoAccessor.getKey");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstAutoAccessor.getTypeAnn");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstAutoAccessor.getValue");
    let method_is_abstract = env
      .get_method_id(
        &class,
        "isAbstract",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstAutoAccessor.isAbstract");
    let method_is_definite = env
      .get_method_id(
        &class,
        "isDefinite",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstAutoAccessor.isDefinite");
    let method_is_override = env
      .get_method_id(
        &class,
        "isOverride",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstAutoAccessor.isOverride");
    let method_is_static = env
      .get_method_id(
        &class,
        "isStatic",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstAutoAccessor.isStatic");
    JavaSwc4jAstAutoAccessor {
      class,
      method_construct,
      method_get_accessibility,
      method_get_decorators,
      method_get_key,
      method_get_type_ann,
      method_get_value,
      method_is_abstract,
      method_is_definite,
      method_is_override,
      method_is_static,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    value: &Option<JObject>,
    type_ann: &Option<JObject>,
    is_static: bool,
    decorators: &JObject<'_>,
    accessibility: &Option<JObject>,
    is_abstract: bool,
    is_override: bool,
    definite: bool,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let value = optional_object_to_jvalue!(value);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let is_static = boolean_to_jvalue!(is_static);
    let decorators = object_to_jvalue!(decorators);
    let accessibility = optional_object_to_jvalue!(accessibility);
    let is_abstract = boolean_to_jvalue!(is_abstract);
    let is_override = boolean_to_jvalue!(is_override);
    let definite = boolean_to_jvalue!(definite);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, value, type_ann, is_static, decorators, accessibility, is_abstract, is_override, definite, span],
        "Swc4jAstAutoAccessor construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_accessibility<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_accessibility,
        &[],
        "Optional get_accessibility()"
      )?;
    Ok(return_value)
  }

  pub fn get_decorators<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decorators,
        &[],
        "List get_decorators()"
      )?;
    Ok(return_value)
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstKey get_key()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      )?;
    Ok(return_value)
  }

  pub fn get_value<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "Optional get_value()"
      )?;
    Ok(return_value)
  }

  pub fn is_abstract<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_abstract,
        &[],
        "boolean is_abstract()"
      )?;
    Ok(return_value)
  }

  pub fn is_definite<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_definite,
        &[],
        "boolean is_definite()"
      )?;
    Ok(return_value)
  }

  pub fn is_override<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_override,
        &[],
        "boolean is_override()"
      )?;
    Ok(return_value)
  }

  pub fn is_static<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_static,
        &[],
        "boolean is_static()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstAwaitExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_arg: JMethodID,
}
unsafe impl Send for JavaSwc4jAstAwaitExpr {}
unsafe impl Sync for JavaSwc4jAstAwaitExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstAwaitExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstAwaitExpr")
      .expect("Couldn't find class Swc4jAstAwaitExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstAwaitExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstAwaitExpr::new");
    let method_get_arg = env
      .get_method_id(
        &class,
        "getArg",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstAwaitExpr.getArg");
    JavaSwc4jAstAwaitExpr {
      class,
      method_construct,
      method_get_arg,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    arg: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let arg = object_to_jvalue!(arg);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[arg, span],
        "Swc4jAstAwaitExpr construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_arg<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_arg,
        &[],
        "ISwc4jAstExpr get_arg()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstBigInt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_raw: JMethodID,
  method_get_sign: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstBigInt {}
unsafe impl Sync for JavaSwc4jAstBigInt {}

#[allow(dead_code)]
impl JavaSwc4jAstBigInt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstBigInt")
      .expect("Couldn't find class Swc4jAstBigInt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstBigInt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstBigIntSign;Ljava/lang/String;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstBigInt::new");
    let method_get_raw = env
      .get_method_id(
        &class,
        "getRaw",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstBigInt.getRaw");
    let method_get_sign = env
      .get_method_id(
        &class,
        "getSign",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstBigIntSign;",
      )
      .expect("Couldn't find method Swc4jAstBigInt.getSign");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Ljava/math/BigInteger;",
      )
      .expect("Couldn't find method Swc4jAstBigInt.getValue");
    JavaSwc4jAstBigInt {
      class,
      method_construct,
      method_get_raw,
      method_get_sign,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    sign: &JObject<'_>,
    raw: &Option<String>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let sign = object_to_jvalue!(sign);
    let java_raw = optional_string_to_jstring!(env, &raw);
    let raw = object_to_jvalue!(java_raw);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[sign, raw, span],
        "Swc4jAstBigInt construct()"
      )?;
    delete_local_ref!(env, java_raw);
    Ok(return_value)
  }

  pub fn get_raw<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_raw,
        &[],
        "Optional get_raw()"
      )?;
    Ok(return_value)
  }

  pub fn get_sign<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_sign,
        &[],
        "Swc4jAstBigIntSign get_sign()"
      )?;
    Ok(return_value)
  }

  pub fn get_value<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "BigInteger get_value()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstBinExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_left: JMethodID,
  method_get_op: JMethodID,
  method_get_right: JMethodID,
}
unsafe impl Send for JavaSwc4jAstBinExpr {}
unsafe impl Sync for JavaSwc4jAstBinExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstBinExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstBinExpr")
      .expect("Couldn't find class Swc4jAstBinExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstBinExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstBinaryOp;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstBinExpr::new");
    let method_get_left = env
      .get_method_id(
        &class,
        "getLeft",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstBinExpr.getLeft");
    let method_get_op = env
      .get_method_id(
        &class,
        "getOp",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstBinaryOp;",
      )
      .expect("Couldn't find method Swc4jAstBinExpr.getOp");
    let method_get_right = env
      .get_method_id(
        &class,
        "getRight",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstBinExpr.getRight");
    JavaSwc4jAstBinExpr {
      class,
      method_construct,
      method_get_left,
      method_get_op,
      method_get_right,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    op: &JObject<'_>,
    left: &JObject<'_>,
    right: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let op = object_to_jvalue!(op);
    let left = object_to_jvalue!(left);
    let right = object_to_jvalue!(right);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[op, left, right, span],
        "Swc4jAstBinExpr construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_left<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_left,
        &[],
        "ISwc4jAstExpr get_left()"
      )?;
    Ok(return_value)
  }

  pub fn get_op<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_op,
        &[],
        "Swc4jAstBinaryOp get_op()"
      )?;
    Ok(return_value)
  }

  pub fn get_right<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_right,
        &[],
        "ISwc4jAstExpr get_right()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstBindingIdent {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_id: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstBindingIdent {}
unsafe impl Sync for JavaSwc4jAstBindingIdent {}

#[allow(dead_code)]
impl JavaSwc4jAstBindingIdent {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/pat/Swc4jAstBindingIdent")
      .expect("Couldn't find class Swc4jAstBindingIdent");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstBindingIdent");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstBindingIdent::new");
    let method_get_id = env
      .get_method_id(
        &class,
        "getId",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstBindingIdent.getId");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstBindingIdent.getTypeAnn");
    JavaSwc4jAstBindingIdent {
      class,
      method_construct,
      method_get_id,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    id: &JObject<'_>,
    type_ann: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let id = object_to_jvalue!(id);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[id, type_ann, span],
        "Swc4jAstBindingIdent construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_id<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_id,
        &[],
        "Swc4jAstIdent get_id()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstBlockStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_ctxt: JMethodID,
  method_get_stmts: JMethodID,
}
unsafe impl Send for JavaSwc4jAstBlockStmt {}
unsafe impl Sync for JavaSwc4jAstBlockStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstBlockStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt")
      .expect("Couldn't find class Swc4jAstBlockStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstBlockStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ILjava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstBlockStmt::new");
    let method_get_ctxt = env
      .get_method_id(
        &class,
        "getCtxt",
        "()I",
      )
      .expect("Couldn't find method Swc4jAstBlockStmt.getCtxt");
    let method_get_stmts = env
      .get_method_id(
        &class,
        "getStmts",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstBlockStmt.getStmts");
    JavaSwc4jAstBlockStmt {
      class,
      method_construct,
      method_get_ctxt,
      method_get_stmts,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    ctxt: SyntaxContext,
    stmts: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let ctxt = ctxt.as_u32() as i32;
    let ctxt = int_to_jvalue!(ctxt);
    let stmts = object_to_jvalue!(stmts);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[ctxt, stmts, span],
        "Swc4jAstBlockStmt construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_ctxt<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<i32>
  {
    let return_value = call_as_int!(
        env,
        obj,
        self.method_get_ctxt,
        &[],
        "int get_ctxt()"
      )?;
    Ok(return_value)
  }

  pub fn get_stmts<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_stmts,
        &[],
        "List get_stmts()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstBool {
  class: GlobalRef,
  method_construct: JMethodID,
  method_is_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstBool {}
unsafe impl Sync for JavaSwc4jAstBool {}

#[allow(dead_code)]
impl JavaSwc4jAstBool {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstBool")
      .expect("Couldn't find class Swc4jAstBool");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstBool");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstBool::new");
    let method_is_value = env
      .get_method_id(
        &class,
        "isValue",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstBool.isValue");
    JavaSwc4jAstBool {
      class,
      method_construct,
      method_is_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    value: bool,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let value = boolean_to_jvalue!(value);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[value, span],
        "Swc4jAstBool construct()"
      )?;
    Ok(return_value)
  }

  pub fn is_value<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_value,
        &[],
        "boolean is_value()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstBreakStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_label: JMethodID,
}
unsafe impl Send for JavaSwc4jAstBreakStmt {}
unsafe impl Sync for JavaSwc4jAstBreakStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstBreakStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstBreakStmt")
      .expect("Couldn't find class Swc4jAstBreakStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstBreakStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstBreakStmt::new");
    let method_get_label = env
      .get_method_id(
        &class,
        "getLabel",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstBreakStmt.getLabel");
    JavaSwc4jAstBreakStmt {
      class,
      method_construct,
      method_get_label,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    label: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let label = optional_object_to_jvalue!(label);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[label, span],
        "Swc4jAstBreakStmt construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_label<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_label,
        &[],
        "Optional get_label()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstCallExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_args: JMethodID,
  method_get_callee: JMethodID,
  method_get_ctxt: JMethodID,
  method_get_type_args: JMethodID,
}
unsafe impl Send for JavaSwc4jAstCallExpr {}
unsafe impl Sync for JavaSwc4jAstCallExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstCallExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstCallExpr")
      .expect("Couldn't find class Swc4jAstCallExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstCallExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ILcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstCallee;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstCallExpr::new");
    let method_get_args = env
      .get_method_id(
        &class,
        "getArgs",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstCallExpr.getArgs");
    let method_get_callee = env
      .get_method_id(
        &class,
        "getCallee",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstCallee;",
      )
      .expect("Couldn't find method Swc4jAstCallExpr.getCallee");
    let method_get_ctxt = env
      .get_method_id(
        &class,
        "getCtxt",
        "()I",
      )
      .expect("Couldn't find method Swc4jAstCallExpr.getCtxt");
    let method_get_type_args = env
      .get_method_id(
        &class,
        "getTypeArgs",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstCallExpr.getTypeArgs");
    JavaSwc4jAstCallExpr {
      class,
      method_construct,
      method_get_args,
      method_get_callee,
      method_get_ctxt,
      method_get_type_args,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    ctxt: SyntaxContext,
    callee: &JObject<'_>,
    args: &JObject<'_>,
    type_args: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let ctxt = ctxt.as_u32() as i32;
    let ctxt = int_to_jvalue!(ctxt);
    let callee = object_to_jvalue!(callee);
    let args = object_to_jvalue!(args);
    let type_args = optional_object_to_jvalue!(type_args);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[ctxt, callee, args, type_args, span],
        "Swc4jAstCallExpr construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_args,
        &[],
        "List get_args()"
      )?;
    Ok(return_value)
  }

  pub fn get_callee<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_callee,
        &[],
        "ISwc4jAstCallee get_callee()"
      )?;
    Ok(return_value)
  }

  pub fn get_ctxt<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<i32>
  {
    let return_value = call_as_int!(
        env,
        obj,
        self.method_get_ctxt,
        &[],
        "int get_ctxt()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_args,
        &[],
        "Optional get_type_args()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstCatchClause {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_param: JMethodID,
}
unsafe impl Send for JavaSwc4jAstCatchClause {}
unsafe impl Sync for JavaSwc4jAstCatchClause {}

#[allow(dead_code)]
impl JavaSwc4jAstCatchClause {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/miscs/Swc4jAstCatchClause")
      .expect("Couldn't find class Swc4jAstCatchClause");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstCatchClause");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstCatchClause::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;",
      )
      .expect("Couldn't find method Swc4jAstCatchClause.getBody");
    let method_get_param = env
      .get_method_id(
        &class,
        "getParam",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstCatchClause.getParam");
    JavaSwc4jAstCatchClause {
      class,
      method_construct,
      method_get_body,
      method_get_param,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    param: &Option<JObject>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let param = optional_object_to_jvalue!(param);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[param, body, span],
        "Swc4jAstCatchClause construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "Swc4jAstBlockStmt get_body()"
      )?;
    Ok(return_value)
  }

  pub fn get_param<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_param,
        &[],
        "Optional get_param()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstClass {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_ctxt: JMethodID,
  method_get_decorators: JMethodID,
  method_get_implements: JMethodID,
  method_get_super_class: JMethodID,
  method_get_super_type_params: JMethodID,
  method_get_type_params: JMethodID,
  method_is_abstract: JMethodID,
}
unsafe impl Send for JavaSwc4jAstClass {}
unsafe impl Sync for JavaSwc4jAstClass {}

#[allow(dead_code)]
impl JavaSwc4jAstClass {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstClass")
      .expect("Couldn't find class Swc4jAstClass");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstClass");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ILjava/util/List;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;ZLcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstClass::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstClass.getBody");
    let method_get_ctxt = env
      .get_method_id(
        &class,
        "getCtxt",
        "()I",
      )
      .expect("Couldn't find method Swc4jAstClass.getCtxt");
    let method_get_decorators = env
      .get_method_id(
        &class,
        "getDecorators",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstClass.getDecorators");
    let method_get_implements = env
      .get_method_id(
        &class,
        "getImplements",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstClass.getImplements");
    let method_get_super_class = env
      .get_method_id(
        &class,
        "getSuperClass",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstClass.getSuperClass");
    let method_get_super_type_params = env
      .get_method_id(
        &class,
        "getSuperTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstClass.getSuperTypeParams");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstClass.getTypeParams");
    let method_is_abstract = env
      .get_method_id(
        &class,
        "isAbstract",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClass.isAbstract");
    JavaSwc4jAstClass {
      class,
      method_construct,
      method_get_body,
      method_get_ctxt,
      method_get_decorators,
      method_get_implements,
      method_get_super_class,
      method_get_super_type_params,
      method_get_type_params,
      method_is_abstract,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    ctxt: SyntaxContext,
    decorators: &JObject<'_>,
    body: &JObject<'_>,
    super_class: &Option<JObject>,
    is_abstract: bool,
    type_params: &Option<JObject>,
    super_type_params: &Option<JObject>,
    implements: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let ctxt = ctxt.as_u32() as i32;
    let ctxt = int_to_jvalue!(ctxt);
    let decorators = object_to_jvalue!(decorators);
    let body = object_to_jvalue!(body);
    let super_class = optional_object_to_jvalue!(super_class);
    let is_abstract = boolean_to_jvalue!(is_abstract);
    let type_params = optional_object_to_jvalue!(type_params);
    let super_type_params = optional_object_to_jvalue!(super_type_params);
    let implements = object_to_jvalue!(implements);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[ctxt, decorators, body, super_class, is_abstract, type_params, super_type_params, implements, span],
        "Swc4jAstClass construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "List get_body()"
      )?;
    Ok(return_value)
  }

  pub fn get_ctxt<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<i32>
  {
    let return_value = call_as_int!(
        env,
        obj,
        self.method_get_ctxt,
        &[],
        "int get_ctxt()"
      )?;
    Ok(return_value)
  }

  pub fn get_decorators<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decorators,
        &[],
        "List get_decorators()"
      )?;
    Ok(return_value)
  }

  pub fn get_implements<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_implements,
        &[],
        "List get_implements()"
      )?;
    Ok(return_value)
  }

  pub fn get_super_class<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_super_class,
        &[],
        "Optional get_super_class()"
      )?;
    Ok(return_value)
  }

  pub fn get_super_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_super_type_params,
        &[],
        "Optional get_super_type_params()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      )?;
    Ok(return_value)
  }

  pub fn is_abstract<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_abstract,
        &[],
        "boolean is_abstract()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstClassDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_clazz: JMethodID,
  method_get_ident: JMethodID,
  method_is_declare: JMethodID,
}
unsafe impl Send for JavaSwc4jAstClassDecl {}
unsafe impl Sync for JavaSwc4jAstClassDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstClassDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstClassDecl")
      .expect("Couldn't find class Swc4jAstClassDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstClassDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;ZLcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstClass;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstClassDecl::new");
    let method_get_clazz = env
      .get_method_id(
        &class,
        "getClazz",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstClass;",
      )
      .expect("Couldn't find method Swc4jAstClassDecl.getClazz");
    let method_get_ident = env
      .get_method_id(
        &class,
        "getIdent",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstClassDecl.getIdent");
    let method_is_declare = env
      .get_method_id(
        &class,
        "isDeclare",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassDecl.isDeclare");
    JavaSwc4jAstClassDecl {
      class,
      method_construct,
      method_get_clazz,
      method_get_ident,
      method_is_declare,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    ident: &JObject<'_>,
    declare: bool,
    clazz: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let ident = object_to_jvalue!(ident);
    let declare = boolean_to_jvalue!(declare);
    let clazz = object_to_jvalue!(clazz);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[ident, declare, clazz, span],
        "Swc4jAstClassDecl construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_clazz<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_clazz,
        &[],
        "Swc4jAstClass get_clazz()"
      )?;
    Ok(return_value)
  }

  pub fn get_ident<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_ident,
        &[],
        "Swc4jAstIdent get_ident()"
      )?;
    Ok(return_value)
  }

  pub fn is_declare<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_declare,
        &[],
        "boolean is_declare()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstClassExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_clazz: JMethodID,
  method_get_ident: JMethodID,
}
unsafe impl Send for JavaSwc4jAstClassExpr {}
unsafe impl Sync for JavaSwc4jAstClassExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstClassExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstClassExpr")
      .expect("Couldn't find class Swc4jAstClassExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstClassExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstClass;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstClassExpr::new");
    let method_get_clazz = env
      .get_method_id(
        &class,
        "getClazz",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstClass;",
      )
      .expect("Couldn't find method Swc4jAstClassExpr.getClazz");
    let method_get_ident = env
      .get_method_id(
        &class,
        "getIdent",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstClassExpr.getIdent");
    JavaSwc4jAstClassExpr {
      class,
      method_construct,
      method_get_clazz,
      method_get_ident,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    ident: &Option<JObject>,
    clazz: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let ident = optional_object_to_jvalue!(ident);
    let clazz = object_to_jvalue!(clazz);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[ident, clazz, span],
        "Swc4jAstClassExpr construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_clazz<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_clazz,
        &[],
        "Swc4jAstClass get_clazz()"
      )?;
    Ok(return_value)
  }

  pub fn get_ident<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_ident,
        &[],
        "Optional get_ident()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstClassMethod {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_accessibility: JMethodID,
  method_get_function: JMethodID,
  method_get_key: JMethodID,
  method_get_kind: JMethodID,
  method_is_abstract: JMethodID,
  method_is_optional: JMethodID,
  method_is_override: JMethodID,
  method_is_static: JMethodID,
}
unsafe impl Send for JavaSwc4jAstClassMethod {}
unsafe impl Sync for JavaSwc4jAstClassMethod {}

#[allow(dead_code)]
impl JavaSwc4jAstClassMethod {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstClassMethod")
      .expect("Couldn't find class Swc4jAstClassMethod");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstClassMethod");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstMethodKind;ZLcom/caoccao/javet/swc4j/ast/enums/Swc4jAstAccessibility;ZZZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstClassMethod::new");
    let method_get_accessibility = env
      .get_method_id(
        &class,
        "getAccessibility",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstClassMethod.getAccessibility");
    let method_get_function = env
      .get_method_id(
        &class,
        "getFunction",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;",
      )
      .expect("Couldn't find method Swc4jAstClassMethod.getFunction");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;",
      )
      .expect("Couldn't find method Swc4jAstClassMethod.getKey");
    let method_get_kind = env
      .get_method_id(
        &class,
        "getKind",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstMethodKind;",
      )
      .expect("Couldn't find method Swc4jAstClassMethod.getKind");
    let method_is_abstract = env
      .get_method_id(
        &class,
        "isAbstract",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassMethod.isAbstract");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassMethod.isOptional");
    let method_is_override = env
      .get_method_id(
        &class,
        "isOverride",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassMethod.isOverride");
    let method_is_static = env
      .get_method_id(
        &class,
        "isStatic",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassMethod.isStatic");
    JavaSwc4jAstClassMethod {
      class,
      method_construct,
      method_get_accessibility,
      method_get_function,
      method_get_key,
      method_get_kind,
      method_is_abstract,
      method_is_optional,
      method_is_override,
      method_is_static,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    function: &JObject<'_>,
    kind: &JObject<'_>,
    is_static: bool,
    accessibility: &Option<JObject>,
    is_abstract: bool,
    optional: bool,
    is_override: bool,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let function = object_to_jvalue!(function);
    let kind = object_to_jvalue!(kind);
    let is_static = boolean_to_jvalue!(is_static);
    let accessibility = optional_object_to_jvalue!(accessibility);
    let is_abstract = boolean_to_jvalue!(is_abstract);
    let optional = boolean_to_jvalue!(optional);
    let is_override = boolean_to_jvalue!(is_override);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, function, kind, is_static, accessibility, is_abstract, optional, is_override, span],
        "Swc4jAstClassMethod construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_accessibility<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_accessibility,
        &[],
        "Optional get_accessibility()"
      )?;
    Ok(return_value)
  }

  pub fn get_function<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_function,
        &[],
        "Swc4jAstFunction get_function()"
      )?;
    Ok(return_value)
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstPropName get_key()"
      )?;
    Ok(return_value)
  }

  pub fn get_kind<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_kind,
        &[],
        "Swc4jAstMethodKind get_kind()"
      )?;
    Ok(return_value)
  }

  pub fn is_abstract<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_abstract,
        &[],
        "boolean is_abstract()"
      )?;
    Ok(return_value)
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      )?;
    Ok(return_value)
  }

  pub fn is_override<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_override,
        &[],
        "boolean is_override()"
      )?;
    Ok(return_value)
  }

  pub fn is_static<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_static,
        &[],
        "boolean is_static()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstClassProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_accessibility: JMethodID,
  method_get_decorators: JMethodID,
  method_get_key: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_value: JMethodID,
  method_is_abstract: JMethodID,
  method_is_declare: JMethodID,
  method_is_definite: JMethodID,
  method_is_optional: JMethodID,
  method_is_override: JMethodID,
  method_is_readonly: JMethodID,
  method_is_static: JMethodID,
}
unsafe impl Send for JavaSwc4jAstClassProp {}
unsafe impl Sync for JavaSwc4jAstClassProp {}

#[allow(dead_code)]
impl JavaSwc4jAstClassProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstClassProp")
      .expect("Couldn't find class Swc4jAstClassProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstClassProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;ZLjava/util/List;Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstAccessibility;ZZZZZZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstClassProp::new");
    let method_get_accessibility = env
      .get_method_id(
        &class,
        "getAccessibility",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstClassProp.getAccessibility");
    let method_get_decorators = env
      .get_method_id(
        &class,
        "getDecorators",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstClassProp.getDecorators");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;",
      )
      .expect("Couldn't find method Swc4jAstClassProp.getKey");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstClassProp.getTypeAnn");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstClassProp.getValue");
    let method_is_abstract = env
      .get_method_id(
        &class,
        "isAbstract",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassProp.isAbstract");
    let method_is_declare = env
      .get_method_id(
        &class,
        "isDeclare",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassProp.isDeclare");
    let method_is_definite = env
      .get_method_id(
        &class,
        "isDefinite",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassProp.isDefinite");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassProp.isOptional");
    let method_is_override = env
      .get_method_id(
        &class,
        "isOverride",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassProp.isOverride");
    let method_is_readonly = env
      .get_method_id(
        &class,
        "isReadonly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassProp.isReadonly");
    let method_is_static = env
      .get_method_id(
        &class,
        "isStatic",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstClassProp.isStatic");
    JavaSwc4jAstClassProp {
      class,
      method_construct,
      method_get_accessibility,
      method_get_decorators,
      method_get_key,
      method_get_type_ann,
      method_get_value,
      method_is_abstract,
      method_is_declare,
      method_is_definite,
      method_is_optional,
      method_is_override,
      method_is_readonly,
      method_is_static,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    value: &Option<JObject>,
    type_ann: &Option<JObject>,
    is_static: bool,
    decorators: &JObject<'_>,
    accessibility: &Option<JObject>,
    is_abstract: bool,
    optional: bool,
    is_override: bool,
    readonly: bool,
    declare: bool,
    definite: bool,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let value = optional_object_to_jvalue!(value);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let is_static = boolean_to_jvalue!(is_static);
    let decorators = object_to_jvalue!(decorators);
    let accessibility = optional_object_to_jvalue!(accessibility);
    let is_abstract = boolean_to_jvalue!(is_abstract);
    let optional = boolean_to_jvalue!(optional);
    let is_override = boolean_to_jvalue!(is_override);
    let readonly = boolean_to_jvalue!(readonly);
    let declare = boolean_to_jvalue!(declare);
    let definite = boolean_to_jvalue!(definite);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, value, type_ann, is_static, decorators, accessibility, is_abstract, optional, is_override, readonly, declare, definite, span],
        "Swc4jAstClassProp construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_accessibility<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_accessibility,
        &[],
        "Optional get_accessibility()"
      )?;
    Ok(return_value)
  }

  pub fn get_decorators<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decorators,
        &[],
        "List get_decorators()"
      )?;
    Ok(return_value)
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstPropName get_key()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      )?;
    Ok(return_value)
  }

  pub fn get_value<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "Optional get_value()"
      )?;
    Ok(return_value)
  }

  pub fn is_abstract<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_abstract,
        &[],
        "boolean is_abstract()"
      )?;
    Ok(return_value)
  }

  pub fn is_declare<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_declare,
        &[],
        "boolean is_declare()"
      )?;
    Ok(return_value)
  }

  pub fn is_definite<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_definite,
        &[],
        "boolean is_definite()"
      )?;
    Ok(return_value)
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      )?;
    Ok(return_value)
  }

  pub fn is_override<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_override,
        &[],
        "boolean is_override()"
      )?;
    Ok(return_value)
  }

  pub fn is_readonly<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_readonly,
        &[],
        "boolean is_readonly()"
      )?;
    Ok(return_value)
  }

  pub fn is_static<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_static,
        &[],
        "boolean is_static()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstComputedPropName {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstComputedPropName {}
unsafe impl Sync for JavaSwc4jAstComputedPropName {}

#[allow(dead_code)]
impl JavaSwc4jAstComputedPropName {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstComputedPropName")
      .expect("Couldn't find class Swc4jAstComputedPropName");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstComputedPropName");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstComputedPropName::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstComputedPropName.getExpr");
    JavaSwc4jAstComputedPropName {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstComputedPropName construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstCondExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_alt: JMethodID,
  method_get_cons: JMethodID,
  method_get_test: JMethodID,
}
unsafe impl Send for JavaSwc4jAstCondExpr {}
unsafe impl Sync for JavaSwc4jAstCondExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstCondExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstCondExpr")
      .expect("Couldn't find class Swc4jAstCondExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstCondExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstCondExpr::new");
    let method_get_alt = env
      .get_method_id(
        &class,
        "getAlt",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstCondExpr.getAlt");
    let method_get_cons = env
      .get_method_id(
        &class,
        "getCons",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstCondExpr.getCons");
    let method_get_test = env
      .get_method_id(
        &class,
        "getTest",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstCondExpr.getTest");
    JavaSwc4jAstCondExpr {
      class,
      method_construct,
      method_get_alt,
      method_get_cons,
      method_get_test,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    test: &JObject<'_>,
    cons: &JObject<'_>,
    alt: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let test = object_to_jvalue!(test);
    let cons = object_to_jvalue!(cons);
    let alt = object_to_jvalue!(alt);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[test, cons, alt, span],
        "Swc4jAstCondExpr construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_alt<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_alt,
        &[],
        "ISwc4jAstExpr get_alt()"
      )?;
    Ok(return_value)
  }

  pub fn get_cons<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_cons,
        &[],
        "ISwc4jAstExpr get_cons()"
      )?;
    Ok(return_value)
  }

  pub fn get_test<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_test,
        &[],
        "ISwc4jAstExpr get_test()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstConstructor {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_accessibility: JMethodID,
  method_get_body: JMethodID,
  method_get_ctxt: JMethodID,
  method_get_key: JMethodID,
  method_get_params: JMethodID,
  method_is_optional: JMethodID,
}
unsafe impl Send for JavaSwc4jAstConstructor {}
unsafe impl Sync for JavaSwc4jAstConstructor {}

#[allow(dead_code)]
impl JavaSwc4jAstConstructor {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstConstructor")
      .expect("Couldn't find class Swc4jAstConstructor");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstConstructor");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ILcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstAccessibility;ZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstConstructor::new");
    let method_get_accessibility = env
      .get_method_id(
        &class,
        "getAccessibility",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstConstructor.getAccessibility");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstConstructor.getBody");
    let method_get_ctxt = env
      .get_method_id(
        &class,
        "getCtxt",
        "()I",
      )
      .expect("Couldn't find method Swc4jAstConstructor.getCtxt");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;",
      )
      .expect("Couldn't find method Swc4jAstConstructor.getKey");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstConstructor.getParams");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstConstructor.isOptional");
    JavaSwc4jAstConstructor {
      class,
      method_construct,
      method_get_accessibility,
      method_get_body,
      method_get_ctxt,
      method_get_key,
      method_get_params,
      method_is_optional,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    ctxt: SyntaxContext,
    key: &JObject<'_>,
    params: &JObject<'_>,
    body: &Option<JObject>,
    accessibility: &Option<JObject>,
    optional: bool,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let ctxt = ctxt.as_u32() as i32;
    let ctxt = int_to_jvalue!(ctxt);
    let key = object_to_jvalue!(key);
    let params = object_to_jvalue!(params);
    let body = optional_object_to_jvalue!(body);
    let accessibility = optional_object_to_jvalue!(accessibility);
    let optional = boolean_to_jvalue!(optional);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[ctxt, key, params, body, accessibility, optional, span],
        "Swc4jAstConstructor construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_accessibility<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_accessibility,
        &[],
        "Optional get_accessibility()"
      )?;
    Ok(return_value)
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "Optional get_body()"
      )?;
    Ok(return_value)
  }

  pub fn get_ctxt<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<i32>
  {
    let return_value = call_as_int!(
        env,
        obj,
        self.method_get_ctxt,
        &[],
        "int get_ctxt()"
      )?;
    Ok(return_value)
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstPropName get_key()"
      )?;
    Ok(return_value)
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      )?;
    Ok(return_value)
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstContinueStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_label: JMethodID,
}
unsafe impl Send for JavaSwc4jAstContinueStmt {}
unsafe impl Sync for JavaSwc4jAstContinueStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstContinueStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstContinueStmt")
      .expect("Couldn't find class Swc4jAstContinueStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstContinueStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstContinueStmt::new");
    let method_get_label = env
      .get_method_id(
        &class,
        "getLabel",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstContinueStmt.getLabel");
    JavaSwc4jAstContinueStmt {
      class,
      method_construct,
      method_get_label,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    label: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let label = optional_object_to_jvalue!(label);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[label, span],
        "Swc4jAstContinueStmt construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_label<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_label,
        &[],
        "Optional get_label()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstDebuggerStmt {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstDebuggerStmt {}
unsafe impl Sync for JavaSwc4jAstDebuggerStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstDebuggerStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstDebuggerStmt")
      .expect("Couldn't find class Swc4jAstDebuggerStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstDebuggerStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstDebuggerStmt::new");
    JavaSwc4jAstDebuggerStmt {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstDebuggerStmt construct()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstDecorator {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstDecorator {}
unsafe impl Sync for JavaSwc4jAstDecorator {}

#[allow(dead_code)]
impl JavaSwc4jAstDecorator {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstDecorator")
      .expect("Couldn't find class Swc4jAstDecorator");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstDecorator");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstDecorator::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstDecorator.getExpr");
    JavaSwc4jAstDecorator {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstDecorator construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstDoWhileStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_test: JMethodID,
}
unsafe impl Send for JavaSwc4jAstDoWhileStmt {}
unsafe impl Sync for JavaSwc4jAstDoWhileStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstDoWhileStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstDoWhileStmt")
      .expect("Couldn't find class Swc4jAstDoWhileStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstDoWhileStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstDoWhileStmt::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;",
      )
      .expect("Couldn't find method Swc4jAstDoWhileStmt.getBody");
    let method_get_test = env
      .get_method_id(
        &class,
        "getTest",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstDoWhileStmt.getTest");
    JavaSwc4jAstDoWhileStmt {
      class,
      method_construct,
      method_get_body,
      method_get_test,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    test: &JObject<'_>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let test = object_to_jvalue!(test);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[test, body, span],
        "Swc4jAstDoWhileStmt construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "ISwc4jAstStmt get_body()"
      )?;
    Ok(return_value)
  }

  pub fn get_test<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_test,
        &[],
        "ISwc4jAstExpr get_test()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstEmptyStmt {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstEmptyStmt {}
unsafe impl Sync for JavaSwc4jAstEmptyStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstEmptyStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstEmptyStmt")
      .expect("Couldn't find class Swc4jAstEmptyStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstEmptyStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstEmptyStmt::new");
    JavaSwc4jAstEmptyStmt {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstEmptyStmt construct()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstExportAll {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_src: JMethodID,
  method_get_with: JMethodID,
  method_is_type_only: JMethodID,
}
unsafe impl Send for JavaSwc4jAstExportAll {}
unsafe impl Sync for JavaSwc4jAstExportAll {}

#[allow(dead_code)]
impl JavaSwc4jAstExportAll {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstExportAll")
      .expect("Couldn't find class Swc4jAstExportAll");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstExportAll");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr;ZLcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstObjectLit;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstExportAll::new");
    let method_get_src = env
      .get_method_id(
        &class,
        "getSrc",
        "()Lcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr;",
      )
      .expect("Couldn't find method Swc4jAstExportAll.getSrc");
    let method_get_with = env
      .get_method_id(
        &class,
        "getWith",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstExportAll.getWith");
    let method_is_type_only = env
      .get_method_id(
        &class,
        "isTypeOnly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstExportAll.isTypeOnly");
    JavaSwc4jAstExportAll {
      class,
      method_construct,
      method_get_src,
      method_get_with,
      method_is_type_only,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    src: &JObject<'_>,
    type_only: bool,
    with: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let src = object_to_jvalue!(src);
    let type_only = boolean_to_jvalue!(type_only);
    let with = optional_object_to_jvalue!(with);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[src, type_only, with, span],
        "Swc4jAstExportAll construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_src<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_src,
        &[],
        "Swc4jAstStr get_src()"
      )?;
    Ok(return_value)
  }

  pub fn get_with<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_with,
        &[],
        "Optional get_with()"
      )?;
    Ok(return_value)
  }

  pub fn is_type_only<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_type_only,
        &[],
        "boolean is_type_only()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstExportDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_decl: JMethodID,
}
unsafe impl Send for JavaSwc4jAstExportDecl {}
unsafe impl Sync for JavaSwc4jAstExportDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstExportDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstExportDecl")
      .expect("Couldn't find class Swc4jAstExportDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstExportDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstDecl;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstExportDecl::new");
    let method_get_decl = env
      .get_method_id(
        &class,
        "getDecl",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstDecl;",
      )
      .expect("Couldn't find method Swc4jAstExportDecl.getDecl");
    JavaSwc4jAstExportDecl {
      class,
      method_construct,
      method_get_decl,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    decl: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let decl = object_to_jvalue!(decl);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[decl, span],
        "Swc4jAstExportDecl construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_decl<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decl,
        &[],
        "ISwc4jAstDecl get_decl()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstExportDefaultDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_decl: JMethodID,
}
unsafe impl Send for JavaSwc4jAstExportDefaultDecl {}
unsafe impl Sync for JavaSwc4jAstExportDefaultDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstExportDefaultDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstExportDefaultDecl")
      .expect("Couldn't find class Swc4jAstExportDefaultDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstExportDefaultDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstDefaultDecl;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstExportDefaultDecl::new");
    let method_get_decl = env
      .get_method_id(
        &class,
        "getDecl",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstDefaultDecl;",
      )
      .expect("Couldn't find method Swc4jAstExportDefaultDecl.getDecl");
    JavaSwc4jAstExportDefaultDecl {
      class,
      method_construct,
      method_get_decl,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    decl: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let decl = object_to_jvalue!(decl);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[decl, span],
        "Swc4jAstExportDefaultDecl construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_decl<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decl,
        &[],
        "ISwc4jAstDefaultDecl get_decl()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstExportDefaultExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstExportDefaultExpr {}
unsafe impl Sync for JavaSwc4jAstExportDefaultExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstExportDefaultExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstExportDefaultExpr")
      .expect("Couldn't find class Swc4jAstExportDefaultExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstExportDefaultExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstExportDefaultExpr::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstExportDefaultExpr.getExpr");
    JavaSwc4jAstExportDefaultExpr {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstExportDefaultExpr construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstExportDefaultSpecifier {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_exported: JMethodID,
}
unsafe impl Send for JavaSwc4jAstExportDefaultSpecifier {}
unsafe impl Sync for JavaSwc4jAstExportDefaultSpecifier {}

#[allow(dead_code)]
impl JavaSwc4jAstExportDefaultSpecifier {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstExportDefaultSpecifier")
      .expect("Couldn't find class Swc4jAstExportDefaultSpecifier");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstExportDefaultSpecifier");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstExportDefaultSpecifier::new");
    let method_get_exported = env
      .get_method_id(
        &class,
        "getExported",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstExportDefaultSpecifier.getExported");
    JavaSwc4jAstExportDefaultSpecifier {
      class,
      method_construct,
      method_get_exported,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    exported: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let exported = object_to_jvalue!(exported);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[exported, span],
        "Swc4jAstExportDefaultSpecifier construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_exported<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_exported,
        &[],
        "Swc4jAstIdent get_exported()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstExportNamedSpecifier {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_exported: JMethodID,
  method_get_orig: JMethodID,
  method_is_type_only: JMethodID,
}
unsafe impl Send for JavaSwc4jAstExportNamedSpecifier {}
unsafe impl Sync for JavaSwc4jAstExportNamedSpecifier {}

#[allow(dead_code)]
impl JavaSwc4jAstExportNamedSpecifier {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstExportNamedSpecifier")
      .expect("Couldn't find class Swc4jAstExportNamedSpecifier");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstExportNamedSpecifier");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstModuleExportName;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstModuleExportName;ZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstExportNamedSpecifier::new");
    let method_get_exported = env
      .get_method_id(
        &class,
        "getExported",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstExportNamedSpecifier.getExported");
    let method_get_orig = env
      .get_method_id(
        &class,
        "getOrig",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstModuleExportName;",
      )
      .expect("Couldn't find method Swc4jAstExportNamedSpecifier.getOrig");
    let method_is_type_only = env
      .get_method_id(
        &class,
        "isTypeOnly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstExportNamedSpecifier.isTypeOnly");
    JavaSwc4jAstExportNamedSpecifier {
      class,
      method_construct,
      method_get_exported,
      method_get_orig,
      method_is_type_only,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    orig: &JObject<'_>,
    exported: &Option<JObject>,
    type_only: bool,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let orig = object_to_jvalue!(orig);
    let exported = optional_object_to_jvalue!(exported);
    let type_only = boolean_to_jvalue!(type_only);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[orig, exported, type_only, span],
        "Swc4jAstExportNamedSpecifier construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_exported<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_exported,
        &[],
        "Optional get_exported()"
      )?;
    Ok(return_value)
  }

  pub fn get_orig<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_orig,
        &[],
        "ISwc4jAstModuleExportName get_orig()"
      )?;
    Ok(return_value)
  }

  pub fn is_type_only<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_type_only,
        &[],
        "boolean is_type_only()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstExportNamespaceSpecifier {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_name: JMethodID,
}
unsafe impl Send for JavaSwc4jAstExportNamespaceSpecifier {}
unsafe impl Sync for JavaSwc4jAstExportNamespaceSpecifier {}

#[allow(dead_code)]
impl JavaSwc4jAstExportNamespaceSpecifier {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstExportNamespaceSpecifier")
      .expect("Couldn't find class Swc4jAstExportNamespaceSpecifier");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstExportNamespaceSpecifier");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstModuleExportName;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstExportNamespaceSpecifier::new");
    let method_get_name = env
      .get_method_id(
        &class,
        "getName",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstModuleExportName;",
      )
      .expect("Couldn't find method Swc4jAstExportNamespaceSpecifier.getName");
    JavaSwc4jAstExportNamespaceSpecifier {
      class,
      method_construct,
      method_get_name,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    name: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let name = object_to_jvalue!(name);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[name, span],
        "Swc4jAstExportNamespaceSpecifier construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_name,
        &[],
        "ISwc4jAstModuleExportName get_name()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstExprOrSpread {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
  method_get_spread: JMethodID,
}
unsafe impl Send for JavaSwc4jAstExprOrSpread {}
unsafe impl Sync for JavaSwc4jAstExprOrSpread {}

#[allow(dead_code)]
impl JavaSwc4jAstExprOrSpread {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstExprOrSpread")
      .expect("Couldn't find class Swc4jAstExprOrSpread");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstExprOrSpread");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstExprOrSpread::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstExprOrSpread.getExpr");
    let method_get_spread = env
      .get_method_id(
        &class,
        "getSpread",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstExprOrSpread.getSpread");
    JavaSwc4jAstExprOrSpread {
      class,
      method_construct,
      method_get_expr,
      method_get_spread,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    spread: &Option<JObject>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let spread = optional_object_to_jvalue!(spread);
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[spread, expr, span],
        "Swc4jAstExprOrSpread construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      )?;
    Ok(return_value)
  }

  pub fn get_spread<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_spread,
        &[],
        "Optional get_spread()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstExprStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstExprStmt {}
unsafe impl Sync for JavaSwc4jAstExprStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstExprStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstExprStmt")
      .expect("Couldn't find class Swc4jAstExprStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstExprStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstExprStmt::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstExprStmt.getExpr");
    JavaSwc4jAstExprStmt {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstExprStmt construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstFnDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_function: JMethodID,
  method_get_ident: JMethodID,
  method_is_declare: JMethodID,
}
unsafe impl Send for JavaSwc4jAstFnDecl {}
unsafe impl Sync for JavaSwc4jAstFnDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstFnDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstFnDecl")
      .expect("Couldn't find class Swc4jAstFnDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstFnDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;ZLcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstFnDecl::new");
    let method_get_function = env
      .get_method_id(
        &class,
        "getFunction",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;",
      )
      .expect("Couldn't find method Swc4jAstFnDecl.getFunction");
    let method_get_ident = env
      .get_method_id(
        &class,
        "getIdent",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstFnDecl.getIdent");
    let method_is_declare = env
      .get_method_id(
        &class,
        "isDeclare",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstFnDecl.isDeclare");
    JavaSwc4jAstFnDecl {
      class,
      method_construct,
      method_get_function,
      method_get_ident,
      method_is_declare,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    ident: &JObject<'_>,
    declare: bool,
    function: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let ident = object_to_jvalue!(ident);
    let declare = boolean_to_jvalue!(declare);
    let function = object_to_jvalue!(function);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[ident, declare, function, span],
        "Swc4jAstFnDecl construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_function<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_function,
        &[],
        "Swc4jAstFunction get_function()"
      )?;
    Ok(return_value)
  }

  pub fn get_ident<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_ident,
        &[],
        "Swc4jAstIdent get_ident()"
      )?;
    Ok(return_value)
  }

  pub fn is_declare<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_declare,
        &[],
        "boolean is_declare()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstFnExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_function: JMethodID,
  method_get_ident: JMethodID,
}
unsafe impl Send for JavaSwc4jAstFnExpr {}
unsafe impl Sync for JavaSwc4jAstFnExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstFnExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstFnExpr")
      .expect("Couldn't find class Swc4jAstFnExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstFnExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstFnExpr::new");
    let method_get_function = env
      .get_method_id(
        &class,
        "getFunction",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;",
      )
      .expect("Couldn't find method Swc4jAstFnExpr.getFunction");
    let method_get_ident = env
      .get_method_id(
        &class,
        "getIdent",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstFnExpr.getIdent");
    JavaSwc4jAstFnExpr {
      class,
      method_construct,
      method_get_function,
      method_get_ident,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    ident: &Option<JObject>,
    function: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let ident = optional_object_to_jvalue!(ident);
    let function = object_to_jvalue!(function);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[ident, function, span],
        "Swc4jAstFnExpr construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_function<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_function,
        &[],
        "Swc4jAstFunction get_function()"
      )?;
    Ok(return_value)
  }

  pub fn get_ident<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_ident,
        &[],
        "Optional get_ident()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstForInStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_left: JMethodID,
  method_get_right: JMethodID,
}
unsafe impl Send for JavaSwc4jAstForInStmt {}
unsafe impl Sync for JavaSwc4jAstForInStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstForInStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstForInStmt")
      .expect("Couldn't find class Swc4jAstForInStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstForInStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstForHead;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstForInStmt::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;",
      )
      .expect("Couldn't find method Swc4jAstForInStmt.getBody");
    let method_get_left = env
      .get_method_id(
        &class,
        "getLeft",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstForHead;",
      )
      .expect("Couldn't find method Swc4jAstForInStmt.getLeft");
    let method_get_right = env
      .get_method_id(
        &class,
        "getRight",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstForInStmt.getRight");
    JavaSwc4jAstForInStmt {
      class,
      method_construct,
      method_get_body,
      method_get_left,
      method_get_right,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    left: &JObject<'_>,
    right: &JObject<'_>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let left = object_to_jvalue!(left);
    let right = object_to_jvalue!(right);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[left, right, body, span],
        "Swc4jAstForInStmt construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "ISwc4jAstStmt get_body()"
      )?;
    Ok(return_value)
  }

  pub fn get_left<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_left,
        &[],
        "ISwc4jAstForHead get_left()"
      )?;
    Ok(return_value)
  }

  pub fn get_right<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_right,
        &[],
        "ISwc4jAstExpr get_right()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstForOfStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_left: JMethodID,
  method_get_right: JMethodID,
  method_is_await: JMethodID,
}
unsafe impl Send for JavaSwc4jAstForOfStmt {}
unsafe impl Sync for JavaSwc4jAstForOfStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstForOfStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstForOfStmt")
      .expect("Couldn't find class Swc4jAstForOfStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstForOfStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstForHead;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstForOfStmt::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;",
      )
      .expect("Couldn't find method Swc4jAstForOfStmt.getBody");
    let method_get_left = env
      .get_method_id(
        &class,
        "getLeft",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstForHead;",
      )
      .expect("Couldn't find method Swc4jAstForOfStmt.getLeft");
    let method_get_right = env
      .get_method_id(
        &class,
        "getRight",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstForOfStmt.getRight");
    let method_is_await = env
      .get_method_id(
        &class,
        "isAwait",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstForOfStmt.isAwait");
    JavaSwc4jAstForOfStmt {
      class,
      method_construct,
      method_get_body,
      method_get_left,
      method_get_right,
      method_is_await,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    is_await: bool,
    left: &JObject<'_>,
    right: &JObject<'_>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let is_await = boolean_to_jvalue!(is_await);
    let left = object_to_jvalue!(left);
    let right = object_to_jvalue!(right);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[is_await, left, right, body, span],
        "Swc4jAstForOfStmt construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "ISwc4jAstStmt get_body()"
      )?;
    Ok(return_value)
  }

  pub fn get_left<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_left,
        &[],
        "ISwc4jAstForHead get_left()"
      )?;
    Ok(return_value)
  }

  pub fn get_right<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_right,
        &[],
        "ISwc4jAstExpr get_right()"
      )?;
    Ok(return_value)
  }

  pub fn is_await<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_await,
        &[],
        "boolean is_await()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstForStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_init: JMethodID,
  method_get_test: JMethodID,
  method_get_update: JMethodID,
}
unsafe impl Send for JavaSwc4jAstForStmt {}
unsafe impl Sync for JavaSwc4jAstForStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstForStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstForStmt")
      .expect("Couldn't find class Swc4jAstForStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstForStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstVarDeclOrExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstForStmt::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;",
      )
      .expect("Couldn't find method Swc4jAstForStmt.getBody");
    let method_get_init = env
      .get_method_id(
        &class,
        "getInit",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstForStmt.getInit");
    let method_get_test = env
      .get_method_id(
        &class,
        "getTest",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstForStmt.getTest");
    let method_get_update = env
      .get_method_id(
        &class,
        "getUpdate",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstForStmt.getUpdate");
    JavaSwc4jAstForStmt {
      class,
      method_construct,
      method_get_body,
      method_get_init,
      method_get_test,
      method_get_update,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    init: &Option<JObject>,
    test: &Option<JObject>,
    update: &Option<JObject>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let init = optional_object_to_jvalue!(init);
    let test = optional_object_to_jvalue!(test);
    let update = optional_object_to_jvalue!(update);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[init, test, update, body, span],
        "Swc4jAstForStmt construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "ISwc4jAstStmt get_body()"
      )?;
    Ok(return_value)
  }

  pub fn get_init<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_init,
        &[],
        "Optional get_init()"
      )?;
    Ok(return_value)
  }

  pub fn get_test<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_test,
        &[],
        "Optional get_test()"
      )?;
    Ok(return_value)
  }

  pub fn get_update<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_update,
        &[],
        "Optional get_update()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstFunction {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_ctxt: JMethodID,
  method_get_decorators: JMethodID,
  method_get_params: JMethodID,
  method_get_return_type: JMethodID,
  method_get_type_params: JMethodID,
  method_is_async: JMethodID,
  method_is_generator: JMethodID,
}
unsafe impl Send for JavaSwc4jAstFunction {}
unsafe impl Sync for JavaSwc4jAstFunction {}

#[allow(dead_code)]
impl JavaSwc4jAstFunction {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction")
      .expect("Couldn't find class Swc4jAstFunction");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstFunction");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ILjava/util/List;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;ZZLcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstFunction::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstFunction.getBody");
    let method_get_ctxt = env
      .get_method_id(
        &class,
        "getCtxt",
        "()I",
      )
      .expect("Couldn't find method Swc4jAstFunction.getCtxt");
    let method_get_decorators = env
      .get_method_id(
        &class,
        "getDecorators",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstFunction.getDecorators");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstFunction.getParams");
    let method_get_return_type = env
      .get_method_id(
        &class,
        "getReturnType",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstFunction.getReturnType");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstFunction.getTypeParams");
    let method_is_async = env
      .get_method_id(
        &class,
        "isAsync",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstFunction.isAsync");
    let method_is_generator = env
      .get_method_id(
        &class,
        "isGenerator",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstFunction.isGenerator");
    JavaSwc4jAstFunction {
      class,
      method_construct,
      method_get_body,
      method_get_ctxt,
      method_get_decorators,
      method_get_params,
      method_get_return_type,
      method_get_type_params,
      method_is_async,
      method_is_generator,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    ctxt: SyntaxContext,
    params: &JObject<'_>,
    decorators: &JObject<'_>,
    body: &Option<JObject>,
    is_generator: bool,
    is_async: bool,
    type_params: &Option<JObject>,
    return_type: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let ctxt = ctxt.as_u32() as i32;
    let ctxt = int_to_jvalue!(ctxt);
    let params = object_to_jvalue!(params);
    let decorators = object_to_jvalue!(decorators);
    let body = optional_object_to_jvalue!(body);
    let is_generator = boolean_to_jvalue!(is_generator);
    let is_async = boolean_to_jvalue!(is_async);
    let type_params = optional_object_to_jvalue!(type_params);
    let return_type = optional_object_to_jvalue!(return_type);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[ctxt, params, decorators, body, is_generator, is_async, type_params, return_type, span],
        "Swc4jAstFunction construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "Optional get_body()"
      )?;
    Ok(return_value)
  }

  pub fn get_ctxt<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<i32>
  {
    let return_value = call_as_int!(
        env,
        obj,
        self.method_get_ctxt,
        &[],
        "int get_ctxt()"
      )?;
    Ok(return_value)
  }

  pub fn get_decorators<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decorators,
        &[],
        "List get_decorators()"
      )?;
    Ok(return_value)
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      )?;
    Ok(return_value)
  }

  pub fn get_return_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_return_type,
        &[],
        "Optional get_return_type()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      )?;
    Ok(return_value)
  }

  pub fn is_async<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_async,
        &[],
        "boolean is_async()"
      )?;
    Ok(return_value)
  }

  pub fn is_generator<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_generator,
        &[],
        "boolean is_generator()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstGetterProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_key: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstGetterProp {}
unsafe impl Sync for JavaSwc4jAstGetterProp {}

#[allow(dead_code)]
impl JavaSwc4jAstGetterProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstGetterProp")
      .expect("Couldn't find class Swc4jAstGetterProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstGetterProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstGetterProp::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstGetterProp.getBody");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;",
      )
      .expect("Couldn't find method Swc4jAstGetterProp.getKey");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstGetterProp.getTypeAnn");
    JavaSwc4jAstGetterProp {
      class,
      method_construct,
      method_get_body,
      method_get_key,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    type_ann: &Option<JObject>,
    body: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let body = optional_object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, type_ann, body, span],
        "Swc4jAstGetterProp construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "Optional get_body()"
      )?;
    Ok(return_value)
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstPropName get_key()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstIdent {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_ctxt: JMethodID,
  method_get_sym: JMethodID,
  method_is_optional: JMethodID,
}
unsafe impl Send for JavaSwc4jAstIdent {}
unsafe impl Sync for JavaSwc4jAstIdent {}

#[allow(dead_code)]
impl JavaSwc4jAstIdent {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent")
      .expect("Couldn't find class Swc4jAstIdent");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstIdent");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ILjava/lang/String;ZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstIdent::new");
    let method_get_ctxt = env
      .get_method_id(
        &class,
        "getCtxt",
        "()I",
      )
      .expect("Couldn't find method Swc4jAstIdent.getCtxt");
    let method_get_sym = env
      .get_method_id(
        &class,
        "getSym",
        "()Ljava/lang/String;",
      )
      .expect("Couldn't find method Swc4jAstIdent.getSym");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstIdent.isOptional");
    JavaSwc4jAstIdent {
      class,
      method_construct,
      method_get_ctxt,
      method_get_sym,
      method_is_optional,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    ctxt: SyntaxContext,
    sym: &str,
    optional: bool,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let ctxt = ctxt.as_u32() as i32;
    let ctxt = int_to_jvalue!(ctxt);
    let java_sym = string_to_jstring!(env, &sym);
    let sym = object_to_jvalue!(java_sym);
    let optional = boolean_to_jvalue!(optional);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[ctxt, sym, optional, span],
        "Swc4jAstIdent construct()"
      )?;
    delete_local_ref!(env, java_sym);
    Ok(return_value)
  }

  pub fn get_ctxt<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<i32>
  {
    let return_value = call_as_int!(
        env,
        obj,
        self.method_get_ctxt,
        &[],
        "int get_ctxt()"
      )?;
    Ok(return_value)
  }

  pub fn get_sym<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<String>
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_sym,
        &[],
        "String get_sym()"
      )?;
    let java_return_value = return_value;
    let return_value: Result<String> = jstring_to_string!(env, java_return_value.as_raw());
    let return_value = return_value?;
    delete_local_ref!(env, java_return_value);
    Ok(return_value)
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstIdentName {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_sym: JMethodID,
}
unsafe impl Send for JavaSwc4jAstIdentName {}
unsafe impl Sync for JavaSwc4jAstIdentName {}

#[allow(dead_code)]
impl JavaSwc4jAstIdentName {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstIdentName")
      .expect("Couldn't find class Swc4jAstIdentName");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstIdentName");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/lang/String;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstIdentName::new");
    let method_get_sym = env
      .get_method_id(
        &class,
        "getSym",
        "()Ljava/lang/String;",
      )
      .expect("Couldn't find method Swc4jAstIdentName.getSym");
    JavaSwc4jAstIdentName {
      class,
      method_construct,
      method_get_sym,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    sym: &str,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_sym = string_to_jstring!(env, &sym);
    let sym = object_to_jvalue!(java_sym);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[sym, span],
        "Swc4jAstIdentName construct()"
      )?;
    delete_local_ref!(env, java_sym);
    Ok(return_value)
  }

  pub fn get_sym<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<String>
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_sym,
        &[],
        "String get_sym()"
      )?;
    let java_return_value = return_value;
    let return_value: Result<String> = jstring_to_string!(env, java_return_value.as_raw());
    let return_value = return_value?;
    delete_local_ref!(env, java_return_value);
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstIfStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_alt: JMethodID,
  method_get_cons: JMethodID,
  method_get_test: JMethodID,
}
unsafe impl Send for JavaSwc4jAstIfStmt {}
unsafe impl Sync for JavaSwc4jAstIfStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstIfStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstIfStmt")
      .expect("Couldn't find class Swc4jAstIfStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstIfStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstIfStmt::new");
    let method_get_alt = env
      .get_method_id(
        &class,
        "getAlt",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstIfStmt.getAlt");
    let method_get_cons = env
      .get_method_id(
        &class,
        "getCons",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;",
      )
      .expect("Couldn't find method Swc4jAstIfStmt.getCons");
    let method_get_test = env
      .get_method_id(
        &class,
        "getTest",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstIfStmt.getTest");
    JavaSwc4jAstIfStmt {
      class,
      method_construct,
      method_get_alt,
      method_get_cons,
      method_get_test,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    test: &JObject<'_>,
    cons: &JObject<'_>,
    alt: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let test = object_to_jvalue!(test);
    let cons = object_to_jvalue!(cons);
    let alt = optional_object_to_jvalue!(alt);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[test, cons, alt, span],
        "Swc4jAstIfStmt construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_alt<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_alt,
        &[],
        "Optional get_alt()"
      )?;
    Ok(return_value)
  }

  pub fn get_cons<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_cons,
        &[],
        "ISwc4jAstStmt get_cons()"
      )?;
    Ok(return_value)
  }

  pub fn get_test<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_test,
        &[],
        "ISwc4jAstExpr get_test()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstImport {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_phase: JMethodID,
}
unsafe impl Send for JavaSwc4jAstImport {}
unsafe impl Sync for JavaSwc4jAstImport {}

#[allow(dead_code)]
impl JavaSwc4jAstImport {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstImport")
      .expect("Couldn't find class Swc4jAstImport");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstImport");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstImportPhase;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstImport::new");
    let method_get_phase = env
      .get_method_id(
        &class,
        "getPhase",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstImportPhase;",
      )
      .expect("Couldn't find method Swc4jAstImport.getPhase");
    JavaSwc4jAstImport {
      class,
      method_construct,
      method_get_phase,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    phase: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let phase = object_to_jvalue!(phase);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[phase, span],
        "Swc4jAstImport construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_phase<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_phase,
        &[],
        "Swc4jAstImportPhase get_phase()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstImportDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_phase: JMethodID,
  method_get_specifiers: JMethodID,
  method_get_src: JMethodID,
  method_get_with: JMethodID,
  method_is_type_only: JMethodID,
}
unsafe impl Send for JavaSwc4jAstImportDecl {}
unsafe impl Sync for JavaSwc4jAstImportDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstImportDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstImportDecl")
      .expect("Couldn't find class Swc4jAstImportDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstImportDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr;ZLcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstObjectLit;Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstImportPhase;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstImportDecl::new");
    let method_get_phase = env
      .get_method_id(
        &class,
        "getPhase",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstImportPhase;",
      )
      .expect("Couldn't find method Swc4jAstImportDecl.getPhase");
    let method_get_specifiers = env
      .get_method_id(
        &class,
        "getSpecifiers",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstImportDecl.getSpecifiers");
    let method_get_src = env
      .get_method_id(
        &class,
        "getSrc",
        "()Lcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr;",
      )
      .expect("Couldn't find method Swc4jAstImportDecl.getSrc");
    let method_get_with = env
      .get_method_id(
        &class,
        "getWith",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstImportDecl.getWith");
    let method_is_type_only = env
      .get_method_id(
        &class,
        "isTypeOnly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstImportDecl.isTypeOnly");
    JavaSwc4jAstImportDecl {
      class,
      method_construct,
      method_get_phase,
      method_get_specifiers,
      method_get_src,
      method_get_with,
      method_is_type_only,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    specifiers: &JObject<'_>,
    src: &JObject<'_>,
    type_only: bool,
    with: &Option<JObject>,
    phase: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let specifiers = object_to_jvalue!(specifiers);
    let src = object_to_jvalue!(src);
    let type_only = boolean_to_jvalue!(type_only);
    let with = optional_object_to_jvalue!(with);
    let phase = object_to_jvalue!(phase);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[specifiers, src, type_only, with, phase, span],
        "Swc4jAstImportDecl construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_phase<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_phase,
        &[],
        "Swc4jAstImportPhase get_phase()"
      )?;
    Ok(return_value)
  }

  pub fn get_specifiers<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_specifiers,
        &[],
        "List get_specifiers()"
      )?;
    Ok(return_value)
  }

  pub fn get_src<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_src,
        &[],
        "Swc4jAstStr get_src()"
      )?;
    Ok(return_value)
  }

  pub fn get_with<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_with,
        &[],
        "Optional get_with()"
      )?;
    Ok(return_value)
  }

  pub fn is_type_only<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_type_only,
        &[],
        "boolean is_type_only()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstImportDefaultSpecifier {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_local: JMethodID,
}
unsafe impl Send for JavaSwc4jAstImportDefaultSpecifier {}
unsafe impl Sync for JavaSwc4jAstImportDefaultSpecifier {}

#[allow(dead_code)]
impl JavaSwc4jAstImportDefaultSpecifier {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstImportDefaultSpecifier")
      .expect("Couldn't find class Swc4jAstImportDefaultSpecifier");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstImportDefaultSpecifier");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstImportDefaultSpecifier::new");
    let method_get_local = env
      .get_method_id(
        &class,
        "getLocal",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstImportDefaultSpecifier.getLocal");
    JavaSwc4jAstImportDefaultSpecifier {
      class,
      method_construct,
      method_get_local,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    local: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let local = object_to_jvalue!(local);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[local, span],
        "Swc4jAstImportDefaultSpecifier construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_local<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_local,
        &[],
        "Swc4jAstIdent get_local()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstImportNamedSpecifier {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_imported: JMethodID,
  method_get_local: JMethodID,
  method_is_type_only: JMethodID,
}
unsafe impl Send for JavaSwc4jAstImportNamedSpecifier {}
unsafe impl Sync for JavaSwc4jAstImportNamedSpecifier {}

#[allow(dead_code)]
impl JavaSwc4jAstImportNamedSpecifier {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstImportNamedSpecifier")
      .expect("Couldn't find class Swc4jAstImportNamedSpecifier");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstImportNamedSpecifier");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstModuleExportName;ZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstImportNamedSpecifier::new");
    let method_get_imported = env
      .get_method_id(
        &class,
        "getImported",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstImportNamedSpecifier.getImported");
    let method_get_local = env
      .get_method_id(
        &class,
        "getLocal",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstImportNamedSpecifier.getLocal");
    let method_is_type_only = env
      .get_method_id(
        &class,
        "isTypeOnly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstImportNamedSpecifier.isTypeOnly");
    JavaSwc4jAstImportNamedSpecifier {
      class,
      method_construct,
      method_get_imported,
      method_get_local,
      method_is_type_only,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    local: &JObject<'_>,
    imported: &Option<JObject>,
    type_only: bool,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let local = object_to_jvalue!(local);
    let imported = optional_object_to_jvalue!(imported);
    let type_only = boolean_to_jvalue!(type_only);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[local, imported, type_only, span],
        "Swc4jAstImportNamedSpecifier construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_imported<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_imported,
        &[],
        "Optional get_imported()"
      )?;
    Ok(return_value)
  }

  pub fn get_local<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_local,
        &[],
        "Swc4jAstIdent get_local()"
      )?;
    Ok(return_value)
  }

  pub fn is_type_only<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_type_only,
        &[],
        "boolean is_type_only()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstImportStarAsSpecifier {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_local: JMethodID,
}
unsafe impl Send for JavaSwc4jAstImportStarAsSpecifier {}
unsafe impl Sync for JavaSwc4jAstImportStarAsSpecifier {}

#[allow(dead_code)]
impl JavaSwc4jAstImportStarAsSpecifier {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstImportStarAsSpecifier")
      .expect("Couldn't find class Swc4jAstImportStarAsSpecifier");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstImportStarAsSpecifier");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstImportStarAsSpecifier::new");
    let method_get_local = env
      .get_method_id(
        &class,
        "getLocal",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstImportStarAsSpecifier.getLocal");
    JavaSwc4jAstImportStarAsSpecifier {
      class,
      method_construct,
      method_get_local,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    local: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let local = object_to_jvalue!(local);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[local, span],
        "Swc4jAstImportStarAsSpecifier construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_local<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_local,
        &[],
        "Swc4jAstIdent get_local()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstInvalid {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstInvalid {}
unsafe impl Sync for JavaSwc4jAstInvalid {}

#[allow(dead_code)]
impl JavaSwc4jAstInvalid {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/pat/Swc4jAstInvalid")
      .expect("Couldn't find class Swc4jAstInvalid");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstInvalid");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstInvalid::new");
    JavaSwc4jAstInvalid {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstInvalid construct()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxAttr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_name: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxAttr {}
unsafe impl Sync for JavaSwc4jAstJsxAttr {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxAttr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxAttr")
      .expect("Couldn't find class Swc4jAstJsxAttr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxAttr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxAttrName;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxAttrValue;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxAttr::new");
    let method_get_name = env
      .get_method_id(
        &class,
        "getName",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxAttrName;",
      )
      .expect("Couldn't find method Swc4jAstJsxAttr.getName");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstJsxAttr.getValue");
    JavaSwc4jAstJsxAttr {
      class,
      method_construct,
      method_get_name,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    name: &JObject<'_>,
    value: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let name = object_to_jvalue!(name);
    let value = optional_object_to_jvalue!(value);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[name, value, span],
        "Swc4jAstJsxAttr construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_name,
        &[],
        "ISwc4jAstJsxAttrName get_name()"
      )?;
    Ok(return_value)
  }

  pub fn get_value<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "Optional get_value()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxClosingElement {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_name: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxClosingElement {}
unsafe impl Sync for JavaSwc4jAstJsxClosingElement {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxClosingElement {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxClosingElement")
      .expect("Couldn't find class Swc4jAstJsxClosingElement");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxClosingElement");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxElementName;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxClosingElement::new");
    let method_get_name = env
      .get_method_id(
        &class,
        "getName",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxElementName;",
      )
      .expect("Couldn't find method Swc4jAstJsxClosingElement.getName");
    JavaSwc4jAstJsxClosingElement {
      class,
      method_construct,
      method_get_name,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    name: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let name = object_to_jvalue!(name);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[name, span],
        "Swc4jAstJsxClosingElement construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_name,
        &[],
        "ISwc4jAstJsxElementName get_name()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxClosingFragment {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxClosingFragment {}
unsafe impl Sync for JavaSwc4jAstJsxClosingFragment {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxClosingFragment {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxClosingFragment")
      .expect("Couldn't find class Swc4jAstJsxClosingFragment");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxClosingFragment");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxClosingFragment::new");
    JavaSwc4jAstJsxClosingFragment {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstJsxClosingFragment construct()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxElement {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_children: JMethodID,
  method_get_closing: JMethodID,
  method_get_opening: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxElement {}
unsafe impl Sync for JavaSwc4jAstJsxElement {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxElement {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstJsxElement")
      .expect("Couldn't find class Swc4jAstJsxElement");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxElement");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxOpeningElement;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxClosingElement;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxElement::new");
    let method_get_children = env
      .get_method_id(
        &class,
        "getChildren",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstJsxElement.getChildren");
    let method_get_closing = env
      .get_method_id(
        &class,
        "getClosing",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstJsxElement.getClosing");
    let method_get_opening = env
      .get_method_id(
        &class,
        "getOpening",
        "()Lcom/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxOpeningElement;",
      )
      .expect("Couldn't find method Swc4jAstJsxElement.getOpening");
    JavaSwc4jAstJsxElement {
      class,
      method_construct,
      method_get_children,
      method_get_closing,
      method_get_opening,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    opening: &JObject<'_>,
    children: &JObject<'_>,
    closing: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let opening = object_to_jvalue!(opening);
    let children = object_to_jvalue!(children);
    let closing = optional_object_to_jvalue!(closing);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[opening, children, closing, span],
        "Swc4jAstJsxElement construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_children<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_children,
        &[],
        "List get_children()"
      )?;
    Ok(return_value)
  }

  pub fn get_closing<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_closing,
        &[],
        "Optional get_closing()"
      )?;
    Ok(return_value)
  }

  pub fn get_opening<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_opening,
        &[],
        "Swc4jAstJsxOpeningElement get_opening()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxEmptyExpr {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxEmptyExpr {}
unsafe impl Sync for JavaSwc4jAstJsxEmptyExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxEmptyExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstJsxEmptyExpr")
      .expect("Couldn't find class Swc4jAstJsxEmptyExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxEmptyExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxEmptyExpr::new");
    JavaSwc4jAstJsxEmptyExpr {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstJsxEmptyExpr construct()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxExprContainer {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxExprContainer {}
unsafe impl Sync for JavaSwc4jAstJsxExprContainer {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxExprContainer {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstJsxExprContainer")
      .expect("Couldn't find class Swc4jAstJsxExprContainer");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxExprContainer");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxExprContainer::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxExpr;",
      )
      .expect("Couldn't find method Swc4jAstJsxExprContainer.getExpr");
    JavaSwc4jAstJsxExprContainer {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstJsxExprContainer construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstJsxExpr get_expr()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxFragment {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_children: JMethodID,
  method_get_closing: JMethodID,
  method_get_opening: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxFragment {}
unsafe impl Sync for JavaSwc4jAstJsxFragment {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxFragment {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstJsxFragment")
      .expect("Couldn't find class Swc4jAstJsxFragment");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxFragment");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxOpeningFragment;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxClosingFragment;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxFragment::new");
    let method_get_children = env
      .get_method_id(
        &class,
        "getChildren",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstJsxFragment.getChildren");
    let method_get_closing = env
      .get_method_id(
        &class,
        "getClosing",
        "()Lcom/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxClosingFragment;",
      )
      .expect("Couldn't find method Swc4jAstJsxFragment.getClosing");
    let method_get_opening = env
      .get_method_id(
        &class,
        "getOpening",
        "()Lcom/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxOpeningFragment;",
      )
      .expect("Couldn't find method Swc4jAstJsxFragment.getOpening");
    JavaSwc4jAstJsxFragment {
      class,
      method_construct,
      method_get_children,
      method_get_closing,
      method_get_opening,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    opening: &JObject<'_>,
    children: &JObject<'_>,
    closing: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let opening = object_to_jvalue!(opening);
    let children = object_to_jvalue!(children);
    let closing = object_to_jvalue!(closing);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[opening, children, closing, span],
        "Swc4jAstJsxFragment construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_children<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_children,
        &[],
        "List get_children()"
      )?;
    Ok(return_value)
  }

  pub fn get_closing<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_closing,
        &[],
        "Swc4jAstJsxClosingFragment get_closing()"
      )?;
    Ok(return_value)
  }

  pub fn get_opening<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_opening,
        &[],
        "Swc4jAstJsxOpeningFragment get_opening()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxMemberExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_obj: JMethodID,
  method_get_prop: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxMemberExpr {}
unsafe impl Sync for JavaSwc4jAstJsxMemberExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxMemberExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstJsxMemberExpr")
      .expect("Couldn't find class Swc4jAstJsxMemberExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxMemberExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxObject;Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdentName;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxMemberExpr::new");
    let method_get_obj = env
      .get_method_id(
        &class,
        "getObj",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxObject;",
      )
      .expect("Couldn't find method Swc4jAstJsxMemberExpr.getObj");
    let method_get_prop = env
      .get_method_id(
        &class,
        "getProp",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdentName;",
      )
      .expect("Couldn't find method Swc4jAstJsxMemberExpr.getProp");
    JavaSwc4jAstJsxMemberExpr {
      class,
      method_construct,
      method_get_obj,
      method_get_prop,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
    prop: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let obj = object_to_jvalue!(obj);
    let prop = object_to_jvalue!(prop);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[obj, prop, span],
        "Swc4jAstJsxMemberExpr construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_obj<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_obj,
        &[],
        "ISwc4jAstJsxObject get_obj()"
      )?;
    Ok(return_value)
  }

  pub fn get_prop<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_prop,
        &[],
        "Swc4jAstIdentName get_prop()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxNamespacedName {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_name: JMethodID,
  method_get_ns: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxNamespacedName {}
unsafe impl Sync for JavaSwc4jAstJsxNamespacedName {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxNamespacedName {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstJsxNamespacedName")
      .expect("Couldn't find class Swc4jAstJsxNamespacedName");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxNamespacedName");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdentName;Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdentName;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxNamespacedName::new");
    let method_get_name = env
      .get_method_id(
        &class,
        "getName",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdentName;",
      )
      .expect("Couldn't find method Swc4jAstJsxNamespacedName.getName");
    let method_get_ns = env
      .get_method_id(
        &class,
        "getNs",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdentName;",
      )
      .expect("Couldn't find method Swc4jAstJsxNamespacedName.getNs");
    JavaSwc4jAstJsxNamespacedName {
      class,
      method_construct,
      method_get_name,
      method_get_ns,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    ns: &JObject<'_>,
    name: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let ns = object_to_jvalue!(ns);
    let name = object_to_jvalue!(name);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[ns, name, span],
        "Swc4jAstJsxNamespacedName construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_name,
        &[],
        "Swc4jAstIdentName get_name()"
      )?;
    Ok(return_value)
  }

  pub fn get_ns<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_ns,
        &[],
        "Swc4jAstIdentName get_ns()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxOpeningElement {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_attrs: JMethodID,
  method_get_name: JMethodID,
  method_get_type_args: JMethodID,
  method_is_self_closing: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxOpeningElement {}
unsafe impl Sync for JavaSwc4jAstJsxOpeningElement {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxOpeningElement {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxOpeningElement")
      .expect("Couldn't find class Swc4jAstJsxOpeningElement");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxOpeningElement");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxElementName;Ljava/util/List;ZLcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxOpeningElement::new");
    let method_get_attrs = env
      .get_method_id(
        &class,
        "getAttrs",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstJsxOpeningElement.getAttrs");
    let method_get_name = env
      .get_method_id(
        &class,
        "getName",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstJsxElementName;",
      )
      .expect("Couldn't find method Swc4jAstJsxOpeningElement.getName");
    let method_get_type_args = env
      .get_method_id(
        &class,
        "getTypeArgs",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstJsxOpeningElement.getTypeArgs");
    let method_is_self_closing = env
      .get_method_id(
        &class,
        "isSelfClosing",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstJsxOpeningElement.isSelfClosing");
    JavaSwc4jAstJsxOpeningElement {
      class,
      method_construct,
      method_get_attrs,
      method_get_name,
      method_get_type_args,
      method_is_self_closing,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    name: &JObject<'_>,
    attrs: &JObject<'_>,
    self_closing: bool,
    type_args: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let name = object_to_jvalue!(name);
    let attrs = object_to_jvalue!(attrs);
    let self_closing = boolean_to_jvalue!(self_closing);
    let type_args = optional_object_to_jvalue!(type_args);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[name, attrs, self_closing, type_args, span],
        "Swc4jAstJsxOpeningElement construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_attrs<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_attrs,
        &[],
        "List get_attrs()"
      )?;
    Ok(return_value)
  }

  pub fn get_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_name,
        &[],
        "ISwc4jAstJsxElementName get_name()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_args,
        &[],
        "Optional get_type_args()"
      )?;
    Ok(return_value)
  }

  pub fn is_self_closing<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_self_closing,
        &[],
        "boolean is_self_closing()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxOpeningFragment {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxOpeningFragment {}
unsafe impl Sync for JavaSwc4jAstJsxOpeningFragment {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxOpeningFragment {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/miscs/Swc4jAstJsxOpeningFragment")
      .expect("Couldn't find class Swc4jAstJsxOpeningFragment");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxOpeningFragment");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxOpeningFragment::new");
    JavaSwc4jAstJsxOpeningFragment {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstJsxOpeningFragment construct()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxSpreadChild {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxSpreadChild {}
unsafe impl Sync for JavaSwc4jAstJsxSpreadChild {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxSpreadChild {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstJsxSpreadChild")
      .expect("Couldn't find class Swc4jAstJsxSpreadChild");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxSpreadChild");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxSpreadChild::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstJsxSpreadChild.getExpr");
    JavaSwc4jAstJsxSpreadChild {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstJsxSpreadChild construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstJsxText {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_raw: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstJsxText {}
unsafe impl Sync for JavaSwc4jAstJsxText {}

#[allow(dead_code)]
impl JavaSwc4jAstJsxText {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstJsxText")
      .expect("Couldn't find class Swc4jAstJsxText");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstJsxText");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/lang/String;Ljava/lang/String;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstJsxText::new");
    let method_get_raw = env
      .get_method_id(
        &class,
        "getRaw",
        "()Ljava/lang/String;",
      )
      .expect("Couldn't find method Swc4jAstJsxText.getRaw");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Ljava/lang/String;",
      )
      .expect("Couldn't find method Swc4jAstJsxText.getValue");
    JavaSwc4jAstJsxText {
      class,
      method_construct,
      method_get_raw,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    value: &str,
    raw: &str,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_value = string_to_jstring!(env, &value);
    let value = object_to_jvalue!(java_value);
    let java_raw = string_to_jstring!(env, &raw);
    let raw = object_to_jvalue!(java_raw);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[value, raw, span],
        "Swc4jAstJsxText construct()"
      )?;
    delete_local_ref!(env, java_value);
    delete_local_ref!(env, java_raw);
    Ok(return_value)
  }

  pub fn get_raw<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<String>
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_raw,
        &[],
        "String get_raw()"
      )?;
    let java_return_value = return_value;
    let return_value: Result<String> = jstring_to_string!(env, java_return_value.as_raw());
    let return_value = return_value?;
    delete_local_ref!(env, java_return_value);
    Ok(return_value)
  }

  pub fn get_value<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<String>
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "String get_value()"
      )?;
    let java_return_value = return_value;
    let return_value: Result<String> = jstring_to_string!(env, java_return_value.as_raw());
    let return_value = return_value?;
    delete_local_ref!(env, java_return_value);
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstKeyValuePatProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_key: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstKeyValuePatProp {}
unsafe impl Sync for JavaSwc4jAstKeyValuePatProp {}

#[allow(dead_code)]
impl JavaSwc4jAstKeyValuePatProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/pat/Swc4jAstKeyValuePatProp")
      .expect("Couldn't find class Swc4jAstKeyValuePatProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstKeyValuePatProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstKeyValuePatProp::new");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;",
      )
      .expect("Couldn't find method Swc4jAstKeyValuePatProp.getKey");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;",
      )
      .expect("Couldn't find method Swc4jAstKeyValuePatProp.getValue");
    JavaSwc4jAstKeyValuePatProp {
      class,
      method_construct,
      method_get_key,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    value: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let value = object_to_jvalue!(value);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, value, span],
        "Swc4jAstKeyValuePatProp construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstPropName get_key()"
      )?;
    Ok(return_value)
  }

  pub fn get_value<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "ISwc4jAstPat get_value()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstKeyValueProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_key: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstKeyValueProp {}
unsafe impl Sync for JavaSwc4jAstKeyValueProp {}

#[allow(dead_code)]
impl JavaSwc4jAstKeyValueProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstKeyValueProp")
      .expect("Couldn't find class Swc4jAstKeyValueProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstKeyValueProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstKeyValueProp::new");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;",
      )
      .expect("Couldn't find method Swc4jAstKeyValueProp.getKey");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstKeyValueProp.getValue");
    JavaSwc4jAstKeyValueProp {
      class,
      method_construct,
      method_get_key,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    value: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let value = object_to_jvalue!(value);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, value, span],
        "Swc4jAstKeyValueProp construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstPropName get_key()"
      )?;
    Ok(return_value)
  }

  pub fn get_value<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "ISwc4jAstExpr get_value()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstLabeledStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_label: JMethodID,
}
unsafe impl Send for JavaSwc4jAstLabeledStmt {}
unsafe impl Sync for JavaSwc4jAstLabeledStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstLabeledStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstLabeledStmt")
      .expect("Couldn't find class Swc4jAstLabeledStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstLabeledStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstLabeledStmt::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;",
      )
      .expect("Couldn't find method Swc4jAstLabeledStmt.getBody");
    let method_get_label = env
      .get_method_id(
        &class,
        "getLabel",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstLabeledStmt.getLabel");
    JavaSwc4jAstLabeledStmt {
      class,
      method_construct,
      method_get_body,
      method_get_label,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    label: &JObject<'_>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let label = object_to_jvalue!(label);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[label, body, span],
        "Swc4jAstLabeledStmt construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "ISwc4jAstStmt get_body()"
      )?;
    Ok(return_value)
  }

  pub fn get_label<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_label,
        &[],
        "Swc4jAstIdent get_label()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstMemberExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_obj: JMethodID,
  method_get_prop: JMethodID,
}
unsafe impl Send for JavaSwc4jAstMemberExpr {}
unsafe impl Sync for JavaSwc4jAstMemberExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstMemberExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstMemberExpr")
      .expect("Couldn't find class Swc4jAstMemberExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstMemberExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstMemberProp;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstMemberExpr::new");
    let method_get_obj = env
      .get_method_id(
        &class,
        "getObj",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstMemberExpr.getObj");
    let method_get_prop = env
      .get_method_id(
        &class,
        "getProp",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstMemberProp;",
      )
      .expect("Couldn't find method Swc4jAstMemberExpr.getProp");
    JavaSwc4jAstMemberExpr {
      class,
      method_construct,
      method_get_obj,
      method_get_prop,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
    prop: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let obj = object_to_jvalue!(obj);
    let prop = object_to_jvalue!(prop);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[obj, prop, span],
        "Swc4jAstMemberExpr construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_obj<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_obj,
        &[],
        "ISwc4jAstExpr get_obj()"
      )?;
    Ok(return_value)
  }

  pub fn get_prop<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_prop,
        &[],
        "ISwc4jAstMemberProp get_prop()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstMetaPropExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_kind: JMethodID,
}
unsafe impl Send for JavaSwc4jAstMetaPropExpr {}
unsafe impl Sync for JavaSwc4jAstMetaPropExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstMetaPropExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstMetaPropExpr")
      .expect("Couldn't find class Swc4jAstMetaPropExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstMetaPropExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstMetaPropKind;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstMetaPropExpr::new");
    let method_get_kind = env
      .get_method_id(
        &class,
        "getKind",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstMetaPropKind;",
      )
      .expect("Couldn't find method Swc4jAstMetaPropExpr.getKind");
    JavaSwc4jAstMetaPropExpr {
      class,
      method_construct,
      method_get_kind,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    kind: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let kind = object_to_jvalue!(kind);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[kind, span],
        "Swc4jAstMetaPropExpr construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_kind<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_kind,
        &[],
        "Swc4jAstMetaPropKind get_kind()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstMethodProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_function: JMethodID,
  method_get_key: JMethodID,
}
unsafe impl Send for JavaSwc4jAstMethodProp {}
unsafe impl Sync for JavaSwc4jAstMethodProp {}

#[allow(dead_code)]
impl JavaSwc4jAstMethodProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstMethodProp")
      .expect("Couldn't find class Swc4jAstMethodProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstMethodProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstMethodProp::new");
    let method_get_function = env
      .get_method_id(
        &class,
        "getFunction",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;",
      )
      .expect("Couldn't find method Swc4jAstMethodProp.getFunction");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;",
      )
      .expect("Couldn't find method Swc4jAstMethodProp.getKey");
    JavaSwc4jAstMethodProp {
      class,
      method_construct,
      method_get_function,
      method_get_key,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    function: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let function = object_to_jvalue!(function);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, function, span],
        "Swc4jAstMethodProp construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_function<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_function,
        &[],
        "Swc4jAstFunction get_function()"
      )?;
    Ok(return_value)
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstPropName get_key()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstModule {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_shebang: JMethodID,
}
unsafe impl Send for JavaSwc4jAstModule {}
unsafe impl Sync for JavaSwc4jAstModule {}

#[allow(dead_code)]
impl JavaSwc4jAstModule {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/program/Swc4jAstModule")
      .expect("Couldn't find class Swc4jAstModule");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstModule");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Ljava/lang/String;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstModule::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstModule.getBody");
    let method_get_shebang = env
      .get_method_id(
        &class,
        "getShebang",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstModule.getShebang");
    JavaSwc4jAstModule {
      class,
      method_construct,
      method_get_body,
      method_get_shebang,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    body: &JObject<'_>,
    shebang: &Option<String>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let body = object_to_jvalue!(body);
    let java_shebang = optional_string_to_jstring!(env, &shebang);
    let shebang = object_to_jvalue!(java_shebang);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[body, shebang, span],
        "Swc4jAstModule construct()"
      )?;
    delete_local_ref!(env, java_shebang);
    Ok(return_value)
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "List get_body()"
      )?;
    Ok(return_value)
  }

  pub fn get_shebang<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_shebang,
        &[],
        "Optional get_shebang()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstNamedExport {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_specifiers: JMethodID,
  method_get_src: JMethodID,
  method_get_with: JMethodID,
  method_is_type_only: JMethodID,
}
unsafe impl Send for JavaSwc4jAstNamedExport {}
unsafe impl Sync for JavaSwc4jAstNamedExport {}

#[allow(dead_code)]
impl JavaSwc4jAstNamedExport {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstNamedExport")
      .expect("Couldn't find class Swc4jAstNamedExport");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstNamedExport");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr;ZLcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstObjectLit;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstNamedExport::new");
    let method_get_specifiers = env
      .get_method_id(
        &class,
        "getSpecifiers",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstNamedExport.getSpecifiers");
    let method_get_src = env
      .get_method_id(
        &class,
        "getSrc",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstNamedExport.getSrc");
    let method_get_with = env
      .get_method_id(
        &class,
        "getWith",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstNamedExport.getWith");
    let method_is_type_only = env
      .get_method_id(
        &class,
        "isTypeOnly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstNamedExport.isTypeOnly");
    JavaSwc4jAstNamedExport {
      class,
      method_construct,
      method_get_specifiers,
      method_get_src,
      method_get_with,
      method_is_type_only,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    specifiers: &JObject<'_>,
    src: &Option<JObject>,
    type_only: bool,
    with: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let specifiers = object_to_jvalue!(specifiers);
    let src = optional_object_to_jvalue!(src);
    let type_only = boolean_to_jvalue!(type_only);
    let with = optional_object_to_jvalue!(with);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[specifiers, src, type_only, with, span],
        "Swc4jAstNamedExport construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_specifiers<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_specifiers,
        &[],
        "List get_specifiers()"
      )?;
    Ok(return_value)
  }

  pub fn get_src<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_src,
        &[],
        "Optional get_src()"
      )?;
    Ok(return_value)
  }

  pub fn get_with<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_with,
        &[],
        "Optional get_with()"
      )?;
    Ok(return_value)
  }

  pub fn is_type_only<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_type_only,
        &[],
        "boolean is_type_only()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstNewExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_args: JMethodID,
  method_get_callee: JMethodID,
  method_get_ctxt: JMethodID,
  method_get_type_args: JMethodID,
}
unsafe impl Send for JavaSwc4jAstNewExpr {}
unsafe impl Sync for JavaSwc4jAstNewExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstNewExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstNewExpr")
      .expect("Couldn't find class Swc4jAstNewExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstNewExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ILcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstNewExpr::new");
    let method_get_args = env
      .get_method_id(
        &class,
        "getArgs",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstNewExpr.getArgs");
    let method_get_callee = env
      .get_method_id(
        &class,
        "getCallee",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstNewExpr.getCallee");
    let method_get_ctxt = env
      .get_method_id(
        &class,
        "getCtxt",
        "()I",
      )
      .expect("Couldn't find method Swc4jAstNewExpr.getCtxt");
    let method_get_type_args = env
      .get_method_id(
        &class,
        "getTypeArgs",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstNewExpr.getTypeArgs");
    JavaSwc4jAstNewExpr {
      class,
      method_construct,
      method_get_args,
      method_get_callee,
      method_get_ctxt,
      method_get_type_args,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    ctxt: SyntaxContext,
    callee: &JObject<'_>,
    args: &Option<JObject>,
    type_args: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let ctxt = ctxt.as_u32() as i32;
    let ctxt = int_to_jvalue!(ctxt);
    let callee = object_to_jvalue!(callee);
    let args = optional_object_to_jvalue!(args);
    let type_args = optional_object_to_jvalue!(type_args);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[ctxt, callee, args, type_args, span],
        "Swc4jAstNewExpr construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_args,
        &[],
        "Optional get_args()"
      )?;
    Ok(return_value)
  }

  pub fn get_callee<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_callee,
        &[],
        "ISwc4jAstExpr get_callee()"
      )?;
    Ok(return_value)
  }

  pub fn get_ctxt<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<i32>
  {
    let return_value = call_as_int!(
        env,
        obj,
        self.method_get_ctxt,
        &[],
        "int get_ctxt()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_args,
        &[],
        "Optional get_type_args()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstNull {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstNull {}
unsafe impl Sync for JavaSwc4jAstNull {}

#[allow(dead_code)]
impl JavaSwc4jAstNull {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstNull")
      .expect("Couldn't find class Swc4jAstNull");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstNull");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstNull::new");
    JavaSwc4jAstNull {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstNull construct()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstNumber {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_raw: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstNumber {}
unsafe impl Sync for JavaSwc4jAstNumber {}

#[allow(dead_code)]
impl JavaSwc4jAstNumber {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstNumber")
      .expect("Couldn't find class Swc4jAstNumber");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstNumber");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(DLjava/lang/String;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstNumber::new");
    let method_get_raw = env
      .get_method_id(
        &class,
        "getRaw",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstNumber.getRaw");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()D",
      )
      .expect("Couldn't find method Swc4jAstNumber.getValue");
    JavaSwc4jAstNumber {
      class,
      method_construct,
      method_get_raw,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    value: f64,
    raw: &Option<String>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let value = double_to_jvalue!(value);
    let java_raw = optional_string_to_jstring!(env, &raw);
    let raw = object_to_jvalue!(java_raw);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[value, raw, span],
        "Swc4jAstNumber construct()"
      )?;
    delete_local_ref!(env, java_raw);
    Ok(return_value)
  }

  pub fn get_raw<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_raw,
        &[],
        "Optional get_raw()"
      )?;
    Ok(return_value)
  }

  pub fn get_value<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<f64>
  {
    let return_value = call_as_double!(
        env,
        obj,
        self.method_get_value,
        &[],
        "double get_value()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstObjectLit {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_props: JMethodID,
}
unsafe impl Send for JavaSwc4jAstObjectLit {}
unsafe impl Sync for JavaSwc4jAstObjectLit {}

#[allow(dead_code)]
impl JavaSwc4jAstObjectLit {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstObjectLit")
      .expect("Couldn't find class Swc4jAstObjectLit");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstObjectLit");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstObjectLit::new");
    let method_get_props = env
      .get_method_id(
        &class,
        "getProps",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstObjectLit.getProps");
    JavaSwc4jAstObjectLit {
      class,
      method_construct,
      method_get_props,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    props: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let props = object_to_jvalue!(props);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[props, span],
        "Swc4jAstObjectLit construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_props<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_props,
        &[],
        "List get_props()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstObjectPat {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_props: JMethodID,
  method_get_type_ann: JMethodID,
  method_is_optional: JMethodID,
}
unsafe impl Send for JavaSwc4jAstObjectPat {}
unsafe impl Sync for JavaSwc4jAstObjectPat {}

#[allow(dead_code)]
impl JavaSwc4jAstObjectPat {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/pat/Swc4jAstObjectPat")
      .expect("Couldn't find class Swc4jAstObjectPat");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstObjectPat");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;ZLcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstObjectPat::new");
    let method_get_props = env
      .get_method_id(
        &class,
        "getProps",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstObjectPat.getProps");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstObjectPat.getTypeAnn");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstObjectPat.isOptional");
    JavaSwc4jAstObjectPat {
      class,
      method_construct,
      method_get_props,
      method_get_type_ann,
      method_is_optional,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    props: &JObject<'_>,
    optional: bool,
    type_ann: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let props = object_to_jvalue!(props);
    let optional = boolean_to_jvalue!(optional);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[props, optional, type_ann, span],
        "Swc4jAstObjectPat construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_props<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_props,
        &[],
        "List get_props()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      )?;
    Ok(return_value)
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstOptCall {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_args: JMethodID,
  method_get_callee: JMethodID,
  method_get_ctxt: JMethodID,
  method_get_type_args: JMethodID,
}
unsafe impl Send for JavaSwc4jAstOptCall {}
unsafe impl Sync for JavaSwc4jAstOptCall {}

#[allow(dead_code)]
impl JavaSwc4jAstOptCall {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/miscs/Swc4jAstOptCall")
      .expect("Couldn't find class Swc4jAstOptCall");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstOptCall");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ILcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstOptCall::new");
    let method_get_args = env
      .get_method_id(
        &class,
        "getArgs",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstOptCall.getArgs");
    let method_get_callee = env
      .get_method_id(
        &class,
        "getCallee",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstOptCall.getCallee");
    let method_get_ctxt = env
      .get_method_id(
        &class,
        "getCtxt",
        "()I",
      )
      .expect("Couldn't find method Swc4jAstOptCall.getCtxt");
    let method_get_type_args = env
      .get_method_id(
        &class,
        "getTypeArgs",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstOptCall.getTypeArgs");
    JavaSwc4jAstOptCall {
      class,
      method_construct,
      method_get_args,
      method_get_callee,
      method_get_ctxt,
      method_get_type_args,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    ctxt: SyntaxContext,
    callee: &JObject<'_>,
    args: &JObject<'_>,
    type_args: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let ctxt = ctxt.as_u32() as i32;
    let ctxt = int_to_jvalue!(ctxt);
    let callee = object_to_jvalue!(callee);
    let args = object_to_jvalue!(args);
    let type_args = optional_object_to_jvalue!(type_args);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[ctxt, callee, args, type_args, span],
        "Swc4jAstOptCall construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_args,
        &[],
        "List get_args()"
      )?;
    Ok(return_value)
  }

  pub fn get_callee<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_callee,
        &[],
        "ISwc4jAstExpr get_callee()"
      )?;
    Ok(return_value)
  }

  pub fn get_ctxt<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<i32>
  {
    let return_value = call_as_int!(
        env,
        obj,
        self.method_get_ctxt,
        &[],
        "int get_ctxt()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_args,
        &[],
        "Optional get_type_args()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstOptChainExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_base: JMethodID,
  method_is_optional: JMethodID,
}
unsafe impl Send for JavaSwc4jAstOptChainExpr {}
unsafe impl Sync for JavaSwc4jAstOptChainExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstOptChainExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstOptChainExpr")
      .expect("Couldn't find class Swc4jAstOptChainExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstOptChainExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstOptChainBase;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstOptChainExpr::new");
    let method_get_base = env
      .get_method_id(
        &class,
        "getBase",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstOptChainBase;",
      )
      .expect("Couldn't find method Swc4jAstOptChainExpr.getBase");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstOptChainExpr.isOptional");
    JavaSwc4jAstOptChainExpr {
      class,
      method_construct,
      method_get_base,
      method_is_optional,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    optional: bool,
    base: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let optional = boolean_to_jvalue!(optional);
    let base = object_to_jvalue!(base);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[optional, base, span],
        "Swc4jAstOptChainExpr construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_base<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_base,
        &[],
        "ISwc4jAstOptChainBase get_base()"
      )?;
    Ok(return_value)
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstParam {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_decorators: JMethodID,
  method_get_pat: JMethodID,
}
unsafe impl Send for JavaSwc4jAstParam {}
unsafe impl Sync for JavaSwc4jAstParam {}

#[allow(dead_code)]
impl JavaSwc4jAstParam {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstParam")
      .expect("Couldn't find class Swc4jAstParam");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstParam");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstParam::new");
    let method_get_decorators = env
      .get_method_id(
        &class,
        "getDecorators",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstParam.getDecorators");
    let method_get_pat = env
      .get_method_id(
        &class,
        "getPat",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;",
      )
      .expect("Couldn't find method Swc4jAstParam.getPat");
    JavaSwc4jAstParam {
      class,
      method_construct,
      method_get_decorators,
      method_get_pat,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    decorators: &JObject<'_>,
    pat: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let decorators = object_to_jvalue!(decorators);
    let pat = object_to_jvalue!(pat);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[decorators, pat, span],
        "Swc4jAstParam construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_decorators<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decorators,
        &[],
        "List get_decorators()"
      )?;
    Ok(return_value)
  }

  pub fn get_pat<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_pat,
        &[],
        "ISwc4jAstPat get_pat()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstParenExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstParenExpr {}
unsafe impl Sync for JavaSwc4jAstParenExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstParenExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstParenExpr")
      .expect("Couldn't find class Swc4jAstParenExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstParenExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstParenExpr::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstParenExpr.getExpr");
    JavaSwc4jAstParenExpr {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstParenExpr construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstPrivateMethod {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_accessibility: JMethodID,
  method_get_function: JMethodID,
  method_get_key: JMethodID,
  method_get_kind: JMethodID,
  method_is_abstract: JMethodID,
  method_is_optional: JMethodID,
  method_is_override: JMethodID,
  method_is_static: JMethodID,
}
unsafe impl Send for JavaSwc4jAstPrivateMethod {}
unsafe impl Sync for JavaSwc4jAstPrivateMethod {}

#[allow(dead_code)]
impl JavaSwc4jAstPrivateMethod {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstPrivateMethod")
      .expect("Couldn't find class Swc4jAstPrivateMethod");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstPrivateMethod");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstPrivateName;Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstMethodKind;ZLcom/caoccao/javet/swc4j/ast/enums/Swc4jAstAccessibility;ZZZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstPrivateMethod::new");
    let method_get_accessibility = env
      .get_method_id(
        &class,
        "getAccessibility",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstPrivateMethod.getAccessibility");
    let method_get_function = env
      .get_method_id(
        &class,
        "getFunction",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstFunction;",
      )
      .expect("Couldn't find method Swc4jAstPrivateMethod.getFunction");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstPrivateName;",
      )
      .expect("Couldn't find method Swc4jAstPrivateMethod.getKey");
    let method_get_kind = env
      .get_method_id(
        &class,
        "getKind",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstMethodKind;",
      )
      .expect("Couldn't find method Swc4jAstPrivateMethod.getKind");
    let method_is_abstract = env
      .get_method_id(
        &class,
        "isAbstract",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstPrivateMethod.isAbstract");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstPrivateMethod.isOptional");
    let method_is_override = env
      .get_method_id(
        &class,
        "isOverride",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstPrivateMethod.isOverride");
    let method_is_static = env
      .get_method_id(
        &class,
        "isStatic",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstPrivateMethod.isStatic");
    JavaSwc4jAstPrivateMethod {
      class,
      method_construct,
      method_get_accessibility,
      method_get_function,
      method_get_key,
      method_get_kind,
      method_is_abstract,
      method_is_optional,
      method_is_override,
      method_is_static,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    function: &JObject<'_>,
    kind: &JObject<'_>,
    is_static: bool,
    accessibility: &Option<JObject>,
    is_abstract: bool,
    optional: bool,
    is_override: bool,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let function = object_to_jvalue!(function);
    let kind = object_to_jvalue!(kind);
    let is_static = boolean_to_jvalue!(is_static);
    let accessibility = optional_object_to_jvalue!(accessibility);
    let is_abstract = boolean_to_jvalue!(is_abstract);
    let optional = boolean_to_jvalue!(optional);
    let is_override = boolean_to_jvalue!(is_override);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, function, kind, is_static, accessibility, is_abstract, optional, is_override, span],
        "Swc4jAstPrivateMethod construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_accessibility<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_accessibility,
        &[],
        "Optional get_accessibility()"
      )?;
    Ok(return_value)
  }

  pub fn get_function<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_function,
        &[],
        "Swc4jAstFunction get_function()"
      )?;
    Ok(return_value)
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "Swc4jAstPrivateName get_key()"
      )?;
    Ok(return_value)
  }

  pub fn get_kind<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_kind,
        &[],
        "Swc4jAstMethodKind get_kind()"
      )?;
    Ok(return_value)
  }

  pub fn is_abstract<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_abstract,
        &[],
        "boolean is_abstract()"
      )?;
    Ok(return_value)
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      )?;
    Ok(return_value)
  }

  pub fn is_override<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_override,
        &[],
        "boolean is_override()"
      )?;
    Ok(return_value)
  }

  pub fn is_static<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_static,
        &[],
        "boolean is_static()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstPrivateName {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_name: JMethodID,
}
unsafe impl Send for JavaSwc4jAstPrivateName {}
unsafe impl Sync for JavaSwc4jAstPrivateName {}

#[allow(dead_code)]
impl JavaSwc4jAstPrivateName {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstPrivateName")
      .expect("Couldn't find class Swc4jAstPrivateName");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstPrivateName");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/lang/String;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstPrivateName::new");
    let method_get_name = env
      .get_method_id(
        &class,
        "getName",
        "()Ljava/lang/String;",
      )
      .expect("Couldn't find method Swc4jAstPrivateName.getName");
    JavaSwc4jAstPrivateName {
      class,
      method_construct,
      method_get_name,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    name: &str,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_name = string_to_jstring!(env, &name);
    let name = object_to_jvalue!(java_name);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[name, span],
        "Swc4jAstPrivateName construct()"
      )?;
    delete_local_ref!(env, java_name);
    Ok(return_value)
  }

  pub fn get_name<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<String>
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_name,
        &[],
        "String get_name()"
      )?;
    let java_return_value = return_value;
    let return_value: Result<String> = jstring_to_string!(env, java_return_value.as_raw());
    let return_value = return_value?;
    delete_local_ref!(env, java_return_value);
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstPrivateProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_accessibility: JMethodID,
  method_get_ctxt: JMethodID,
  method_get_decorators: JMethodID,
  method_get_key: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_value: JMethodID,
  method_is_definite: JMethodID,
  method_is_optional: JMethodID,
  method_is_override: JMethodID,
  method_is_readonly: JMethodID,
  method_is_static: JMethodID,
}
unsafe impl Send for JavaSwc4jAstPrivateProp {}
unsafe impl Sync for JavaSwc4jAstPrivateProp {}

#[allow(dead_code)]
impl JavaSwc4jAstPrivateProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstPrivateProp")
      .expect("Couldn't find class Swc4jAstPrivateProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstPrivateProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ILcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstPrivateName;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;ZLjava/util/List;Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstAccessibility;ZZZZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp::new");
    let method_get_accessibility = env
      .get_method_id(
        &class,
        "getAccessibility",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.getAccessibility");
    let method_get_ctxt = env
      .get_method_id(
        &class,
        "getCtxt",
        "()I",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.getCtxt");
    let method_get_decorators = env
      .get_method_id(
        &class,
        "getDecorators",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.getDecorators");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstPrivateName;",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.getKey");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.getTypeAnn");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.getValue");
    let method_is_definite = env
      .get_method_id(
        &class,
        "isDefinite",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.isDefinite");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.isOptional");
    let method_is_override = env
      .get_method_id(
        &class,
        "isOverride",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.isOverride");
    let method_is_readonly = env
      .get_method_id(
        &class,
        "isReadonly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.isReadonly");
    let method_is_static = env
      .get_method_id(
        &class,
        "isStatic",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstPrivateProp.isStatic");
    JavaSwc4jAstPrivateProp {
      class,
      method_construct,
      method_get_accessibility,
      method_get_ctxt,
      method_get_decorators,
      method_get_key,
      method_get_type_ann,
      method_get_value,
      method_is_definite,
      method_is_optional,
      method_is_override,
      method_is_readonly,
      method_is_static,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    ctxt: SyntaxContext,
    key: &JObject<'_>,
    value: &Option<JObject>,
    type_ann: &Option<JObject>,
    is_static: bool,
    decorators: &JObject<'_>,
    accessibility: &Option<JObject>,
    optional: bool,
    is_override: bool,
    readonly: bool,
    definite: bool,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let ctxt = ctxt.as_u32() as i32;
    let ctxt = int_to_jvalue!(ctxt);
    let key = object_to_jvalue!(key);
    let value = optional_object_to_jvalue!(value);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let is_static = boolean_to_jvalue!(is_static);
    let decorators = object_to_jvalue!(decorators);
    let accessibility = optional_object_to_jvalue!(accessibility);
    let optional = boolean_to_jvalue!(optional);
    let is_override = boolean_to_jvalue!(is_override);
    let readonly = boolean_to_jvalue!(readonly);
    let definite = boolean_to_jvalue!(definite);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[ctxt, key, value, type_ann, is_static, decorators, accessibility, optional, is_override, readonly, definite, span],
        "Swc4jAstPrivateProp construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_accessibility<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_accessibility,
        &[],
        "Optional get_accessibility()"
      )?;
    Ok(return_value)
  }

  pub fn get_ctxt<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<i32>
  {
    let return_value = call_as_int!(
        env,
        obj,
        self.method_get_ctxt,
        &[],
        "int get_ctxt()"
      )?;
    Ok(return_value)
  }

  pub fn get_decorators<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decorators,
        &[],
        "List get_decorators()"
      )?;
    Ok(return_value)
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "Swc4jAstPrivateName get_key()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      )?;
    Ok(return_value)
  }

  pub fn get_value<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "Optional get_value()"
      )?;
    Ok(return_value)
  }

  pub fn is_definite<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_definite,
        &[],
        "boolean is_definite()"
      )?;
    Ok(return_value)
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      )?;
    Ok(return_value)
  }

  pub fn is_override<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_override,
        &[],
        "boolean is_override()"
      )?;
    Ok(return_value)
  }

  pub fn is_readonly<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_readonly,
        &[],
        "boolean is_readonly()"
      )?;
    Ok(return_value)
  }

  pub fn is_static<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_static,
        &[],
        "boolean is_static()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstRegex {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_exp: JMethodID,
  method_get_flags: JMethodID,
}
unsafe impl Send for JavaSwc4jAstRegex {}
unsafe impl Sync for JavaSwc4jAstRegex {}

#[allow(dead_code)]
impl JavaSwc4jAstRegex {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstRegex")
      .expect("Couldn't find class Swc4jAstRegex");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstRegex");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/lang/String;Ljava/lang/String;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstRegex::new");
    let method_get_exp = env
      .get_method_id(
        &class,
        "getExp",
        "()Ljava/lang/String;",
      )
      .expect("Couldn't find method Swc4jAstRegex.getExp");
    let method_get_flags = env
      .get_method_id(
        &class,
        "getFlags",
        "()Ljava/lang/String;",
      )
      .expect("Couldn't find method Swc4jAstRegex.getFlags");
    JavaSwc4jAstRegex {
      class,
      method_construct,
      method_get_exp,
      method_get_flags,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    exp: &str,
    flags: &str,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_exp = string_to_jstring!(env, &exp);
    let exp = object_to_jvalue!(java_exp);
    let java_flags = string_to_jstring!(env, &flags);
    let flags = object_to_jvalue!(java_flags);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[exp, flags, span],
        "Swc4jAstRegex construct()"
      )?;
    delete_local_ref!(env, java_exp);
    delete_local_ref!(env, java_flags);
    Ok(return_value)
  }

  pub fn get_exp<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<String>
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_exp,
        &[],
        "String get_exp()"
      )?;
    let java_return_value = return_value;
    let return_value: Result<String> = jstring_to_string!(env, java_return_value.as_raw());
    let return_value = return_value?;
    delete_local_ref!(env, java_return_value);
    Ok(return_value)
  }

  pub fn get_flags<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<String>
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_flags,
        &[],
        "String get_flags()"
      )?;
    let java_return_value = return_value;
    let return_value: Result<String> = jstring_to_string!(env, java_return_value.as_raw());
    let return_value = return_value?;
    delete_local_ref!(env, java_return_value);
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstRestPat {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_arg: JMethodID,
  method_get_dot3_token: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstRestPat {}
unsafe impl Sync for JavaSwc4jAstRestPat {}

#[allow(dead_code)]
impl JavaSwc4jAstRestPat {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/pat/Swc4jAstRestPat")
      .expect("Couldn't find class Swc4jAstRestPat");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstRestPat");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstRestPat::new");
    let method_get_arg = env
      .get_method_id(
        &class,
        "getArg",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;",
      )
      .expect("Couldn't find method Swc4jAstRestPat.getArg");
    let method_get_dot3_token = env
      .get_method_id(
        &class,
        "getDot3Token",
        "()Lcom/caoccao/javet/swc4j/span/Swc4jSpan;",
      )
      .expect("Couldn't find method Swc4jAstRestPat.getDot3Token");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstRestPat.getTypeAnn");
    JavaSwc4jAstRestPat {
      class,
      method_construct,
      method_get_arg,
      method_get_dot3_token,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    dot3_token: &JObject<'_>,
    arg: &JObject<'_>,
    type_ann: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let dot3_token = object_to_jvalue!(dot3_token);
    let arg = object_to_jvalue!(arg);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[dot3_token, arg, type_ann, span],
        "Swc4jAstRestPat construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_arg<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_arg,
        &[],
        "ISwc4jAstPat get_arg()"
      )?;
    Ok(return_value)
  }

  pub fn get_dot3_token<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_dot3_token,
        &[],
        "Swc4jSpan get_dot3_token()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstReturnStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_arg: JMethodID,
}
unsafe impl Send for JavaSwc4jAstReturnStmt {}
unsafe impl Sync for JavaSwc4jAstReturnStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstReturnStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstReturnStmt")
      .expect("Couldn't find class Swc4jAstReturnStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstReturnStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstReturnStmt::new");
    let method_get_arg = env
      .get_method_id(
        &class,
        "getArg",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstReturnStmt.getArg");
    JavaSwc4jAstReturnStmt {
      class,
      method_construct,
      method_get_arg,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    arg: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let arg = optional_object_to_jvalue!(arg);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[arg, span],
        "Swc4jAstReturnStmt construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_arg<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_arg,
        &[],
        "Optional get_arg()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstScript {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_shebang: JMethodID,
}
unsafe impl Send for JavaSwc4jAstScript {}
unsafe impl Sync for JavaSwc4jAstScript {}

#[allow(dead_code)]
impl JavaSwc4jAstScript {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/program/Swc4jAstScript")
      .expect("Couldn't find class Swc4jAstScript");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstScript");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Ljava/lang/String;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstScript::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstScript.getBody");
    let method_get_shebang = env
      .get_method_id(
        &class,
        "getShebang",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstScript.getShebang");
    JavaSwc4jAstScript {
      class,
      method_construct,
      method_get_body,
      method_get_shebang,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    body: &JObject<'_>,
    shebang: &Option<String>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let body = object_to_jvalue!(body);
    let java_shebang = optional_string_to_jstring!(env, &shebang);
    let shebang = object_to_jvalue!(java_shebang);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[body, shebang, span],
        "Swc4jAstScript construct()"
      )?;
    delete_local_ref!(env, java_shebang);
    Ok(return_value)
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "List get_body()"
      )?;
    Ok(return_value)
  }

  pub fn get_shebang<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_shebang,
        &[],
        "Optional get_shebang()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstSeqExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_exprs: JMethodID,
}
unsafe impl Send for JavaSwc4jAstSeqExpr {}
unsafe impl Sync for JavaSwc4jAstSeqExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstSeqExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstSeqExpr")
      .expect("Couldn't find class Swc4jAstSeqExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstSeqExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstSeqExpr::new");
    let method_get_exprs = env
      .get_method_id(
        &class,
        "getExprs",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstSeqExpr.getExprs");
    JavaSwc4jAstSeqExpr {
      class,
      method_construct,
      method_get_exprs,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    exprs: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let exprs = object_to_jvalue!(exprs);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[exprs, span],
        "Swc4jAstSeqExpr construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_exprs<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_exprs,
        &[],
        "List get_exprs()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstSetterProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_key: JMethodID,
  method_get_param: JMethodID,
  method_get_this_param: JMethodID,
}
unsafe impl Send for JavaSwc4jAstSetterProp {}
unsafe impl Sync for JavaSwc4jAstSetterProp {}

#[allow(dead_code)]
impl JavaSwc4jAstSetterProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstSetterProp")
      .expect("Couldn't find class Swc4jAstSetterProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstSetterProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstSetterProp::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstSetterProp.getBody");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPropName;",
      )
      .expect("Couldn't find method Swc4jAstSetterProp.getKey");
    let method_get_param = env
      .get_method_id(
        &class,
        "getParam",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;",
      )
      .expect("Couldn't find method Swc4jAstSetterProp.getParam");
    let method_get_this_param = env
      .get_method_id(
        &class,
        "getThisParam",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstSetterProp.getThisParam");
    JavaSwc4jAstSetterProp {
      class,
      method_construct,
      method_get_body,
      method_get_key,
      method_get_param,
      method_get_this_param,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    this_param: &Option<JObject>,
    param: &JObject<'_>,
    body: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let this_param = optional_object_to_jvalue!(this_param);
    let param = object_to_jvalue!(param);
    let body = optional_object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, this_param, param, body, span],
        "Swc4jAstSetterProp construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "Optional get_body()"
      )?;
    Ok(return_value)
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstPropName get_key()"
      )?;
    Ok(return_value)
  }

  pub fn get_param<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_param,
        &[],
        "ISwc4jAstPat get_param()"
      )?;
    Ok(return_value)
  }

  pub fn get_this_param<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_this_param,
        &[],
        "Optional get_this_param()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstSpreadElement {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_dot3_token: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstSpreadElement {}
unsafe impl Sync for JavaSwc4jAstSpreadElement {}

#[allow(dead_code)]
impl JavaSwc4jAstSpreadElement {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstSpreadElement")
      .expect("Couldn't find class Swc4jAstSpreadElement");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstSpreadElement");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstSpreadElement::new");
    let method_get_dot3_token = env
      .get_method_id(
        &class,
        "getDot3Token",
        "()Lcom/caoccao/javet/swc4j/span/Swc4jSpan;",
      )
      .expect("Couldn't find method Swc4jAstSpreadElement.getDot3Token");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstSpreadElement.getExpr");
    JavaSwc4jAstSpreadElement {
      class,
      method_construct,
      method_get_dot3_token,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    dot3_token: &JObject<'_>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let dot3_token = object_to_jvalue!(dot3_token);
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[dot3_token, expr, span],
        "Swc4jAstSpreadElement construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_dot3_token<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_dot3_token,
        &[],
        "Swc4jSpan get_dot3_token()"
      )?;
    Ok(return_value)
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstStaticBlock {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
}
unsafe impl Send for JavaSwc4jAstStaticBlock {}
unsafe impl Sync for JavaSwc4jAstStaticBlock {}

#[allow(dead_code)]
impl JavaSwc4jAstStaticBlock {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstStaticBlock")
      .expect("Couldn't find class Swc4jAstStaticBlock");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstStaticBlock");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstStaticBlock::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;",
      )
      .expect("Couldn't find method Swc4jAstStaticBlock.getBody");
    JavaSwc4jAstStaticBlock {
      class,
      method_construct,
      method_get_body,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[body, span],
        "Swc4jAstStaticBlock construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "Swc4jAstBlockStmt get_body()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstStr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_raw: JMethodID,
  method_get_value: JMethodID,
}
unsafe impl Send for JavaSwc4jAstStr {}
unsafe impl Sync for JavaSwc4jAstStr {}

#[allow(dead_code)]
impl JavaSwc4jAstStr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr")
      .expect("Couldn't find class Swc4jAstStr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstStr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/lang/String;Ljava/lang/String;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstStr::new");
    let method_get_raw = env
      .get_method_id(
        &class,
        "getRaw",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstStr.getRaw");
    let method_get_value = env
      .get_method_id(
        &class,
        "getValue",
        "()Ljava/lang/String;",
      )
      .expect("Couldn't find method Swc4jAstStr.getValue");
    JavaSwc4jAstStr {
      class,
      method_construct,
      method_get_raw,
      method_get_value,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    value: &str,
    raw: &Option<String>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_value = string_to_jstring!(env, &value);
    let value = object_to_jvalue!(java_value);
    let java_raw = optional_string_to_jstring!(env, &raw);
    let raw = object_to_jvalue!(java_raw);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[value, raw, span],
        "Swc4jAstStr construct()"
      )?;
    delete_local_ref!(env, java_value);
    delete_local_ref!(env, java_raw);
    Ok(return_value)
  }

  pub fn get_raw<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_raw,
        &[],
        "Optional get_raw()"
      )?;
    Ok(return_value)
  }

  pub fn get_value<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<String>
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_value,
        &[],
        "String get_value()"
      )?;
    let java_return_value = return_value;
    let return_value: Result<String> = jstring_to_string!(env, java_return_value.as_raw());
    let return_value = return_value?;
    delete_local_ref!(env, java_return_value);
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstSuper {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstSuper {}
unsafe impl Sync for JavaSwc4jAstSuper {}

#[allow(dead_code)]
impl JavaSwc4jAstSuper {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/clazz/Swc4jAstSuper")
      .expect("Couldn't find class Swc4jAstSuper");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstSuper");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstSuper::new");
    JavaSwc4jAstSuper {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstSuper construct()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstSuperPropExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_obj: JMethodID,
  method_get_prop: JMethodID,
}
unsafe impl Send for JavaSwc4jAstSuperPropExpr {}
unsafe impl Sync for JavaSwc4jAstSuperPropExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstSuperPropExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstSuperPropExpr")
      .expect("Couldn't find class Swc4jAstSuperPropExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstSuperPropExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstSuper;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstSuperProp;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstSuperPropExpr::new");
    let method_get_obj = env
      .get_method_id(
        &class,
        "getObj",
        "()Lcom/caoccao/javet/swc4j/ast/clazz/Swc4jAstSuper;",
      )
      .expect("Couldn't find method Swc4jAstSuperPropExpr.getObj");
    let method_get_prop = env
      .get_method_id(
        &class,
        "getProp",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstSuperProp;",
      )
      .expect("Couldn't find method Swc4jAstSuperPropExpr.getProp");
    JavaSwc4jAstSuperPropExpr {
      class,
      method_construct,
      method_get_obj,
      method_get_prop,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
    prop: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let obj = object_to_jvalue!(obj);
    let prop = object_to_jvalue!(prop);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[obj, prop, span],
        "Swc4jAstSuperPropExpr construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_obj<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_obj,
        &[],
        "Swc4jAstSuper get_obj()"
      )?;
    Ok(return_value)
  }

  pub fn get_prop<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_prop,
        &[],
        "ISwc4jAstSuperProp get_prop()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstSwitchCase {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_cons: JMethodID,
  method_get_test: JMethodID,
}
unsafe impl Send for JavaSwc4jAstSwitchCase {}
unsafe impl Sync for JavaSwc4jAstSwitchCase {}

#[allow(dead_code)]
impl JavaSwc4jAstSwitchCase {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/miscs/Swc4jAstSwitchCase")
      .expect("Couldn't find class Swc4jAstSwitchCase");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstSwitchCase");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstSwitchCase::new");
    let method_get_cons = env
      .get_method_id(
        &class,
        "getCons",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstSwitchCase.getCons");
    let method_get_test = env
      .get_method_id(
        &class,
        "getTest",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstSwitchCase.getTest");
    JavaSwc4jAstSwitchCase {
      class,
      method_construct,
      method_get_cons,
      method_get_test,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    test: &Option<JObject>,
    cons: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let test = optional_object_to_jvalue!(test);
    let cons = object_to_jvalue!(cons);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[test, cons, span],
        "Swc4jAstSwitchCase construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_cons<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_cons,
        &[],
        "List get_cons()"
      )?;
    Ok(return_value)
  }

  pub fn get_test<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_test,
        &[],
        "Optional get_test()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstSwitchStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_cases: JMethodID,
  method_get_discriminant: JMethodID,
}
unsafe impl Send for JavaSwc4jAstSwitchStmt {}
unsafe impl Sync for JavaSwc4jAstSwitchStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstSwitchStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstSwitchStmt")
      .expect("Couldn't find class Swc4jAstSwitchStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstSwitchStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstSwitchStmt::new");
    let method_get_cases = env
      .get_method_id(
        &class,
        "getCases",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstSwitchStmt.getCases");
    let method_get_discriminant = env
      .get_method_id(
        &class,
        "getDiscriminant",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstSwitchStmt.getDiscriminant");
    JavaSwc4jAstSwitchStmt {
      class,
      method_construct,
      method_get_cases,
      method_get_discriminant,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    discriminant: &JObject<'_>,
    cases: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let discriminant = object_to_jvalue!(discriminant);
    let cases = object_to_jvalue!(cases);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[discriminant, cases, span],
        "Swc4jAstSwitchStmt construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_cases<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_cases,
        &[],
        "List get_cases()"
      )?;
    Ok(return_value)
  }

  pub fn get_discriminant<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_discriminant,
        &[],
        "ISwc4jAstExpr get_discriminant()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTaggedTpl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_ctxt: JMethodID,
  method_get_tag: JMethodID,
  method_get_tpl: JMethodID,
  method_get_type_params: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTaggedTpl {}
unsafe impl Sync for JavaSwc4jAstTaggedTpl {}

#[allow(dead_code)]
impl JavaSwc4jAstTaggedTpl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstTaggedTpl")
      .expect("Couldn't find class Swc4jAstTaggedTpl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTaggedTpl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ILcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstTpl;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTaggedTpl::new");
    let method_get_ctxt = env
      .get_method_id(
        &class,
        "getCtxt",
        "()I",
      )
      .expect("Couldn't find method Swc4jAstTaggedTpl.getCtxt");
    let method_get_tag = env
      .get_method_id(
        &class,
        "getTag",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTaggedTpl.getTag");
    let method_get_tpl = env
      .get_method_id(
        &class,
        "getTpl",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstTpl;",
      )
      .expect("Couldn't find method Swc4jAstTaggedTpl.getTpl");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTaggedTpl.getTypeParams");
    JavaSwc4jAstTaggedTpl {
      class,
      method_construct,
      method_get_ctxt,
      method_get_tag,
      method_get_tpl,
      method_get_type_params,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    ctxt: SyntaxContext,
    tag: &JObject<'_>,
    type_params: &Option<JObject>,
    tpl: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let ctxt = ctxt.as_u32() as i32;
    let ctxt = int_to_jvalue!(ctxt);
    let tag = object_to_jvalue!(tag);
    let type_params = optional_object_to_jvalue!(type_params);
    let tpl = object_to_jvalue!(tpl);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[ctxt, tag, type_params, tpl, span],
        "Swc4jAstTaggedTpl construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_ctxt<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<i32>
  {
    let return_value = call_as_int!(
        env,
        obj,
        self.method_get_ctxt,
        &[],
        "int get_ctxt()"
      )?;
    Ok(return_value)
  }

  pub fn get_tag<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_tag,
        &[],
        "ISwc4jAstExpr get_tag()"
      )?;
    Ok(return_value)
  }

  pub fn get_tpl<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_tpl,
        &[],
        "Swc4jAstTpl get_tpl()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstThisExpr {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstThisExpr {}
unsafe impl Sync for JavaSwc4jAstThisExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstThisExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstThisExpr")
      .expect("Couldn't find class Swc4jAstThisExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstThisExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstThisExpr::new");
    JavaSwc4jAstThisExpr {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstThisExpr construct()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstThrowStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_arg: JMethodID,
}
unsafe impl Send for JavaSwc4jAstThrowStmt {}
unsafe impl Sync for JavaSwc4jAstThrowStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstThrowStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstThrowStmt")
      .expect("Couldn't find class Swc4jAstThrowStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstThrowStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstThrowStmt::new");
    let method_get_arg = env
      .get_method_id(
        &class,
        "getArg",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstThrowStmt.getArg");
    JavaSwc4jAstThrowStmt {
      class,
      method_construct,
      method_get_arg,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    arg: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let arg = object_to_jvalue!(arg);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[arg, span],
        "Swc4jAstThrowStmt construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_arg<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_arg,
        &[],
        "ISwc4jAstExpr get_arg()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTpl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_exprs: JMethodID,
  method_get_quasis: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTpl {}
unsafe impl Sync for JavaSwc4jAstTpl {}

#[allow(dead_code)]
impl JavaSwc4jAstTpl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstTpl")
      .expect("Couldn't find class Swc4jAstTpl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTpl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTpl::new");
    let method_get_exprs = env
      .get_method_id(
        &class,
        "getExprs",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTpl.getExprs");
    let method_get_quasis = env
      .get_method_id(
        &class,
        "getQuasis",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTpl.getQuasis");
    JavaSwc4jAstTpl {
      class,
      method_construct,
      method_get_exprs,
      method_get_quasis,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    exprs: &JObject<'_>,
    quasis: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let exprs = object_to_jvalue!(exprs);
    let quasis = object_to_jvalue!(quasis);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[exprs, quasis, span],
        "Swc4jAstTpl construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_exprs<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_exprs,
        &[],
        "List get_exprs()"
      )?;
    Ok(return_value)
  }

  pub fn get_quasis<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_quasis,
        &[],
        "List get_quasis()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTplElement {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_cooked: JMethodID,
  method_get_raw: JMethodID,
  method_is_tail: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTplElement {}
unsafe impl Sync for JavaSwc4jAstTplElement {}

#[allow(dead_code)]
impl JavaSwc4jAstTplElement {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/miscs/Swc4jAstTplElement")
      .expect("Couldn't find class Swc4jAstTplElement");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTplElement");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLjava/lang/String;Ljava/lang/String;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTplElement::new");
    let method_get_cooked = env
      .get_method_id(
        &class,
        "getCooked",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTplElement.getCooked");
    let method_get_raw = env
      .get_method_id(
        &class,
        "getRaw",
        "()Ljava/lang/String;",
      )
      .expect("Couldn't find method Swc4jAstTplElement.getRaw");
    let method_is_tail = env
      .get_method_id(
        &class,
        "isTail",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTplElement.isTail");
    JavaSwc4jAstTplElement {
      class,
      method_construct,
      method_get_cooked,
      method_get_raw,
      method_is_tail,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    tail: bool,
    cooked: &Option<String>,
    raw: &str,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let tail = boolean_to_jvalue!(tail);
    let java_cooked = optional_string_to_jstring!(env, &cooked);
    let cooked = object_to_jvalue!(java_cooked);
    let java_raw = string_to_jstring!(env, &raw);
    let raw = object_to_jvalue!(java_raw);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[tail, cooked, raw, span],
        "Swc4jAstTplElement construct()"
      )?;
    delete_local_ref!(env, java_cooked);
    delete_local_ref!(env, java_raw);
    Ok(return_value)
  }

  pub fn get_cooked<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_cooked,
        &[],
        "Optional get_cooked()"
      )?;
    Ok(return_value)
  }

  pub fn get_raw<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<String>
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_raw,
        &[],
        "String get_raw()"
      )?;
    let java_return_value = return_value;
    let return_value: Result<String> = jstring_to_string!(env, java_return_value.as_raw());
    let return_value = return_value?;
    delete_local_ref!(env, java_return_value);
    Ok(return_value)
  }

  pub fn is_tail<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_tail,
        &[],
        "boolean is_tail()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTryStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_block: JMethodID,
  method_get_finalizer: JMethodID,
  method_get_handler: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTryStmt {}
unsafe impl Sync for JavaSwc4jAstTryStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstTryStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstTryStmt")
      .expect("Couldn't find class Swc4jAstTryStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTryStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;Lcom/caoccao/javet/swc4j/ast/miscs/Swc4jAstCatchClause;Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTryStmt::new");
    let method_get_block = env
      .get_method_id(
        &class,
        "getBlock",
        "()Lcom/caoccao/javet/swc4j/ast/stmt/Swc4jAstBlockStmt;",
      )
      .expect("Couldn't find method Swc4jAstTryStmt.getBlock");
    let method_get_finalizer = env
      .get_method_id(
        &class,
        "getFinalizer",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTryStmt.getFinalizer");
    let method_get_handler = env
      .get_method_id(
        &class,
        "getHandler",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTryStmt.getHandler");
    JavaSwc4jAstTryStmt {
      class,
      method_construct,
      method_get_block,
      method_get_finalizer,
      method_get_handler,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    block: &JObject<'_>,
    handler: &Option<JObject>,
    finalizer: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let block = object_to_jvalue!(block);
    let handler = optional_object_to_jvalue!(handler);
    let finalizer = optional_object_to_jvalue!(finalizer);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[block, handler, finalizer, span],
        "Swc4jAstTryStmt construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_block<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_block,
        &[],
        "Swc4jAstBlockStmt get_block()"
      )?;
    Ok(return_value)
  }

  pub fn get_finalizer<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_finalizer,
        &[],
        "Optional get_finalizer()"
      )?;
    Ok(return_value)
  }

  pub fn get_handler<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_handler,
        &[],
        "Optional get_handler()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsArrayType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_elem_type: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsArrayType {}
unsafe impl Sync for JavaSwc4jAstTsArrayType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsArrayType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsArrayType")
      .expect("Couldn't find class Swc4jAstTsArrayType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsArrayType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsArrayType::new");
    let method_get_elem_type = env
      .get_method_id(
        &class,
        "getElemType",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsArrayType.getElemType");
    JavaSwc4jAstTsArrayType {
      class,
      method_construct,
      method_get_elem_type,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    elem_type: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let elem_type = object_to_jvalue!(elem_type);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[elem_type, span],
        "Swc4jAstTsArrayType construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_elem_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_elem_type,
        &[],
        "ISwc4jAstTsType get_elem_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsAsExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsAsExpr {}
unsafe impl Sync for JavaSwc4jAstTsAsExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstTsAsExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstTsAsExpr")
      .expect("Couldn't find class Swc4jAstTsAsExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsAsExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsAsExpr::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsAsExpr.getExpr");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsAsExpr.getTypeAnn");
    JavaSwc4jAstTsAsExpr {
      class,
      method_construct,
      method_get_expr,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, type_ann, span],
        "Swc4jAstTsAsExpr construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "ISwc4jAstTsType get_type_ann()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsCallSignatureDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_params: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_type_params: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsCallSignatureDecl {}
unsafe impl Sync for JavaSwc4jAstTsCallSignatureDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsCallSignatureDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsCallSignatureDecl")
      .expect("Couldn't find class Swc4jAstTsCallSignatureDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsCallSignatureDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsCallSignatureDecl::new");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsCallSignatureDecl.getParams");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsCallSignatureDecl.getTypeAnn");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsCallSignatureDecl.getTypeParams");
    JavaSwc4jAstTsCallSignatureDecl {
      class,
      method_construct,
      method_get_params,
      method_get_type_ann,
      method_get_type_params,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    params: &JObject<'_>,
    type_ann: &Option<JObject>,
    type_params: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let params = object_to_jvalue!(params);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let type_params = optional_object_to_jvalue!(type_params);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[params, type_ann, type_params, span],
        "Swc4jAstTsCallSignatureDecl construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsConditionalType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_check_type: JMethodID,
  method_get_extends_type: JMethodID,
  method_get_false_type: JMethodID,
  method_get_true_type: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsConditionalType {}
unsafe impl Sync for JavaSwc4jAstTsConditionalType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsConditionalType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsConditionalType")
      .expect("Couldn't find class Swc4jAstTsConditionalType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsConditionalType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsConditionalType::new");
    let method_get_check_type = env
      .get_method_id(
        &class,
        "getCheckType",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsConditionalType.getCheckType");
    let method_get_extends_type = env
      .get_method_id(
        &class,
        "getExtendsType",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsConditionalType.getExtendsType");
    let method_get_false_type = env
      .get_method_id(
        &class,
        "getFalseType",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsConditionalType.getFalseType");
    let method_get_true_type = env
      .get_method_id(
        &class,
        "getTrueType",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsConditionalType.getTrueType");
    JavaSwc4jAstTsConditionalType {
      class,
      method_construct,
      method_get_check_type,
      method_get_extends_type,
      method_get_false_type,
      method_get_true_type,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    check_type: &JObject<'_>,
    extends_type: &JObject<'_>,
    true_type: &JObject<'_>,
    false_type: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let check_type = object_to_jvalue!(check_type);
    let extends_type = object_to_jvalue!(extends_type);
    let true_type = object_to_jvalue!(true_type);
    let false_type = object_to_jvalue!(false_type);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[check_type, extends_type, true_type, false_type, span],
        "Swc4jAstTsConditionalType construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_check_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_check_type,
        &[],
        "ISwc4jAstTsType get_check_type()"
      )?;
    Ok(return_value)
  }

  pub fn get_extends_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_extends_type,
        &[],
        "ISwc4jAstTsType get_extends_type()"
      )?;
    Ok(return_value)
  }

  pub fn get_false_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_false_type,
        &[],
        "ISwc4jAstTsType get_false_type()"
      )?;
    Ok(return_value)
  }

  pub fn get_true_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_true_type,
        &[],
        "ISwc4jAstTsType get_true_type()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsConstAssertion {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsConstAssertion {}
unsafe impl Sync for JavaSwc4jAstTsConstAssertion {}

#[allow(dead_code)]
impl JavaSwc4jAstTsConstAssertion {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstTsConstAssertion")
      .expect("Couldn't find class Swc4jAstTsConstAssertion");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsConstAssertion");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsConstAssertion::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsConstAssertion.getExpr");
    JavaSwc4jAstTsConstAssertion {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstTsConstAssertion construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsConstructSignatureDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_params: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_type_params: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsConstructSignatureDecl {}
unsafe impl Sync for JavaSwc4jAstTsConstructSignatureDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsConstructSignatureDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsConstructSignatureDecl")
      .expect("Couldn't find class Swc4jAstTsConstructSignatureDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsConstructSignatureDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsConstructSignatureDecl::new");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsConstructSignatureDecl.getParams");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsConstructSignatureDecl.getTypeAnn");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsConstructSignatureDecl.getTypeParams");
    JavaSwc4jAstTsConstructSignatureDecl {
      class,
      method_construct,
      method_get_params,
      method_get_type_ann,
      method_get_type_params,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    params: &JObject<'_>,
    type_ann: &Option<JObject>,
    type_params: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let params = object_to_jvalue!(params);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let type_params = optional_object_to_jvalue!(type_params);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[params, type_ann, type_params, span],
        "Swc4jAstTsConstructSignatureDecl construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsConstructorType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_params: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_type_params: JMethodID,
  method_is_abstract: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsConstructorType {}
unsafe impl Sync for JavaSwc4jAstTsConstructorType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsConstructorType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsConstructorType")
      .expect("Couldn't find class Swc4jAstTsConstructorType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsConstructorType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;ZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsConstructorType::new");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsConstructorType.getParams");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;",
      )
      .expect("Couldn't find method Swc4jAstTsConstructorType.getTypeAnn");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsConstructorType.getTypeParams");
    let method_is_abstract = env
      .get_method_id(
        &class,
        "isAbstract",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsConstructorType.isAbstract");
    JavaSwc4jAstTsConstructorType {
      class,
      method_construct,
      method_get_params,
      method_get_type_ann,
      method_get_type_params,
      method_is_abstract,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    params: &JObject<'_>,
    type_params: &Option<JObject>,
    type_ann: &JObject<'_>,
    is_abstract: bool,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let params = object_to_jvalue!(params);
    let type_params = optional_object_to_jvalue!(type_params);
    let type_ann = object_to_jvalue!(type_ann);
    let is_abstract = boolean_to_jvalue!(is_abstract);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[params, type_params, type_ann, is_abstract, span],
        "Swc4jAstTsConstructorType construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Swc4jAstTsTypeAnn get_type_ann()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      )?;
    Ok(return_value)
  }

  pub fn is_abstract<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_abstract,
        &[],
        "boolean is_abstract()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsEnumDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_id: JMethodID,
  method_get_members: JMethodID,
  method_is_const: JMethodID,
  method_is_declare: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsEnumDecl {}
unsafe impl Sync for JavaSwc4jAstTsEnumDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsEnumDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstTsEnumDecl")
      .expect("Couldn't find class Swc4jAstTsEnumDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsEnumDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZZLcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsEnumDecl::new");
    let method_get_id = env
      .get_method_id(
        &class,
        "getId",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstTsEnumDecl.getId");
    let method_get_members = env
      .get_method_id(
        &class,
        "getMembers",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsEnumDecl.getMembers");
    let method_is_const = env
      .get_method_id(
        &class,
        "isConst",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsEnumDecl.isConst");
    let method_is_declare = env
      .get_method_id(
        &class,
        "isDeclare",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsEnumDecl.isDeclare");
    JavaSwc4jAstTsEnumDecl {
      class,
      method_construct,
      method_get_id,
      method_get_members,
      method_is_const,
      method_is_declare,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    declare: bool,
    is_const: bool,
    id: &JObject<'_>,
    members: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let declare = boolean_to_jvalue!(declare);
    let is_const = boolean_to_jvalue!(is_const);
    let id = object_to_jvalue!(id);
    let members = object_to_jvalue!(members);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[declare, is_const, id, members, span],
        "Swc4jAstTsEnumDecl construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_id<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_id,
        &[],
        "Swc4jAstIdent get_id()"
      )?;
    Ok(return_value)
  }

  pub fn get_members<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_members,
        &[],
        "List get_members()"
      )?;
    Ok(return_value)
  }

  pub fn is_const<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_const,
        &[],
        "boolean is_const()"
      )?;
    Ok(return_value)
  }

  pub fn is_declare<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_declare,
        &[],
        "boolean is_declare()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsEnumMember {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_id: JMethodID,
  method_get_init: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsEnumMember {}
unsafe impl Sync for JavaSwc4jAstTsEnumMember {}

#[allow(dead_code)]
impl JavaSwc4jAstTsEnumMember {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsEnumMember")
      .expect("Couldn't find class Swc4jAstTsEnumMember");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsEnumMember");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsEnumMemberId;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsEnumMember::new");
    let method_get_id = env
      .get_method_id(
        &class,
        "getId",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsEnumMemberId;",
      )
      .expect("Couldn't find method Swc4jAstTsEnumMember.getId");
    let method_get_init = env
      .get_method_id(
        &class,
        "getInit",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsEnumMember.getInit");
    JavaSwc4jAstTsEnumMember {
      class,
      method_construct,
      method_get_id,
      method_get_init,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    id: &JObject<'_>,
    init: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let id = object_to_jvalue!(id);
    let init = optional_object_to_jvalue!(init);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[id, init, span],
        "Swc4jAstTsEnumMember construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_id<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_id,
        &[],
        "ISwc4jAstTsEnumMemberId get_id()"
      )?;
    Ok(return_value)
  }

  pub fn get_init<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_init,
        &[],
        "Optional get_init()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsExportAssignment {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsExportAssignment {}
unsafe impl Sync for JavaSwc4jAstTsExportAssignment {}

#[allow(dead_code)]
impl JavaSwc4jAstTsExportAssignment {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstTsExportAssignment")
      .expect("Couldn't find class Swc4jAstTsExportAssignment");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsExportAssignment");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsExportAssignment::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsExportAssignment.getExpr");
    JavaSwc4jAstTsExportAssignment {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstTsExportAssignment construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsExprWithTypeArgs {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
  method_get_type_args: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsExprWithTypeArgs {}
unsafe impl Sync for JavaSwc4jAstTsExprWithTypeArgs {}

#[allow(dead_code)]
impl JavaSwc4jAstTsExprWithTypeArgs {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsExprWithTypeArgs")
      .expect("Couldn't find class Swc4jAstTsExprWithTypeArgs");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsExprWithTypeArgs");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsExprWithTypeArgs::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsExprWithTypeArgs.getExpr");
    let method_get_type_args = env
      .get_method_id(
        &class,
        "getTypeArgs",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsExprWithTypeArgs.getTypeArgs");
    JavaSwc4jAstTsExprWithTypeArgs {
      class,
      method_construct,
      method_get_expr,
      method_get_type_args,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    type_args: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let type_args = optional_object_to_jvalue!(type_args);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, type_args, span],
        "Swc4jAstTsExprWithTypeArgs construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_args,
        &[],
        "Optional get_type_args()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsExternalModuleRef {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsExternalModuleRef {}
unsafe impl Sync for JavaSwc4jAstTsExternalModuleRef {}

#[allow(dead_code)]
impl JavaSwc4jAstTsExternalModuleRef {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstTsExternalModuleRef")
      .expect("Couldn't find class Swc4jAstTsExternalModuleRef");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsExternalModuleRef");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsExternalModuleRef::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr;",
      )
      .expect("Couldn't find method Swc4jAstTsExternalModuleRef.getExpr");
    JavaSwc4jAstTsExternalModuleRef {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstTsExternalModuleRef construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "Swc4jAstStr get_expr()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsFnType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_params: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_type_params: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsFnType {}
unsafe impl Sync for JavaSwc4jAstTsFnType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsFnType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsFnType")
      .expect("Couldn't find class Swc4jAstTsFnType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsFnType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsFnType::new");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsFnType.getParams");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;",
      )
      .expect("Couldn't find method Swc4jAstTsFnType.getTypeAnn");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsFnType.getTypeParams");
    JavaSwc4jAstTsFnType {
      class,
      method_construct,
      method_get_params,
      method_get_type_ann,
      method_get_type_params,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    params: &JObject<'_>,
    type_params: &Option<JObject>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let params = object_to_jvalue!(params);
    let type_params = optional_object_to_jvalue!(type_params);
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[params, type_params, type_ann, span],
        "Swc4jAstTsFnType construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Swc4jAstTsTypeAnn get_type_ann()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsGetterSignature {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_key: JMethodID,
  method_get_type_ann: JMethodID,
  method_is_computed: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsGetterSignature {}
unsafe impl Sync for JavaSwc4jAstTsGetterSignature {}

#[allow(dead_code)]
impl JavaSwc4jAstTsGetterSignature {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsGetterSignature")
      .expect("Couldn't find class Swc4jAstTsGetterSignature");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsGetterSignature");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;ZLcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsGetterSignature::new");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsGetterSignature.getKey");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsGetterSignature.getTypeAnn");
    let method_is_computed = env
      .get_method_id(
        &class,
        "isComputed",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsGetterSignature.isComputed");
    JavaSwc4jAstTsGetterSignature {
      class,
      method_construct,
      method_get_key,
      method_get_type_ann,
      method_is_computed,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    computed: bool,
    type_ann: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let computed = boolean_to_jvalue!(computed);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, computed, type_ann, span],
        "Swc4jAstTsGetterSignature construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstExpr get_key()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      )?;
    Ok(return_value)
  }

  pub fn is_computed<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_computed,
        &[],
        "boolean is_computed()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsImportEqualsDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_id: JMethodID,
  method_get_module_ref: JMethodID,
  method_is_export: JMethodID,
  method_is_type_only: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsImportEqualsDecl {}
unsafe impl Sync for JavaSwc4jAstTsImportEqualsDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsImportEqualsDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstTsImportEqualsDecl")
      .expect("Couldn't find class Swc4jAstTsImportEqualsDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsImportEqualsDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZZLcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsModuleRef;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsImportEqualsDecl::new");
    let method_get_id = env
      .get_method_id(
        &class,
        "getId",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstTsImportEqualsDecl.getId");
    let method_get_module_ref = env
      .get_method_id(
        &class,
        "getModuleRef",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsModuleRef;",
      )
      .expect("Couldn't find method Swc4jAstTsImportEqualsDecl.getModuleRef");
    let method_is_export = env
      .get_method_id(
        &class,
        "isExport",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsImportEqualsDecl.isExport");
    let method_is_type_only = env
      .get_method_id(
        &class,
        "isTypeOnly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsImportEqualsDecl.isTypeOnly");
    JavaSwc4jAstTsImportEqualsDecl {
      class,
      method_construct,
      method_get_id,
      method_get_module_ref,
      method_is_export,
      method_is_type_only,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    export: bool,
    type_only: bool,
    id: &JObject<'_>,
    module_ref: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let export = boolean_to_jvalue!(export);
    let type_only = boolean_to_jvalue!(type_only);
    let id = object_to_jvalue!(id);
    let module_ref = object_to_jvalue!(module_ref);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[export, type_only, id, module_ref, span],
        "Swc4jAstTsImportEqualsDecl construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_id<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_id,
        &[],
        "Swc4jAstIdent get_id()"
      )?;
    Ok(return_value)
  }

  pub fn get_module_ref<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_module_ref,
        &[],
        "ISwc4jAstTsModuleRef get_module_ref()"
      )?;
    Ok(return_value)
  }

  pub fn is_export<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_export,
        &[],
        "boolean is_export()"
      )?;
    Ok(return_value)
  }

  pub fn is_type_only<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_type_only,
        &[],
        "boolean is_type_only()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsImportType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_arg: JMethodID,
  method_get_qualifier: JMethodID,
  method_get_type_args: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsImportType {}
unsafe impl Sync for JavaSwc4jAstTsImportType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsImportType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsImportType")
      .expect("Couldn't find class Swc4jAstTsImportType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsImportType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsEntityName;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsImportType::new");
    let method_get_arg = env
      .get_method_id(
        &class,
        "getArg",
        "()Lcom/caoccao/javet/swc4j/ast/expr/lit/Swc4jAstStr;",
      )
      .expect("Couldn't find method Swc4jAstTsImportType.getArg");
    let method_get_qualifier = env
      .get_method_id(
        &class,
        "getQualifier",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsImportType.getQualifier");
    let method_get_type_args = env
      .get_method_id(
        &class,
        "getTypeArgs",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsImportType.getTypeArgs");
    JavaSwc4jAstTsImportType {
      class,
      method_construct,
      method_get_arg,
      method_get_qualifier,
      method_get_type_args,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    arg: &JObject<'_>,
    qualifier: &Option<JObject>,
    type_args: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let arg = object_to_jvalue!(arg);
    let qualifier = optional_object_to_jvalue!(qualifier);
    let type_args = optional_object_to_jvalue!(type_args);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[arg, qualifier, type_args, span],
        "Swc4jAstTsImportType construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_arg<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_arg,
        &[],
        "Swc4jAstStr get_arg()"
      )?;
    Ok(return_value)
  }

  pub fn get_qualifier<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_qualifier,
        &[],
        "Optional get_qualifier()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_args,
        &[],
        "Optional get_type_args()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsIndexSignature {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_params: JMethodID,
  method_get_type_ann: JMethodID,
  method_is_readonly: JMethodID,
  method_is_static: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsIndexSignature {}
unsafe impl Sync for JavaSwc4jAstTsIndexSignature {}

#[allow(dead_code)]
impl JavaSwc4jAstTsIndexSignature {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsIndexSignature")
      .expect("Couldn't find class Swc4jAstTsIndexSignature");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsIndexSignature");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;ZZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsIndexSignature::new");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsIndexSignature.getParams");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsIndexSignature.getTypeAnn");
    let method_is_readonly = env
      .get_method_id(
        &class,
        "isReadonly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsIndexSignature.isReadonly");
    let method_is_static = env
      .get_method_id(
        &class,
        "isStatic",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsIndexSignature.isStatic");
    JavaSwc4jAstTsIndexSignature {
      class,
      method_construct,
      method_get_params,
      method_get_type_ann,
      method_is_readonly,
      method_is_static,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    params: &JObject<'_>,
    type_ann: &Option<JObject>,
    readonly: bool,
    is_static: bool,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let params = object_to_jvalue!(params);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let readonly = boolean_to_jvalue!(readonly);
    let is_static = boolean_to_jvalue!(is_static);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[params, type_ann, readonly, is_static, span],
        "Swc4jAstTsIndexSignature construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      )?;
    Ok(return_value)
  }

  pub fn is_readonly<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_readonly,
        &[],
        "boolean is_readonly()"
      )?;
    Ok(return_value)
  }

  pub fn is_static<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_static,
        &[],
        "boolean is_static()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsIndexedAccessType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_index_type: JMethodID,
  method_get_obj_type: JMethodID,
  method_is_readonly: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsIndexedAccessType {}
unsafe impl Sync for JavaSwc4jAstTsIndexedAccessType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsIndexedAccessType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsIndexedAccessType")
      .expect("Couldn't find class Swc4jAstTsIndexedAccessType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsIndexedAccessType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsIndexedAccessType::new");
    let method_get_index_type = env
      .get_method_id(
        &class,
        "getIndexType",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsIndexedAccessType.getIndexType");
    let method_get_obj_type = env
      .get_method_id(
        &class,
        "getObjType",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsIndexedAccessType.getObjType");
    let method_is_readonly = env
      .get_method_id(
        &class,
        "isReadonly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsIndexedAccessType.isReadonly");
    JavaSwc4jAstTsIndexedAccessType {
      class,
      method_construct,
      method_get_index_type,
      method_get_obj_type,
      method_is_readonly,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    readonly: bool,
    obj_type: &JObject<'_>,
    index_type: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let readonly = boolean_to_jvalue!(readonly);
    let obj_type = object_to_jvalue!(obj_type);
    let index_type = object_to_jvalue!(index_type);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[readonly, obj_type, index_type, span],
        "Swc4jAstTsIndexedAccessType construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_index_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_index_type,
        &[],
        "ISwc4jAstTsType get_index_type()"
      )?;
    Ok(return_value)
  }

  pub fn get_obj_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_obj_type,
        &[],
        "ISwc4jAstTsType get_obj_type()"
      )?;
    Ok(return_value)
  }

  pub fn is_readonly<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_readonly,
        &[],
        "boolean is_readonly()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsInferType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_type_param: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsInferType {}
unsafe impl Sync for JavaSwc4jAstTsInferType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsInferType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsInferType")
      .expect("Couldn't find class Swc4jAstTsInferType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsInferType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParam;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsInferType::new");
    let method_get_type_param = env
      .get_method_id(
        &class,
        "getTypeParam",
        "()Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParam;",
      )
      .expect("Couldn't find method Swc4jAstTsInferType.getTypeParam");
    JavaSwc4jAstTsInferType {
      class,
      method_construct,
      method_get_type_param,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    type_param: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let type_param = object_to_jvalue!(type_param);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[type_param, span],
        "Swc4jAstTsInferType construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_param<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_param,
        &[],
        "Swc4jAstTsTypeParam get_type_param()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsInstantiation {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
  method_get_type_args: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsInstantiation {}
unsafe impl Sync for JavaSwc4jAstTsInstantiation {}

#[allow(dead_code)]
impl JavaSwc4jAstTsInstantiation {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstTsInstantiation")
      .expect("Couldn't find class Swc4jAstTsInstantiation");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsInstantiation");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsInstantiation::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsInstantiation.getExpr");
    let method_get_type_args = env
      .get_method_id(
        &class,
        "getTypeArgs",
        "()Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;",
      )
      .expect("Couldn't find method Swc4jAstTsInstantiation.getTypeArgs");
    JavaSwc4jAstTsInstantiation {
      class,
      method_construct,
      method_get_expr,
      method_get_type_args,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    type_args: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let type_args = object_to_jvalue!(type_args);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, type_args, span],
        "Swc4jAstTsInstantiation construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_args,
        &[],
        "Swc4jAstTsTypeParamInstantiation get_type_args()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsInterfaceBody {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsInterfaceBody {}
unsafe impl Sync for JavaSwc4jAstTsInterfaceBody {}

#[allow(dead_code)]
impl JavaSwc4jAstTsInterfaceBody {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsInterfaceBody")
      .expect("Couldn't find class Swc4jAstTsInterfaceBody");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsInterfaceBody");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsInterfaceBody::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsInterfaceBody.getBody");
    JavaSwc4jAstTsInterfaceBody {
      class,
      method_construct,
      method_get_body,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[body, span],
        "Swc4jAstTsInterfaceBody construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "List get_body()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsInterfaceDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_extends: JMethodID,
  method_get_id: JMethodID,
  method_get_type_params: JMethodID,
  method_is_declare: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsInterfaceDecl {}
unsafe impl Sync for JavaSwc4jAstTsInterfaceDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsInterfaceDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstTsInterfaceDecl")
      .expect("Couldn't find class Swc4jAstTsInterfaceDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsInterfaceDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;ZLcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsInterfaceBody;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsInterfaceDecl::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsInterfaceBody;",
      )
      .expect("Couldn't find method Swc4jAstTsInterfaceDecl.getBody");
    let method_get_extends = env
      .get_method_id(
        &class,
        "getExtends",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsInterfaceDecl.getExtends");
    let method_get_id = env
      .get_method_id(
        &class,
        "getId",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstTsInterfaceDecl.getId");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsInterfaceDecl.getTypeParams");
    let method_is_declare = env
      .get_method_id(
        &class,
        "isDeclare",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsInterfaceDecl.isDeclare");
    JavaSwc4jAstTsInterfaceDecl {
      class,
      method_construct,
      method_get_body,
      method_get_extends,
      method_get_id,
      method_get_type_params,
      method_is_declare,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    id: &JObject<'_>,
    declare: bool,
    type_params: &Option<JObject>,
    extends: &JObject<'_>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let id = object_to_jvalue!(id);
    let declare = boolean_to_jvalue!(declare);
    let type_params = optional_object_to_jvalue!(type_params);
    let extends = object_to_jvalue!(extends);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[id, declare, type_params, extends, body, span],
        "Swc4jAstTsInterfaceDecl construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "Swc4jAstTsInterfaceBody get_body()"
      )?;
    Ok(return_value)
  }

  pub fn get_extends<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_extends,
        &[],
        "List get_extends()"
      )?;
    Ok(return_value)
  }

  pub fn get_id<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_id,
        &[],
        "Swc4jAstIdent get_id()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      )?;
    Ok(return_value)
  }

  pub fn is_declare<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_declare,
        &[],
        "boolean is_declare()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsIntersectionType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_types: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsIntersectionType {}
unsafe impl Sync for JavaSwc4jAstTsIntersectionType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsIntersectionType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsIntersectionType")
      .expect("Couldn't find class Swc4jAstTsIntersectionType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsIntersectionType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsIntersectionType::new");
    let method_get_types = env
      .get_method_id(
        &class,
        "getTypes",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsIntersectionType.getTypes");
    JavaSwc4jAstTsIntersectionType {
      class,
      method_construct,
      method_get_types,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    types: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let types = object_to_jvalue!(types);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[types, span],
        "Swc4jAstTsIntersectionType construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_types<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_types,
        &[],
        "List get_types()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsKeywordType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_kind: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsKeywordType {}
unsafe impl Sync for JavaSwc4jAstTsKeywordType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsKeywordType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsKeywordType")
      .expect("Couldn't find class Swc4jAstTsKeywordType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsKeywordType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstTsKeywordTypeKind;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsKeywordType::new");
    let method_get_kind = env
      .get_method_id(
        &class,
        "getKind",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstTsKeywordTypeKind;",
      )
      .expect("Couldn't find method Swc4jAstTsKeywordType.getKind");
    JavaSwc4jAstTsKeywordType {
      class,
      method_construct,
      method_get_kind,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    kind: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let kind = object_to_jvalue!(kind);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[kind, span],
        "Swc4jAstTsKeywordType construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_kind<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_kind,
        &[],
        "Swc4jAstTsKeywordTypeKind get_kind()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsLitType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_lit: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsLitType {}
unsafe impl Sync for JavaSwc4jAstTsLitType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsLitType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsLitType")
      .expect("Couldn't find class Swc4jAstTsLitType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsLitType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsLit;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsLitType::new");
    let method_get_lit = env
      .get_method_id(
        &class,
        "getLit",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsLit;",
      )
      .expect("Couldn't find method Swc4jAstTsLitType.getLit");
    JavaSwc4jAstTsLitType {
      class,
      method_construct,
      method_get_lit,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    lit: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let lit = object_to_jvalue!(lit);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[lit, span],
        "Swc4jAstTsLitType construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_lit<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_lit,
        &[],
        "ISwc4jAstTsLit get_lit()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsMappedType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_name_type: JMethodID,
  method_get_optional: JMethodID,
  method_get_readonly: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_type_param: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsMappedType {}
unsafe impl Sync for JavaSwc4jAstTsMappedType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsMappedType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsMappedType")
      .expect("Couldn't find class Swc4jAstTsMappedType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsMappedType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstTruePlusMinus;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParam;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstTruePlusMinus;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsMappedType::new");
    let method_get_name_type = env
      .get_method_id(
        &class,
        "getNameType",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsMappedType.getNameType");
    let method_get_optional = env
      .get_method_id(
        &class,
        "getOptional",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsMappedType.getOptional");
    let method_get_readonly = env
      .get_method_id(
        &class,
        "getReadonly",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsMappedType.getReadonly");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsMappedType.getTypeAnn");
    let method_get_type_param = env
      .get_method_id(
        &class,
        "getTypeParam",
        "()Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParam;",
      )
      .expect("Couldn't find method Swc4jAstTsMappedType.getTypeParam");
    JavaSwc4jAstTsMappedType {
      class,
      method_construct,
      method_get_name_type,
      method_get_optional,
      method_get_readonly,
      method_get_type_ann,
      method_get_type_param,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    readonly: &Option<JObject>,
    type_param: &JObject<'_>,
    name_type: &Option<JObject>,
    optional: &Option<JObject>,
    type_ann: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let readonly = optional_object_to_jvalue!(readonly);
    let type_param = object_to_jvalue!(type_param);
    let name_type = optional_object_to_jvalue!(name_type);
    let optional = optional_object_to_jvalue!(optional);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[readonly, type_param, name_type, optional, type_ann, span],
        "Swc4jAstTsMappedType construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_name_type<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_name_type,
        &[],
        "Optional get_name_type()"
      )?;
    Ok(return_value)
  }

  pub fn get_optional<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_optional,
        &[],
        "Optional get_optional()"
      )?;
    Ok(return_value)
  }

  pub fn get_readonly<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_readonly,
        &[],
        "Optional get_readonly()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_param<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_param,
        &[],
        "Swc4jAstTsTypeParam get_type_param()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsMethodSignature {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_key: JMethodID,
  method_get_params: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_type_params: JMethodID,
  method_is_computed: JMethodID,
  method_is_optional: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsMethodSignature {}
unsafe impl Sync for JavaSwc4jAstTsMethodSignature {}

#[allow(dead_code)]
impl JavaSwc4jAstTsMethodSignature {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsMethodSignature")
      .expect("Couldn't find class Swc4jAstTsMethodSignature");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsMethodSignature");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;ZZLjava/util/List;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsMethodSignature::new");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsMethodSignature.getKey");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsMethodSignature.getParams");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsMethodSignature.getTypeAnn");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsMethodSignature.getTypeParams");
    let method_is_computed = env
      .get_method_id(
        &class,
        "isComputed",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsMethodSignature.isComputed");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsMethodSignature.isOptional");
    JavaSwc4jAstTsMethodSignature {
      class,
      method_construct,
      method_get_key,
      method_get_params,
      method_get_type_ann,
      method_get_type_params,
      method_is_computed,
      method_is_optional,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    computed: bool,
    optional: bool,
    params: &JObject<'_>,
    type_ann: &Option<JObject>,
    type_params: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let computed = boolean_to_jvalue!(computed);
    let optional = boolean_to_jvalue!(optional);
    let params = object_to_jvalue!(params);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let type_params = optional_object_to_jvalue!(type_params);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, computed, optional, params, type_ann, type_params, span],
        "Swc4jAstTsMethodSignature construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstExpr get_key()"
      )?;
    Ok(return_value)
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      )?;
    Ok(return_value)
  }

  pub fn is_computed<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_computed,
        &[],
        "boolean is_computed()"
      )?;
    Ok(return_value)
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsModuleBlock {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsModuleBlock {}
unsafe impl Sync for JavaSwc4jAstTsModuleBlock {}

#[allow(dead_code)]
impl JavaSwc4jAstTsModuleBlock {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstTsModuleBlock")
      .expect("Couldn't find class Swc4jAstTsModuleBlock");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsModuleBlock");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsModuleBlock::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsModuleBlock.getBody");
    JavaSwc4jAstTsModuleBlock {
      class,
      method_construct,
      method_get_body,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[body, span],
        "Swc4jAstTsModuleBlock construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "List get_body()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsModuleDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_id: JMethodID,
  method_is_declare: JMethodID,
  method_is_global: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsModuleDecl {}
unsafe impl Sync for JavaSwc4jAstTsModuleDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsModuleDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstTsModuleDecl")
      .expect("Couldn't find class Swc4jAstTsModuleDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsModuleDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsModuleName;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsNamespaceBody;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsModuleDecl::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsModuleDecl.getBody");
    let method_get_id = env
      .get_method_id(
        &class,
        "getId",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsModuleName;",
      )
      .expect("Couldn't find method Swc4jAstTsModuleDecl.getId");
    let method_is_declare = env
      .get_method_id(
        &class,
        "isDeclare",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsModuleDecl.isDeclare");
    let method_is_global = env
      .get_method_id(
        &class,
        "isGlobal",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsModuleDecl.isGlobal");
    JavaSwc4jAstTsModuleDecl {
      class,
      method_construct,
      method_get_body,
      method_get_id,
      method_is_declare,
      method_is_global,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    declare: bool,
    global: bool,
    id: &JObject<'_>,
    body: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let declare = boolean_to_jvalue!(declare);
    let global = boolean_to_jvalue!(global);
    let id = object_to_jvalue!(id);
    let body = optional_object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[declare, global, id, body, span],
        "Swc4jAstTsModuleDecl construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "Optional get_body()"
      )?;
    Ok(return_value)
  }

  pub fn get_id<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_id,
        &[],
        "ISwc4jAstTsModuleName get_id()"
      )?;
    Ok(return_value)
  }

  pub fn is_declare<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_declare,
        &[],
        "boolean is_declare()"
      )?;
    Ok(return_value)
  }

  pub fn is_global<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_global,
        &[],
        "boolean is_global()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsNamespaceDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_id: JMethodID,
  method_is_declare: JMethodID,
  method_is_global: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsNamespaceDecl {}
unsafe impl Sync for JavaSwc4jAstTsNamespaceDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsNamespaceDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstTsNamespaceDecl")
      .expect("Couldn't find class Swc4jAstTsNamespaceDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsNamespaceDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZZLcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsNamespaceBody;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsNamespaceDecl::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsNamespaceBody;",
      )
      .expect("Couldn't find method Swc4jAstTsNamespaceDecl.getBody");
    let method_get_id = env
      .get_method_id(
        &class,
        "getId",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstTsNamespaceDecl.getId");
    let method_is_declare = env
      .get_method_id(
        &class,
        "isDeclare",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsNamespaceDecl.isDeclare");
    let method_is_global = env
      .get_method_id(
        &class,
        "isGlobal",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsNamespaceDecl.isGlobal");
    JavaSwc4jAstTsNamespaceDecl {
      class,
      method_construct,
      method_get_body,
      method_get_id,
      method_is_declare,
      method_is_global,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    declare: bool,
    global: bool,
    id: &JObject<'_>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let declare = boolean_to_jvalue!(declare);
    let global = boolean_to_jvalue!(global);
    let id = object_to_jvalue!(id);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[declare, global, id, body, span],
        "Swc4jAstTsNamespaceDecl construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "ISwc4jAstTsNamespaceBody get_body()"
      )?;
    Ok(return_value)
  }

  pub fn get_id<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_id,
        &[],
        "Swc4jAstIdent get_id()"
      )?;
    Ok(return_value)
  }

  pub fn is_declare<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_declare,
        &[],
        "boolean is_declare()"
      )?;
    Ok(return_value)
  }

  pub fn is_global<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_global,
        &[],
        "boolean is_global()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsNamespaceExportDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_id: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsNamespaceExportDecl {}
unsafe impl Sync for JavaSwc4jAstTsNamespaceExportDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsNamespaceExportDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/module/Swc4jAstTsNamespaceExportDecl")
      .expect("Couldn't find class Swc4jAstTsNamespaceExportDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsNamespaceExportDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsNamespaceExportDecl::new");
    let method_get_id = env
      .get_method_id(
        &class,
        "getId",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstTsNamespaceExportDecl.getId");
    JavaSwc4jAstTsNamespaceExportDecl {
      class,
      method_construct,
      method_get_id,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    id: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let id = object_to_jvalue!(id);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[id, span],
        "Swc4jAstTsNamespaceExportDecl construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_id<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_id,
        &[],
        "Swc4jAstIdent get_id()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsNonNullExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsNonNullExpr {}
unsafe impl Sync for JavaSwc4jAstTsNonNullExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstTsNonNullExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstTsNonNullExpr")
      .expect("Couldn't find class Swc4jAstTsNonNullExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsNonNullExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsNonNullExpr::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsNonNullExpr.getExpr");
    JavaSwc4jAstTsNonNullExpr {
      class,
      method_construct,
      method_get_expr,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, span],
        "Swc4jAstTsNonNullExpr construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsOptionalType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsOptionalType {}
unsafe impl Sync for JavaSwc4jAstTsOptionalType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsOptionalType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsOptionalType")
      .expect("Couldn't find class Swc4jAstTsOptionalType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsOptionalType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsOptionalType::new");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsOptionalType.getTypeAnn");
    JavaSwc4jAstTsOptionalType {
      class,
      method_construct,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[type_ann, span],
        "Swc4jAstTsOptionalType construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "ISwc4jAstTsType get_type_ann()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsParamProp {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_accessibility: JMethodID,
  method_get_decorators: JMethodID,
  method_get_param: JMethodID,
  method_is_override: JMethodID,
  method_is_readonly: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsParamProp {}
unsafe impl Sync for JavaSwc4jAstTsParamProp {}

#[allow(dead_code)]
impl JavaSwc4jAstTsParamProp {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsParamProp")
      .expect("Couldn't find class Swc4jAstTsParamProp");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsParamProp");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstAccessibility;ZZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsParamPropParam;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsParamProp::new");
    let method_get_accessibility = env
      .get_method_id(
        &class,
        "getAccessibility",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsParamProp.getAccessibility");
    let method_get_decorators = env
      .get_method_id(
        &class,
        "getDecorators",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsParamProp.getDecorators");
    let method_get_param = env
      .get_method_id(
        &class,
        "getParam",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsParamPropParam;",
      )
      .expect("Couldn't find method Swc4jAstTsParamProp.getParam");
    let method_is_override = env
      .get_method_id(
        &class,
        "isOverride",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsParamProp.isOverride");
    let method_is_readonly = env
      .get_method_id(
        &class,
        "isReadonly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsParamProp.isReadonly");
    JavaSwc4jAstTsParamProp {
      class,
      method_construct,
      method_get_accessibility,
      method_get_decorators,
      method_get_param,
      method_is_override,
      method_is_readonly,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    decorators: &JObject<'_>,
    accessibility: &Option<JObject>,
    is_override: bool,
    readonly: bool,
    param: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let decorators = object_to_jvalue!(decorators);
    let accessibility = optional_object_to_jvalue!(accessibility);
    let is_override = boolean_to_jvalue!(is_override);
    let readonly = boolean_to_jvalue!(readonly);
    let param = object_to_jvalue!(param);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[decorators, accessibility, is_override, readonly, param, span],
        "Swc4jAstTsParamProp construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_accessibility<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_accessibility,
        &[],
        "Optional get_accessibility()"
      )?;
    Ok(return_value)
  }

  pub fn get_decorators<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decorators,
        &[],
        "List get_decorators()"
      )?;
    Ok(return_value)
  }

  pub fn get_param<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_param,
        &[],
        "ISwc4jAstTsParamPropParam get_param()"
      )?;
    Ok(return_value)
  }

  pub fn is_override<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_override,
        &[],
        "boolean is_override()"
      )?;
    Ok(return_value)
  }

  pub fn is_readonly<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_readonly,
        &[],
        "boolean is_readonly()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsParenthesizedType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsParenthesizedType {}
unsafe impl Sync for JavaSwc4jAstTsParenthesizedType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsParenthesizedType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsParenthesizedType")
      .expect("Couldn't find class Swc4jAstTsParenthesizedType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsParenthesizedType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsParenthesizedType::new");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsParenthesizedType.getTypeAnn");
    JavaSwc4jAstTsParenthesizedType {
      class,
      method_construct,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[type_ann, span],
        "Swc4jAstTsParenthesizedType construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "ISwc4jAstTsType get_type_ann()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsPropertySignature {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_key: JMethodID,
  method_get_type_ann: JMethodID,
  method_is_computed: JMethodID,
  method_is_optional: JMethodID,
  method_is_readonly: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsPropertySignature {}
unsafe impl Sync for JavaSwc4jAstTsPropertySignature {}

#[allow(dead_code)]
impl JavaSwc4jAstTsPropertySignature {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsPropertySignature")
      .expect("Couldn't find class Swc4jAstTsPropertySignature");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsPropertySignature");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;ZZLcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsPropertySignature::new");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsPropertySignature.getKey");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsPropertySignature.getTypeAnn");
    let method_is_computed = env
      .get_method_id(
        &class,
        "isComputed",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsPropertySignature.isComputed");
    let method_is_optional = env
      .get_method_id(
        &class,
        "isOptional",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsPropertySignature.isOptional");
    let method_is_readonly = env
      .get_method_id(
        &class,
        "isReadonly",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsPropertySignature.isReadonly");
    JavaSwc4jAstTsPropertySignature {
      class,
      method_construct,
      method_get_key,
      method_get_type_ann,
      method_is_computed,
      method_is_optional,
      method_is_readonly,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    readonly: bool,
    key: &JObject<'_>,
    computed: bool,
    optional: bool,
    type_ann: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let readonly = boolean_to_jvalue!(readonly);
    let key = object_to_jvalue!(key);
    let computed = boolean_to_jvalue!(computed);
    let optional = boolean_to_jvalue!(optional);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[readonly, key, computed, optional, type_ann, span],
        "Swc4jAstTsPropertySignature construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstExpr get_key()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      )?;
    Ok(return_value)
  }

  pub fn is_computed<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_computed,
        &[],
        "boolean is_computed()"
      )?;
    Ok(return_value)
  }

  pub fn is_optional<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_optional,
        &[],
        "boolean is_optional()"
      )?;
    Ok(return_value)
  }

  pub fn is_readonly<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_readonly,
        &[],
        "boolean is_readonly()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsQualifiedName {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_left: JMethodID,
  method_get_right: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsQualifiedName {}
unsafe impl Sync for JavaSwc4jAstTsQualifiedName {}

#[allow(dead_code)]
impl JavaSwc4jAstTsQualifiedName {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsQualifiedName")
      .expect("Couldn't find class Swc4jAstTsQualifiedName");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsQualifiedName");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsEntityName;Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdentName;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsQualifiedName::new");
    let method_get_left = env
      .get_method_id(
        &class,
        "getLeft",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsEntityName;",
      )
      .expect("Couldn't find method Swc4jAstTsQualifiedName.getLeft");
    let method_get_right = env
      .get_method_id(
        &class,
        "getRight",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdentName;",
      )
      .expect("Couldn't find method Swc4jAstTsQualifiedName.getRight");
    JavaSwc4jAstTsQualifiedName {
      class,
      method_construct,
      method_get_left,
      method_get_right,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    left: &JObject<'_>,
    right: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let left = object_to_jvalue!(left);
    let right = object_to_jvalue!(right);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[left, right, span],
        "Swc4jAstTsQualifiedName construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_left<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_left,
        &[],
        "ISwc4jAstTsEntityName get_left()"
      )?;
    Ok(return_value)
  }

  pub fn get_right<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_right,
        &[],
        "Swc4jAstIdentName get_right()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsRestType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsRestType {}
unsafe impl Sync for JavaSwc4jAstTsRestType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsRestType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsRestType")
      .expect("Couldn't find class Swc4jAstTsRestType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsRestType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsRestType::new");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsRestType.getTypeAnn");
    JavaSwc4jAstTsRestType {
      class,
      method_construct,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[type_ann, span],
        "Swc4jAstTsRestType construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "ISwc4jAstTsType get_type_ann()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsSatisfiesExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsSatisfiesExpr {}
unsafe impl Sync for JavaSwc4jAstTsSatisfiesExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstTsSatisfiesExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstTsSatisfiesExpr")
      .expect("Couldn't find class Swc4jAstTsSatisfiesExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsSatisfiesExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsSatisfiesExpr::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsSatisfiesExpr.getExpr");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsSatisfiesExpr.getTypeAnn");
    JavaSwc4jAstTsSatisfiesExpr {
      class,
      method_construct,
      method_get_expr,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, type_ann, span],
        "Swc4jAstTsSatisfiesExpr construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "ISwc4jAstTsType get_type_ann()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsSetterSignature {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_key: JMethodID,
  method_get_param: JMethodID,
  method_is_computed: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsSetterSignature {}
unsafe impl Sync for JavaSwc4jAstTsSetterSignature {}

#[allow(dead_code)]
impl JavaSwc4jAstTsSetterSignature {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsSetterSignature")
      .expect("Couldn't find class Swc4jAstTsSetterSignature");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsSetterSignature");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;ZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsFnParam;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsSetterSignature::new");
    let method_get_key = env
      .get_method_id(
        &class,
        "getKey",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsSetterSignature.getKey");
    let method_get_param = env
      .get_method_id(
        &class,
        "getParam",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsFnParam;",
      )
      .expect("Couldn't find method Swc4jAstTsSetterSignature.getParam");
    let method_is_computed = env
      .get_method_id(
        &class,
        "isComputed",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsSetterSignature.isComputed");
    JavaSwc4jAstTsSetterSignature {
      class,
      method_construct,
      method_get_key,
      method_get_param,
      method_is_computed,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    key: &JObject<'_>,
    computed: bool,
    param: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let key = object_to_jvalue!(key);
    let computed = boolean_to_jvalue!(computed);
    let param = object_to_jvalue!(param);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[key, computed, param, span],
        "Swc4jAstTsSetterSignature construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_key<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_key,
        &[],
        "ISwc4jAstExpr get_key()"
      )?;
    Ok(return_value)
  }

  pub fn get_param<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_param,
        &[],
        "ISwc4jAstTsFnParam get_param()"
      )?;
    Ok(return_value)
  }

  pub fn is_computed<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_computed,
        &[],
        "boolean is_computed()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsThisType {
  class: GlobalRef,
  method_construct: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsThisType {}
unsafe impl Sync for JavaSwc4jAstTsThisType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsThisType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsThisType")
      .expect("Couldn't find class Swc4jAstTsThisType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsThisType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsThisType::new");
    JavaSwc4jAstTsThisType {
      class,
      method_construct,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[span],
        "Swc4jAstTsThisType construct()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTplLitType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_quasis: JMethodID,
  method_get_types: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTplLitType {}
unsafe impl Sync for JavaSwc4jAstTsTplLitType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTplLitType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTplLitType")
      .expect("Couldn't find class Swc4jAstTsTplLitType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTplLitType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTplLitType::new");
    let method_get_quasis = env
      .get_method_id(
        &class,
        "getQuasis",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsTplLitType.getQuasis");
    let method_get_types = env
      .get_method_id(
        &class,
        "getTypes",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsTplLitType.getTypes");
    JavaSwc4jAstTsTplLitType {
      class,
      method_construct,
      method_get_quasis,
      method_get_types,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    types: &JObject<'_>,
    quasis: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let types = object_to_jvalue!(types);
    let quasis = object_to_jvalue!(quasis);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[types, quasis, span],
        "Swc4jAstTsTplLitType construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_quasis<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_quasis,
        &[],
        "List get_quasis()"
      )?;
    Ok(return_value)
  }

  pub fn get_types<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_types,
        &[],
        "List get_types()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTupleElement {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_label: JMethodID,
  method_get_ty: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTupleElement {}
unsafe impl Sync for JavaSwc4jAstTsTupleElement {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTupleElement {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTupleElement")
      .expect("Couldn't find class Swc4jAstTsTupleElement");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTupleElement");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTupleElement::new");
    let method_get_label = env
      .get_method_id(
        &class,
        "getLabel",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsTupleElement.getLabel");
    let method_get_ty = env
      .get_method_id(
        &class,
        "getTy",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsTupleElement.getTy");
    JavaSwc4jAstTsTupleElement {
      class,
      method_construct,
      method_get_label,
      method_get_ty,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    label: &Option<JObject>,
    ty: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let label = optional_object_to_jvalue!(label);
    let ty = object_to_jvalue!(ty);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[label, ty, span],
        "Swc4jAstTsTupleElement construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_label<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_label,
        &[],
        "Optional get_label()"
      )?;
    Ok(return_value)
  }

  pub fn get_ty<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_ty,
        &[],
        "ISwc4jAstTsType get_ty()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTupleType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_elem_types: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTupleType {}
unsafe impl Sync for JavaSwc4jAstTsTupleType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTupleType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTupleType")
      .expect("Couldn't find class Swc4jAstTsTupleType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTupleType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTupleType::new");
    let method_get_elem_types = env
      .get_method_id(
        &class,
        "getElemTypes",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsTupleType.getElemTypes");
    JavaSwc4jAstTsTupleType {
      class,
      method_construct,
      method_get_elem_types,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    elem_types: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let elem_types = object_to_jvalue!(elem_types);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[elem_types, span],
        "Swc4jAstTsTupleType construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_elem_types<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_elem_types,
        &[],
        "List get_elem_types()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeAliasDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_id: JMethodID,
  method_get_type_ann: JMethodID,
  method_get_type_params: JMethodID,
  method_is_declare: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeAliasDecl {}
unsafe impl Sync for JavaSwc4jAstTsTypeAliasDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeAliasDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstTsTypeAliasDecl")
      .expect("Couldn't find class Swc4jAstTsTypeAliasDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeAliasDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;ZLcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAliasDecl::new");
    let method_get_id = env
      .get_method_id(
        &class,
        "getId",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAliasDecl.getId");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAliasDecl.getTypeAnn");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAliasDecl.getTypeParams");
    let method_is_declare = env
      .get_method_id(
        &class,
        "isDeclare",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAliasDecl.isDeclare");
    JavaSwc4jAstTsTypeAliasDecl {
      class,
      method_construct,
      method_get_id,
      method_get_type_ann,
      method_get_type_params,
      method_is_declare,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    id: &JObject<'_>,
    declare: bool,
    type_params: &Option<JObject>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let id = object_to_jvalue!(id);
    let declare = boolean_to_jvalue!(declare);
    let type_params = optional_object_to_jvalue!(type_params);
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[id, declare, type_params, type_ann, span],
        "Swc4jAstTsTypeAliasDecl construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_id<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_id,
        &[],
        "Swc4jAstIdent get_id()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "ISwc4jAstTsType get_type_ann()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      )?;
    Ok(return_value)
  }

  pub fn is_declare<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_declare,
        &[],
        "boolean is_declare()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeAnn {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeAnn {}
unsafe impl Sync for JavaSwc4jAstTsTypeAnn {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeAnn {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn")
      .expect("Couldn't find class Swc4jAstTsTypeAnn");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeAnn");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAnn::new");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAnn.getTypeAnn");
    JavaSwc4jAstTsTypeAnn {
      class,
      method_construct,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[type_ann, span],
        "Swc4jAstTsTypeAnn construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "ISwc4jAstTsType get_type_ann()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeAssertion {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeAssertion {}
unsafe impl Sync for JavaSwc4jAstTsTypeAssertion {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeAssertion {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstTsTypeAssertion")
      .expect("Couldn't find class Swc4jAstTsTypeAssertion");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeAssertion");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAssertion::new");
    let method_get_expr = env
      .get_method_id(
        &class,
        "getExpr",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAssertion.getExpr");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeAssertion.getTypeAnn");
    JavaSwc4jAstTsTypeAssertion {
      class,
      method_construct,
      method_get_expr,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr: &JObject<'_>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let expr = object_to_jvalue!(expr);
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr, type_ann, span],
        "Swc4jAstTsTypeAssertion construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_expr<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr,
        &[],
        "ISwc4jAstExpr get_expr()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "ISwc4jAstTsType get_type_ann()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeLit {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_members: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeLit {}
unsafe impl Sync for JavaSwc4jAstTsTypeLit {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeLit {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeLit")
      .expect("Couldn't find class Swc4jAstTsTypeLit");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeLit");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeLit::new");
    let method_get_members = env
      .get_method_id(
        &class,
        "getMembers",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeLit.getMembers");
    JavaSwc4jAstTsTypeLit {
      class,
      method_construct,
      method_get_members,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    members: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let members = object_to_jvalue!(members);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[members, span],
        "Swc4jAstTsTypeLit construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_members<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_members,
        &[],
        "List get_members()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeOperator {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_op: JMethodID,
  method_get_type_ann: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeOperator {}
unsafe impl Sync for JavaSwc4jAstTsTypeOperator {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeOperator {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeOperator")
      .expect("Couldn't find class Swc4jAstTsTypeOperator");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeOperator");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstTsTypeOperatorOp;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeOperator::new");
    let method_get_op = env
      .get_method_id(
        &class,
        "getOp",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstTsTypeOperatorOp;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeOperator.getOp");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeOperator.getTypeAnn");
    JavaSwc4jAstTsTypeOperator {
      class,
      method_construct,
      method_get_op,
      method_get_type_ann,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    op: &JObject<'_>,
    type_ann: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let op = object_to_jvalue!(op);
    let type_ann = object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[op, type_ann, span],
        "Swc4jAstTsTypeOperator construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_op<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_op,
        &[],
        "Swc4jAstTsTypeOperatorOp get_op()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "ISwc4jAstTsType get_type_ann()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeParam {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_constraint: JMethodID,
  method_get_default: JMethodID,
  method_get_name: JMethodID,
  method_is_const: JMethodID,
  method_is_in: JMethodID,
  method_is_out: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeParam {}
unsafe impl Sync for JavaSwc4jAstTsTypeParam {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeParam {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParam")
      .expect("Couldn't find class Swc4jAstTsTypeParam");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeParam");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;ZZZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsType;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParam::new");
    let method_get_constraint = env
      .get_method_id(
        &class,
        "getConstraint",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParam.getConstraint");
    let method_get_default = env
      .get_method_id(
        &class,
        "getDefault",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParam.getDefault");
    let method_get_name = env
      .get_method_id(
        &class,
        "getName",
        "()Lcom/caoccao/javet/swc4j/ast/expr/Swc4jAstIdent;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParam.getName");
    let method_is_const = env
      .get_method_id(
        &class,
        "isConst",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParam.isConst");
    let method_is_in = env
      .get_method_id(
        &class,
        "isIn",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParam.isIn");
    let method_is_out = env
      .get_method_id(
        &class,
        "isOut",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParam.isOut");
    JavaSwc4jAstTsTypeParam {
      class,
      method_construct,
      method_get_constraint,
      method_get_default,
      method_get_name,
      method_is_const,
      method_is_in,
      method_is_out,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    name: &JObject<'_>,
    is_in: bool,
    is_out: bool,
    is_count: bool,
    constraint: &Option<JObject>,
    default: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let name = object_to_jvalue!(name);
    let is_in = boolean_to_jvalue!(is_in);
    let is_out = boolean_to_jvalue!(is_out);
    let is_count = boolean_to_jvalue!(is_count);
    let constraint = optional_object_to_jvalue!(constraint);
    let default = optional_object_to_jvalue!(default);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[name, is_in, is_out, is_count, constraint, default, span],
        "Swc4jAstTsTypeParam construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_constraint<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_constraint,
        &[],
        "Optional get_constraint()"
      )?;
    Ok(return_value)
  }

  pub fn get_default<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_default,
        &[],
        "Optional get_default()"
      )?;
    Ok(return_value)
  }

  pub fn get_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_name,
        &[],
        "Swc4jAstIdent get_name()"
      )?;
    Ok(return_value)
  }

  pub fn is_const<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_const,
        &[],
        "boolean is_const()"
      )?;
    Ok(return_value)
  }

  pub fn is_in<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_in,
        &[],
        "boolean is_in()"
      )?;
    Ok(return_value)
  }

  pub fn is_out<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_out,
        &[],
        "boolean is_out()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeParamDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_params: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeParamDecl {}
unsafe impl Sync for JavaSwc4jAstTsTypeParamDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeParamDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamDecl")
      .expect("Couldn't find class Swc4jAstTsTypeParamDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeParamDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParamDecl::new");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParamDecl.getParams");
    JavaSwc4jAstTsTypeParamDecl {
      class,
      method_construct,
      method_get_params,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    params: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let params = object_to_jvalue!(params);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[params, span],
        "Swc4jAstTsTypeParamDecl construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeParamInstantiation {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_params: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeParamInstantiation {}
unsafe impl Sync for JavaSwc4jAstTsTypeParamInstantiation {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeParamInstantiation {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation")
      .expect("Couldn't find class Swc4jAstTsTypeParamInstantiation");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeParamInstantiation");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParamInstantiation::new");
    let method_get_params = env
      .get_method_id(
        &class,
        "getParams",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeParamInstantiation.getParams");
    JavaSwc4jAstTsTypeParamInstantiation {
      class,
      method_construct,
      method_get_params,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    params: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let params = object_to_jvalue!(params);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[params, span],
        "Swc4jAstTsTypeParamInstantiation construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_params,
        &[],
        "List get_params()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypePredicate {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_param_name: JMethodID,
  method_get_type_ann: JMethodID,
  method_is_asserts: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypePredicate {}
unsafe impl Sync for JavaSwc4jAstTsTypePredicate {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypePredicate {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypePredicate")
      .expect("Couldn't find class Swc4jAstTsTypePredicate");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypePredicate");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsThisTypeOrIdent;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeAnn;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypePredicate::new");
    let method_get_param_name = env
      .get_method_id(
        &class,
        "getParamName",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsThisTypeOrIdent;",
      )
      .expect("Couldn't find method Swc4jAstTsTypePredicate.getParamName");
    let method_get_type_ann = env
      .get_method_id(
        &class,
        "getTypeAnn",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsTypePredicate.getTypeAnn");
    let method_is_asserts = env
      .get_method_id(
        &class,
        "isAsserts",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstTsTypePredicate.isAsserts");
    JavaSwc4jAstTsTypePredicate {
      class,
      method_construct,
      method_get_param_name,
      method_get_type_ann,
      method_is_asserts,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    asserts: bool,
    param_name: &JObject<'_>,
    type_ann: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let asserts = boolean_to_jvalue!(asserts);
    let param_name = object_to_jvalue!(param_name);
    let type_ann = optional_object_to_jvalue!(type_ann);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[asserts, param_name, type_ann, span],
        "Swc4jAstTsTypePredicate construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_param_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_param_name,
        &[],
        "ISwc4jAstTsThisTypeOrIdent get_param_name()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_ann<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_ann,
        &[],
        "Optional get_type_ann()"
      )?;
    Ok(return_value)
  }

  pub fn is_asserts<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_asserts,
        &[],
        "boolean is_asserts()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeQuery {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_expr_name: JMethodID,
  method_get_type_args: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeQuery {}
unsafe impl Sync for JavaSwc4jAstTsTypeQuery {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeQuery {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeQuery")
      .expect("Couldn't find class Swc4jAstTsTypeQuery");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeQuery");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsTypeQueryExpr;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeQuery::new");
    let method_get_expr_name = env
      .get_method_id(
        &class,
        "getExprName",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsTypeQueryExpr;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeQuery.getExprName");
    let method_get_type_args = env
      .get_method_id(
        &class,
        "getTypeArgs",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeQuery.getTypeArgs");
    JavaSwc4jAstTsTypeQuery {
      class,
      method_construct,
      method_get_expr_name,
      method_get_type_args,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    expr_name: &JObject<'_>,
    type_args: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let expr_name = object_to_jvalue!(expr_name);
    let type_args = optional_object_to_jvalue!(type_args);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[expr_name, type_args, span],
        "Swc4jAstTsTypeQuery construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_expr_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_expr_name,
        &[],
        "ISwc4jAstTsTypeQueryExpr get_expr_name()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_args<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_args,
        &[],
        "Optional get_type_args()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsTypeRef {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_type_name: JMethodID,
  method_get_type_params: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsTypeRef {}
unsafe impl Sync for JavaSwc4jAstTsTypeRef {}

#[allow(dead_code)]
impl JavaSwc4jAstTsTypeRef {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeRef")
      .expect("Couldn't find class Swc4jAstTsTypeRef");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsTypeRef");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsEntityName;Lcom/caoccao/javet/swc4j/ast/ts/Swc4jAstTsTypeParamInstantiation;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsTypeRef::new");
    let method_get_type_name = env
      .get_method_id(
        &class,
        "getTypeName",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstTsEntityName;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeRef.getTypeName");
    let method_get_type_params = env
      .get_method_id(
        &class,
        "getTypeParams",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstTsTypeRef.getTypeParams");
    JavaSwc4jAstTsTypeRef {
      class,
      method_construct,
      method_get_type_name,
      method_get_type_params,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    type_name: &JObject<'_>,
    type_params: &Option<JObject>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let type_name = object_to_jvalue!(type_name);
    let type_params = optional_object_to_jvalue!(type_params);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[type_name, type_params, span],
        "Swc4jAstTsTypeRef construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_name,
        &[],
        "ISwc4jAstTsEntityName get_type_name()"
      )?;
    Ok(return_value)
  }

  pub fn get_type_params<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_type_params,
        &[],
        "Optional get_type_params()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstTsUnionType {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_types: JMethodID,
}
unsafe impl Send for JavaSwc4jAstTsUnionType {}
unsafe impl Sync for JavaSwc4jAstTsUnionType {}

#[allow(dead_code)]
impl JavaSwc4jAstTsUnionType {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsUnionType")
      .expect("Couldn't find class Swc4jAstTsUnionType");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstTsUnionType");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Ljava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstTsUnionType::new");
    let method_get_types = env
      .get_method_id(
        &class,
        "getTypes",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstTsUnionType.getTypes");
    JavaSwc4jAstTsUnionType {
      class,
      method_construct,
      method_get_types,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    types: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let types = object_to_jvalue!(types);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[types, span],
        "Swc4jAstTsUnionType construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_types<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_types,
        &[],
        "List get_types()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstUnaryExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_arg: JMethodID,
  method_get_op: JMethodID,
}
unsafe impl Send for JavaSwc4jAstUnaryExpr {}
unsafe impl Sync for JavaSwc4jAstUnaryExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstUnaryExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstUnaryExpr")
      .expect("Couldn't find class Swc4jAstUnaryExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstUnaryExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstUnaryOp;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstUnaryExpr::new");
    let method_get_arg = env
      .get_method_id(
        &class,
        "getArg",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstUnaryExpr.getArg");
    let method_get_op = env
      .get_method_id(
        &class,
        "getOp",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstUnaryOp;",
      )
      .expect("Couldn't find method Swc4jAstUnaryExpr.getOp");
    JavaSwc4jAstUnaryExpr {
      class,
      method_construct,
      method_get_arg,
      method_get_op,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    op: &JObject<'_>,
    arg: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let op = object_to_jvalue!(op);
    let arg = object_to_jvalue!(arg);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[op, arg, span],
        "Swc4jAstUnaryExpr construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_arg<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_arg,
        &[],
        "ISwc4jAstExpr get_arg()"
      )?;
    Ok(return_value)
  }

  pub fn get_op<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_op,
        &[],
        "Swc4jAstUnaryOp get_op()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstUpdateExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_arg: JMethodID,
  method_get_op: JMethodID,
  method_is_prefix: JMethodID,
}
unsafe impl Send for JavaSwc4jAstUpdateExpr {}
unsafe impl Sync for JavaSwc4jAstUpdateExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstUpdateExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstUpdateExpr")
      .expect("Couldn't find class Swc4jAstUpdateExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstUpdateExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstUpdateOp;ZLcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstUpdateExpr::new");
    let method_get_arg = env
      .get_method_id(
        &class,
        "getArg",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstUpdateExpr.getArg");
    let method_get_op = env
      .get_method_id(
        &class,
        "getOp",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstUpdateOp;",
      )
      .expect("Couldn't find method Swc4jAstUpdateExpr.getOp");
    let method_is_prefix = env
      .get_method_id(
        &class,
        "isPrefix",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstUpdateExpr.isPrefix");
    JavaSwc4jAstUpdateExpr {
      class,
      method_construct,
      method_get_arg,
      method_get_op,
      method_is_prefix,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    op: &JObject<'_>,
    prefix: bool,
    arg: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let op = object_to_jvalue!(op);
    let prefix = boolean_to_jvalue!(prefix);
    let arg = object_to_jvalue!(arg);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[op, prefix, arg, span],
        "Swc4jAstUpdateExpr construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_arg<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_arg,
        &[],
        "ISwc4jAstExpr get_arg()"
      )?;
    Ok(return_value)
  }

  pub fn get_op<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_op,
        &[],
        "Swc4jAstUpdateOp get_op()"
      )?;
    Ok(return_value)
  }

  pub fn is_prefix<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_prefix,
        &[],
        "boolean is_prefix()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstUsingDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_decls: JMethodID,
  method_is_await: JMethodID,
}
unsafe impl Send for JavaSwc4jAstUsingDecl {}
unsafe impl Sync for JavaSwc4jAstUsingDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstUsingDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstUsingDecl")
      .expect("Couldn't find class Swc4jAstUsingDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstUsingDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ZLjava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstUsingDecl::new");
    let method_get_decls = env
      .get_method_id(
        &class,
        "getDecls",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstUsingDecl.getDecls");
    let method_is_await = env
      .get_method_id(
        &class,
        "isAwait",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstUsingDecl.isAwait");
    JavaSwc4jAstUsingDecl {
      class,
      method_construct,
      method_get_decls,
      method_is_await,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    is_await: bool,
    decls: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let is_await = boolean_to_jvalue!(is_await);
    let decls = object_to_jvalue!(decls);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[is_await, decls, span],
        "Swc4jAstUsingDecl construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_decls<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decls,
        &[],
        "List get_decls()"
      )?;
    Ok(return_value)
  }

  pub fn is_await<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_await,
        &[],
        "boolean is_await()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstVarDecl {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_ctxt: JMethodID,
  method_get_decls: JMethodID,
  method_get_kind: JMethodID,
  method_is_declare: JMethodID,
}
unsafe impl Send for JavaSwc4jAstVarDecl {}
unsafe impl Sync for JavaSwc4jAstVarDecl {}

#[allow(dead_code)]
impl JavaSwc4jAstVarDecl {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstVarDecl")
      .expect("Couldn't find class Swc4jAstVarDecl");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstVarDecl");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(ILcom/caoccao/javet/swc4j/ast/enums/Swc4jAstVarDeclKind;ZLjava/util/List;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstVarDecl::new");
    let method_get_ctxt = env
      .get_method_id(
        &class,
        "getCtxt",
        "()I",
      )
      .expect("Couldn't find method Swc4jAstVarDecl.getCtxt");
    let method_get_decls = env
      .get_method_id(
        &class,
        "getDecls",
        "()Ljava/util/List;",
      )
      .expect("Couldn't find method Swc4jAstVarDecl.getDecls");
    let method_get_kind = env
      .get_method_id(
        &class,
        "getKind",
        "()Lcom/caoccao/javet/swc4j/ast/enums/Swc4jAstVarDeclKind;",
      )
      .expect("Couldn't find method Swc4jAstVarDecl.getKind");
    let method_is_declare = env
      .get_method_id(
        &class,
        "isDeclare",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstVarDecl.isDeclare");
    JavaSwc4jAstVarDecl {
      class,
      method_construct,
      method_get_ctxt,
      method_get_decls,
      method_get_kind,
      method_is_declare,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    ctxt: SyntaxContext,
    kind: &JObject<'_>,
    declare: bool,
    decls: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let ctxt = ctxt.as_u32() as i32;
    let ctxt = int_to_jvalue!(ctxt);
    let kind = object_to_jvalue!(kind);
    let declare = boolean_to_jvalue!(declare);
    let decls = object_to_jvalue!(decls);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[ctxt, kind, declare, decls, span],
        "Swc4jAstVarDecl construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_ctxt<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<i32>
  {
    let return_value = call_as_int!(
        env,
        obj,
        self.method_get_ctxt,
        &[],
        "int get_ctxt()"
      )?;
    Ok(return_value)
  }

  pub fn get_decls<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_decls,
        &[],
        "List get_decls()"
      )?;
    Ok(return_value)
  }

  pub fn get_kind<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_kind,
        &[],
        "Swc4jAstVarDeclKind get_kind()"
      )?;
    Ok(return_value)
  }

  pub fn is_declare<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_declare,
        &[],
        "boolean is_declare()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstVarDeclarator {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_init: JMethodID,
  method_get_name: JMethodID,
  method_is_definite: JMethodID,
}
unsafe impl Send for JavaSwc4jAstVarDeclarator {}
unsafe impl Sync for JavaSwc4jAstVarDeclarator {}

#[allow(dead_code)]
impl JavaSwc4jAstVarDeclarator {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstVarDeclarator")
      .expect("Couldn't find class Swc4jAstVarDeclarator");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstVarDeclarator");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;ZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstVarDeclarator::new");
    let method_get_init = env
      .get_method_id(
        &class,
        "getInit",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstVarDeclarator.getInit");
    let method_get_name = env
      .get_method_id(
        &class,
        "getName",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstPat;",
      )
      .expect("Couldn't find method Swc4jAstVarDeclarator.getName");
    let method_is_definite = env
      .get_method_id(
        &class,
        "isDefinite",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstVarDeclarator.isDefinite");
    JavaSwc4jAstVarDeclarator {
      class,
      method_construct,
      method_get_init,
      method_get_name,
      method_is_definite,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    name: &JObject<'_>,
    init: &Option<JObject>,
    definite: bool,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let name = object_to_jvalue!(name);
    let init = optional_object_to_jvalue!(init);
    let definite = boolean_to_jvalue!(definite);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[name, init, definite, span],
        "Swc4jAstVarDeclarator construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_init<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_init,
        &[],
        "Optional get_init()"
      )?;
    Ok(return_value)
  }

  pub fn get_name<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_name,
        &[],
        "ISwc4jAstPat get_name()"
      )?;
    Ok(return_value)
  }

  pub fn is_definite<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_definite,
        &[],
        "boolean is_definite()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstWhileStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_test: JMethodID,
}
unsafe impl Send for JavaSwc4jAstWhileStmt {}
unsafe impl Sync for JavaSwc4jAstWhileStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstWhileStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstWhileStmt")
      .expect("Couldn't find class Swc4jAstWhileStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstWhileStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstWhileStmt::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;",
      )
      .expect("Couldn't find method Swc4jAstWhileStmt.getBody");
    let method_get_test = env
      .get_method_id(
        &class,
        "getTest",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstWhileStmt.getTest");
    JavaSwc4jAstWhileStmt {
      class,
      method_construct,
      method_get_body,
      method_get_test,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    test: &JObject<'_>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let test = object_to_jvalue!(test);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[test, body, span],
        "Swc4jAstWhileStmt construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "ISwc4jAstStmt get_body()"
      )?;
    Ok(return_value)
  }

  pub fn get_test<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_test,
        &[],
        "ISwc4jAstExpr get_test()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstWithStmt {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_body: JMethodID,
  method_get_obj: JMethodID,
}
unsafe impl Send for JavaSwc4jAstWithStmt {}
unsafe impl Sync for JavaSwc4jAstWithStmt {}

#[allow(dead_code)]
impl JavaSwc4jAstWithStmt {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/stmt/Swc4jAstWithStmt")
      .expect("Couldn't find class Swc4jAstWithStmt");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstWithStmt");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;Lcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstWithStmt::new");
    let method_get_body = env
      .get_method_id(
        &class,
        "getBody",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstStmt;",
      )
      .expect("Couldn't find method Swc4jAstWithStmt.getBody");
    let method_get_obj = env
      .get_method_id(
        &class,
        "getObj",
        "()Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;",
      )
      .expect("Couldn't find method Swc4jAstWithStmt.getObj");
    JavaSwc4jAstWithStmt {
      class,
      method_construct,
      method_get_body,
      method_get_obj,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
    body: &JObject<'_>,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let obj = object_to_jvalue!(obj);
    let body = object_to_jvalue!(body);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[obj, body, span],
        "Swc4jAstWithStmt construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_body<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_body,
        &[],
        "ISwc4jAstStmt get_body()"
      )?;
    Ok(return_value)
  }

  pub fn get_obj<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_obj,
        &[],
        "ISwc4jAstExpr get_obj()"
      )?;
    Ok(return_value)
  }
}

#[allow(dead_code)]
struct JavaSwc4jAstYieldExpr {
  class: GlobalRef,
  method_construct: JMethodID,
  method_get_arg: JMethodID,
  method_is_delegate: JMethodID,
}
unsafe impl Send for JavaSwc4jAstYieldExpr {}
unsafe impl Sync for JavaSwc4jAstYieldExpr {}

#[allow(dead_code)]
impl JavaSwc4jAstYieldExpr {
  pub fn new<'local>(env: &mut JNIEnv<'local>) -> Self {
    let class = env
      .find_class("com/caoccao/javet/swc4j/ast/expr/Swc4jAstYieldExpr")
      .expect("Couldn't find class Swc4jAstYieldExpr");
    let class = env
      .new_global_ref(class)
      .expect("Couldn't globalize class Swc4jAstYieldExpr");
    let method_construct = env
      .get_method_id(
        &class,
        "<init>",
        "(Lcom/caoccao/javet/swc4j/ast/interfaces/ISwc4jAstExpr;ZLcom/caoccao/javet/swc4j/span/Swc4jSpan;)V",
      )
      .expect("Couldn't find method Swc4jAstYieldExpr::new");
    let method_get_arg = env
      .get_method_id(
        &class,
        "getArg",
        "()Ljava/util/Optional;",
      )
      .expect("Couldn't find method Swc4jAstYieldExpr.getArg");
    let method_is_delegate = env
      .get_method_id(
        &class,
        "isDelegate",
        "()Z",
      )
      .expect("Couldn't find method Swc4jAstYieldExpr.isDelegate");
    JavaSwc4jAstYieldExpr {
      class,
      method_construct,
      method_get_arg,
      method_is_delegate,
    }
  }

  pub fn construct<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    arg: &Option<JObject>,
    delegate: bool,
    span: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let arg = optional_object_to_jvalue!(arg);
    let delegate = boolean_to_jvalue!(delegate);
    let span = object_to_jvalue!(span);
    let return_value = call_as_construct!(
        env,
        &self.class,
        self.method_construct,
        &[arg, delegate, span],
        "Swc4jAstYieldExpr construct()"
      )?;
    Ok(return_value)
  }

  pub fn get_arg<'local, 'a>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let return_value = call_as_object!(
        env,
        obj,
        self.method_get_arg,
        &[],
        "Optional get_arg()"
      )?;
    Ok(return_value)
  }

  pub fn is_delegate<'local>(
    &self,
    env: &mut JNIEnv<'local>,
    obj: &JObject<'_>,
  ) -> Result<bool>
  {
    let return_value = call_as_boolean!(
        env,
        obj,
        self.method_is_delegate,
        &[],
        "boolean is_delegate()"
      )?;
    Ok(return_value)
  }
}

static mut JAVA_CLASS_: Option<JavaISwc4jAst> = None;
static mut JAVA_CLASS_ASSIGN_TARGET: Option<JavaISwc4jAstAssignTarget> = None;
static mut JAVA_CLASS_ASSIGN_TARGET_PAT: Option<JavaISwc4jAstAssignTargetPat> = None;
static mut JAVA_CLASS_BLOCK_STMT_OR_EXPR: Option<JavaISwc4jAstBlockStmtOrExpr> = None;
static mut JAVA_CLASS_CALLEE: Option<JavaISwc4jAstCallee> = None;
static mut JAVA_CLASS_CLASS_MEMBER: Option<JavaISwc4jAstClassMember> = None;
static mut JAVA_CLASS_DECL: Option<JavaISwc4jAstDecl> = None;
static mut JAVA_CLASS_DEFAULT_DECL: Option<JavaISwc4jAstDefaultDecl> = None;
static mut JAVA_CLASS_EXPORT_SPECIFIER: Option<JavaISwc4jAstExportSpecifier> = None;
static mut JAVA_CLASS_EXPR: Option<JavaISwc4jAstExpr> = None;
static mut JAVA_CLASS_FOR_HEAD: Option<JavaISwc4jAstForHead> = None;
static mut JAVA_CLASS_IMPORT_SPECIFIER: Option<JavaISwc4jAstImportSpecifier> = None;
static mut JAVA_CLASS_JSX_ATTR_NAME: Option<JavaISwc4jAstJsxAttrName> = None;
static mut JAVA_CLASS_JSX_ATTR_OR_SPREAD: Option<JavaISwc4jAstJsxAttrOrSpread> = None;
static mut JAVA_CLASS_JSX_ATTR_VALUE: Option<JavaISwc4jAstJsxAttrValue> = None;
static mut JAVA_CLASS_JSX_ELEMENT_CHILD: Option<JavaISwc4jAstJsxElementChild> = None;
static mut JAVA_CLASS_JSX_ELEMENT_NAME: Option<JavaISwc4jAstJsxElementName> = None;
static mut JAVA_CLASS_JSX_EXPR: Option<JavaISwc4jAstJsxExpr> = None;
static mut JAVA_CLASS_JSX_OBJECT: Option<JavaISwc4jAstJsxObject> = None;
static mut JAVA_CLASS_KEY: Option<JavaISwc4jAstKey> = None;
static mut JAVA_CLASS_LIT: Option<JavaISwc4jAstLit> = None;
static mut JAVA_CLASS_MEMBER_PROP: Option<JavaISwc4jAstMemberProp> = None;
static mut JAVA_CLASS_MODULE_DECL: Option<JavaISwc4jAstModuleDecl> = None;
static mut JAVA_CLASS_MODULE_EXPORT_NAME: Option<JavaISwc4jAstModuleExportName> = None;
static mut JAVA_CLASS_MODULE_ITEM: Option<JavaISwc4jAstModuleItem> = None;
static mut JAVA_CLASS_OBJECT_PAT_PROP: Option<JavaISwc4jAstObjectPatProp> = None;
static mut JAVA_CLASS_OPT_CHAIN_BASE: Option<JavaISwc4jAstOptChainBase> = None;
static mut JAVA_CLASS_PARAM_OR_TS_PARAM_PROP: Option<JavaISwc4jAstParamOrTsParamProp> = None;
static mut JAVA_CLASS_PAT: Option<JavaISwc4jAstPat> = None;
static mut JAVA_CLASS_PROGRAM: Option<JavaISwc4jAstProgram> = None;
static mut JAVA_CLASS_PROP: Option<JavaISwc4jAstProp> = None;
static mut JAVA_CLASS_PROP_NAME: Option<JavaISwc4jAstPropName> = None;
static mut JAVA_CLASS_PROP_OR_SPREAD: Option<JavaISwc4jAstPropOrSpread> = None;
static mut JAVA_CLASS_SIMPLE_ASSIGN_TARGET: Option<JavaISwc4jAstSimpleAssignTarget> = None;
static mut JAVA_CLASS_STMT: Option<JavaISwc4jAstStmt> = None;
static mut JAVA_CLASS_SUPER_PROP: Option<JavaISwc4jAstSuperProp> = None;
static mut JAVA_CLASS_TS_ENTITY_NAME: Option<JavaISwc4jAstTsEntityName> = None;
static mut JAVA_CLASS_TS_ENUM_MEMBER_ID: Option<JavaISwc4jAstTsEnumMemberId> = None;
static mut JAVA_CLASS_TS_FN_OR_CONSTRUCTOR_TYPE: Option<JavaISwc4jAstTsFnOrConstructorType> = None;
static mut JAVA_CLASS_TS_FN_PARAM: Option<JavaISwc4jAstTsFnParam> = None;
static mut JAVA_CLASS_TS_LIT: Option<JavaISwc4jAstTsLit> = None;
static mut JAVA_CLASS_TS_MODULE_NAME: Option<JavaISwc4jAstTsModuleName> = None;
static mut JAVA_CLASS_TS_MODULE_REF: Option<JavaISwc4jAstTsModuleRef> = None;
static mut JAVA_CLASS_TS_NAMESPACE_BODY: Option<JavaISwc4jAstTsNamespaceBody> = None;
static mut JAVA_CLASS_TS_PARAM_PROP_PARAM: Option<JavaISwc4jAstTsParamPropParam> = None;
static mut JAVA_CLASS_TS_THIS_TYPE_OR_IDENT: Option<JavaISwc4jAstTsThisTypeOrIdent> = None;
static mut JAVA_CLASS_TS_TYPE: Option<JavaISwc4jAstTsType> = None;
static mut JAVA_CLASS_TS_TYPE_ELEMENT: Option<JavaISwc4jAstTsTypeElement> = None;
static mut JAVA_CLASS_TS_TYPE_QUERY_EXPR: Option<JavaISwc4jAstTsTypeQueryExpr> = None;
static mut JAVA_CLASS_TS_UNION_OR_INTERSECTION_TYPE: Option<JavaISwc4jAstTsUnionOrIntersectionType> = None;
static mut JAVA_CLASS_VAR_DECL_OR_EXPR: Option<JavaISwc4jAstVarDeclOrExpr> = None;
static mut JAVA_CLASS_ARRAY_LIT: Option<JavaSwc4jAstArrayLit> = None;
static mut JAVA_CLASS_ARRAY_PAT: Option<JavaSwc4jAstArrayPat> = None;
static mut JAVA_CLASS_ARROW_EXPR: Option<JavaSwc4jAstArrowExpr> = None;
static mut JAVA_CLASS_ASSIGN_EXPR: Option<JavaSwc4jAstAssignExpr> = None;
static mut JAVA_CLASS_ASSIGN_PAT: Option<JavaSwc4jAstAssignPat> = None;
static mut JAVA_CLASS_ASSIGN_PAT_PROP: Option<JavaSwc4jAstAssignPatProp> = None;
static mut JAVA_CLASS_ASSIGN_PROP: Option<JavaSwc4jAstAssignProp> = None;
static mut JAVA_CLASS_AUTO_ACCESSOR: Option<JavaSwc4jAstAutoAccessor> = None;
static mut JAVA_CLASS_AWAIT_EXPR: Option<JavaSwc4jAstAwaitExpr> = None;
static mut JAVA_CLASS_BIG_INT: Option<JavaSwc4jAstBigInt> = None;
static mut JAVA_CLASS_BIN_EXPR: Option<JavaSwc4jAstBinExpr> = None;
static mut JAVA_CLASS_BINDING_IDENT: Option<JavaSwc4jAstBindingIdent> = None;
static mut JAVA_CLASS_BLOCK_STMT: Option<JavaSwc4jAstBlockStmt> = None;
static mut JAVA_CLASS_BOOL: Option<JavaSwc4jAstBool> = None;
static mut JAVA_CLASS_BREAK_STMT: Option<JavaSwc4jAstBreakStmt> = None;
static mut JAVA_CLASS_CALL_EXPR: Option<JavaSwc4jAstCallExpr> = None;
static mut JAVA_CLASS_CATCH_CLAUSE: Option<JavaSwc4jAstCatchClause> = None;
static mut JAVA_CLASS_CLASS: Option<JavaSwc4jAstClass> = None;
static mut JAVA_CLASS_CLASS_DECL: Option<JavaSwc4jAstClassDecl> = None;
static mut JAVA_CLASS_CLASS_EXPR: Option<JavaSwc4jAstClassExpr> = None;
static mut JAVA_CLASS_CLASS_METHOD: Option<JavaSwc4jAstClassMethod> = None;
static mut JAVA_CLASS_CLASS_PROP: Option<JavaSwc4jAstClassProp> = None;
static mut JAVA_CLASS_COMPUTED_PROP_NAME: Option<JavaSwc4jAstComputedPropName> = None;
static mut JAVA_CLASS_COND_EXPR: Option<JavaSwc4jAstCondExpr> = None;
static mut JAVA_CLASS_CONSTRUCTOR: Option<JavaSwc4jAstConstructor> = None;
static mut JAVA_CLASS_CONTINUE_STMT: Option<JavaSwc4jAstContinueStmt> = None;
static mut JAVA_CLASS_DEBUGGER_STMT: Option<JavaSwc4jAstDebuggerStmt> = None;
static mut JAVA_CLASS_DECORATOR: Option<JavaSwc4jAstDecorator> = None;
static mut JAVA_CLASS_DO_WHILE_STMT: Option<JavaSwc4jAstDoWhileStmt> = None;
static mut JAVA_CLASS_EMPTY_STMT: Option<JavaSwc4jAstEmptyStmt> = None;
static mut JAVA_CLASS_EXPORT_ALL: Option<JavaSwc4jAstExportAll> = None;
static mut JAVA_CLASS_EXPORT_DECL: Option<JavaSwc4jAstExportDecl> = None;
static mut JAVA_CLASS_EXPORT_DEFAULT_DECL: Option<JavaSwc4jAstExportDefaultDecl> = None;
static mut JAVA_CLASS_EXPORT_DEFAULT_EXPR: Option<JavaSwc4jAstExportDefaultExpr> = None;
static mut JAVA_CLASS_EXPORT_DEFAULT_SPECIFIER: Option<JavaSwc4jAstExportDefaultSpecifier> = None;
static mut JAVA_CLASS_EXPORT_NAMED_SPECIFIER: Option<JavaSwc4jAstExportNamedSpecifier> = None;
static mut JAVA_CLASS_EXPORT_NAMESPACE_SPECIFIER: Option<JavaSwc4jAstExportNamespaceSpecifier> = None;
static mut JAVA_CLASS_EXPR_OR_SPREAD: Option<JavaSwc4jAstExprOrSpread> = None;
static mut JAVA_CLASS_EXPR_STMT: Option<JavaSwc4jAstExprStmt> = None;
static mut JAVA_CLASS_FN_DECL: Option<JavaSwc4jAstFnDecl> = None;
static mut JAVA_CLASS_FN_EXPR: Option<JavaSwc4jAstFnExpr> = None;
static mut JAVA_CLASS_FOR_IN_STMT: Option<JavaSwc4jAstForInStmt> = None;
static mut JAVA_CLASS_FOR_OF_STMT: Option<JavaSwc4jAstForOfStmt> = None;
static mut JAVA_CLASS_FOR_STMT: Option<JavaSwc4jAstForStmt> = None;
static mut JAVA_CLASS_FUNCTION: Option<JavaSwc4jAstFunction> = None;
static mut JAVA_CLASS_GETTER_PROP: Option<JavaSwc4jAstGetterProp> = None;
static mut JAVA_CLASS_IDENT: Option<JavaSwc4jAstIdent> = None;
static mut JAVA_CLASS_IDENT_NAME: Option<JavaSwc4jAstIdentName> = None;
static mut JAVA_CLASS_IF_STMT: Option<JavaSwc4jAstIfStmt> = None;
static mut JAVA_CLASS_IMPORT: Option<JavaSwc4jAstImport> = None;
static mut JAVA_CLASS_IMPORT_DECL: Option<JavaSwc4jAstImportDecl> = None;
static mut JAVA_CLASS_IMPORT_DEFAULT_SPECIFIER: Option<JavaSwc4jAstImportDefaultSpecifier> = None;
static mut JAVA_CLASS_IMPORT_NAMED_SPECIFIER: Option<JavaSwc4jAstImportNamedSpecifier> = None;
static mut JAVA_CLASS_IMPORT_STAR_AS_SPECIFIER: Option<JavaSwc4jAstImportStarAsSpecifier> = None;
static mut JAVA_CLASS_INVALID: Option<JavaSwc4jAstInvalid> = None;
static mut JAVA_CLASS_JSX_ATTR: Option<JavaSwc4jAstJsxAttr> = None;
static mut JAVA_CLASS_JSX_CLOSING_ELEMENT: Option<JavaSwc4jAstJsxClosingElement> = None;
static mut JAVA_CLASS_JSX_CLOSING_FRAGMENT: Option<JavaSwc4jAstJsxClosingFragment> = None;
static mut JAVA_CLASS_JSX_ELEMENT: Option<JavaSwc4jAstJsxElement> = None;
static mut JAVA_CLASS_JSX_EMPTY_EXPR: Option<JavaSwc4jAstJsxEmptyExpr> = None;
static mut JAVA_CLASS_JSX_EXPR_CONTAINER: Option<JavaSwc4jAstJsxExprContainer> = None;
static mut JAVA_CLASS_JSX_FRAGMENT: Option<JavaSwc4jAstJsxFragment> = None;
static mut JAVA_CLASS_JSX_MEMBER_EXPR: Option<JavaSwc4jAstJsxMemberExpr> = None;
static mut JAVA_CLASS_JSX_NAMESPACED_NAME: Option<JavaSwc4jAstJsxNamespacedName> = None;
static mut JAVA_CLASS_JSX_OPENING_ELEMENT: Option<JavaSwc4jAstJsxOpeningElement> = None;
static mut JAVA_CLASS_JSX_OPENING_FRAGMENT: Option<JavaSwc4jAstJsxOpeningFragment> = None;
static mut JAVA_CLASS_JSX_SPREAD_CHILD: Option<JavaSwc4jAstJsxSpreadChild> = None;
static mut JAVA_CLASS_JSX_TEXT: Option<JavaSwc4jAstJsxText> = None;
static mut JAVA_CLASS_KEY_VALUE_PAT_PROP: Option<JavaSwc4jAstKeyValuePatProp> = None;
static mut JAVA_CLASS_KEY_VALUE_PROP: Option<JavaSwc4jAstKeyValueProp> = None;
static mut JAVA_CLASS_LABELED_STMT: Option<JavaSwc4jAstLabeledStmt> = None;
static mut JAVA_CLASS_MEMBER_EXPR: Option<JavaSwc4jAstMemberExpr> = None;
static mut JAVA_CLASS_META_PROP_EXPR: Option<JavaSwc4jAstMetaPropExpr> = None;
static mut JAVA_CLASS_METHOD_PROP: Option<JavaSwc4jAstMethodProp> = None;
static mut JAVA_CLASS_MODULE: Option<JavaSwc4jAstModule> = None;
static mut JAVA_CLASS_NAMED_EXPORT: Option<JavaSwc4jAstNamedExport> = None;
static mut JAVA_CLASS_NEW_EXPR: Option<JavaSwc4jAstNewExpr> = None;
static mut JAVA_CLASS_NULL: Option<JavaSwc4jAstNull> = None;
static mut JAVA_CLASS_NUMBER: Option<JavaSwc4jAstNumber> = None;
static mut JAVA_CLASS_OBJECT_LIT: Option<JavaSwc4jAstObjectLit> = None;
static mut JAVA_CLASS_OBJECT_PAT: Option<JavaSwc4jAstObjectPat> = None;
static mut JAVA_CLASS_OPT_CALL: Option<JavaSwc4jAstOptCall> = None;
static mut JAVA_CLASS_OPT_CHAIN_EXPR: Option<JavaSwc4jAstOptChainExpr> = None;
static mut JAVA_CLASS_PARAM: Option<JavaSwc4jAstParam> = None;
static mut JAVA_CLASS_PAREN_EXPR: Option<JavaSwc4jAstParenExpr> = None;
static mut JAVA_CLASS_PRIVATE_METHOD: Option<JavaSwc4jAstPrivateMethod> = None;
static mut JAVA_CLASS_PRIVATE_NAME: Option<JavaSwc4jAstPrivateName> = None;
static mut JAVA_CLASS_PRIVATE_PROP: Option<JavaSwc4jAstPrivateProp> = None;
static mut JAVA_CLASS_REGEX: Option<JavaSwc4jAstRegex> = None;
static mut JAVA_CLASS_REST_PAT: Option<JavaSwc4jAstRestPat> = None;
static mut JAVA_CLASS_RETURN_STMT: Option<JavaSwc4jAstReturnStmt> = None;
static mut JAVA_CLASS_SCRIPT: Option<JavaSwc4jAstScript> = None;
static mut JAVA_CLASS_SEQ_EXPR: Option<JavaSwc4jAstSeqExpr> = None;
static mut JAVA_CLASS_SETTER_PROP: Option<JavaSwc4jAstSetterProp> = None;
static mut JAVA_CLASS_SPREAD_ELEMENT: Option<JavaSwc4jAstSpreadElement> = None;
static mut JAVA_CLASS_STATIC_BLOCK: Option<JavaSwc4jAstStaticBlock> = None;
static mut JAVA_CLASS_STR: Option<JavaSwc4jAstStr> = None;
static mut JAVA_CLASS_SUPER: Option<JavaSwc4jAstSuper> = None;
static mut JAVA_CLASS_SUPER_PROP_EXPR: Option<JavaSwc4jAstSuperPropExpr> = None;
static mut JAVA_CLASS_SWITCH_CASE: Option<JavaSwc4jAstSwitchCase> = None;
static mut JAVA_CLASS_SWITCH_STMT: Option<JavaSwc4jAstSwitchStmt> = None;
static mut JAVA_CLASS_TAGGED_TPL: Option<JavaSwc4jAstTaggedTpl> = None;
static mut JAVA_CLASS_THIS_EXPR: Option<JavaSwc4jAstThisExpr> = None;
static mut JAVA_CLASS_THROW_STMT: Option<JavaSwc4jAstThrowStmt> = None;
static mut JAVA_CLASS_TPL: Option<JavaSwc4jAstTpl> = None;
static mut JAVA_CLASS_TPL_ELEMENT: Option<JavaSwc4jAstTplElement> = None;
static mut JAVA_CLASS_TRY_STMT: Option<JavaSwc4jAstTryStmt> = None;
static mut JAVA_CLASS_TS_ARRAY_TYPE: Option<JavaSwc4jAstTsArrayType> = None;
static mut JAVA_CLASS_TS_AS_EXPR: Option<JavaSwc4jAstTsAsExpr> = None;
static mut JAVA_CLASS_TS_CALL_SIGNATURE_DECL: Option<JavaSwc4jAstTsCallSignatureDecl> = None;
static mut JAVA_CLASS_TS_CONDITIONAL_TYPE: Option<JavaSwc4jAstTsConditionalType> = None;
static mut JAVA_CLASS_TS_CONST_ASSERTION: Option<JavaSwc4jAstTsConstAssertion> = None;
static mut JAVA_CLASS_TS_CONSTRUCT_SIGNATURE_DECL: Option<JavaSwc4jAstTsConstructSignatureDecl> = None;
static mut JAVA_CLASS_TS_CONSTRUCTOR_TYPE: Option<JavaSwc4jAstTsConstructorType> = None;
static mut JAVA_CLASS_TS_ENUM_DECL: Option<JavaSwc4jAstTsEnumDecl> = None;
static mut JAVA_CLASS_TS_ENUM_MEMBER: Option<JavaSwc4jAstTsEnumMember> = None;
static mut JAVA_CLASS_TS_EXPORT_ASSIGNMENT: Option<JavaSwc4jAstTsExportAssignment> = None;
static mut JAVA_CLASS_TS_EXPR_WITH_TYPE_ARGS: Option<JavaSwc4jAstTsExprWithTypeArgs> = None;
static mut JAVA_CLASS_TS_EXTERNAL_MODULE_REF: Option<JavaSwc4jAstTsExternalModuleRef> = None;
static mut JAVA_CLASS_TS_FN_TYPE: Option<JavaSwc4jAstTsFnType> = None;
static mut JAVA_CLASS_TS_GETTER_SIGNATURE: Option<JavaSwc4jAstTsGetterSignature> = None;
static mut JAVA_CLASS_TS_IMPORT_EQUALS_DECL: Option<JavaSwc4jAstTsImportEqualsDecl> = None;
static mut JAVA_CLASS_TS_IMPORT_TYPE: Option<JavaSwc4jAstTsImportType> = None;
static mut JAVA_CLASS_TS_INDEX_SIGNATURE: Option<JavaSwc4jAstTsIndexSignature> = None;
static mut JAVA_CLASS_TS_INDEXED_ACCESS_TYPE: Option<JavaSwc4jAstTsIndexedAccessType> = None;
static mut JAVA_CLASS_TS_INFER_TYPE: Option<JavaSwc4jAstTsInferType> = None;
static mut JAVA_CLASS_TS_INSTANTIATION: Option<JavaSwc4jAstTsInstantiation> = None;
static mut JAVA_CLASS_TS_INTERFACE_BODY: Option<JavaSwc4jAstTsInterfaceBody> = None;
static mut JAVA_CLASS_TS_INTERFACE_DECL: Option<JavaSwc4jAstTsInterfaceDecl> = None;
static mut JAVA_CLASS_TS_INTERSECTION_TYPE: Option<JavaSwc4jAstTsIntersectionType> = None;
static mut JAVA_CLASS_TS_KEYWORD_TYPE: Option<JavaSwc4jAstTsKeywordType> = None;
static mut JAVA_CLASS_TS_LIT_TYPE: Option<JavaSwc4jAstTsLitType> = None;
static mut JAVA_CLASS_TS_MAPPED_TYPE: Option<JavaSwc4jAstTsMappedType> = None;
static mut JAVA_CLASS_TS_METHOD_SIGNATURE: Option<JavaSwc4jAstTsMethodSignature> = None;
static mut JAVA_CLASS_TS_MODULE_BLOCK: Option<JavaSwc4jAstTsModuleBlock> = None;
static mut JAVA_CLASS_TS_MODULE_DECL: Option<JavaSwc4jAstTsModuleDecl> = None;
static mut JAVA_CLASS_TS_NAMESPACE_DECL: Option<JavaSwc4jAstTsNamespaceDecl> = None;
static mut JAVA_CLASS_TS_NAMESPACE_EXPORT_DECL: Option<JavaSwc4jAstTsNamespaceExportDecl> = None;
static mut JAVA_CLASS_TS_NON_NULL_EXPR: Option<JavaSwc4jAstTsNonNullExpr> = None;
static mut JAVA_CLASS_TS_OPTIONAL_TYPE: Option<JavaSwc4jAstTsOptionalType> = None;
static mut JAVA_CLASS_TS_PARAM_PROP: Option<JavaSwc4jAstTsParamProp> = None;
static mut JAVA_CLASS_TS_PARENTHESIZED_TYPE: Option<JavaSwc4jAstTsParenthesizedType> = None;
static mut JAVA_CLASS_TS_PROPERTY_SIGNATURE: Option<JavaSwc4jAstTsPropertySignature> = None;
static mut JAVA_CLASS_TS_QUALIFIED_NAME: Option<JavaSwc4jAstTsQualifiedName> = None;
static mut JAVA_CLASS_TS_REST_TYPE: Option<JavaSwc4jAstTsRestType> = None;
static mut JAVA_CLASS_TS_SATISFIES_EXPR: Option<JavaSwc4jAstTsSatisfiesExpr> = None;
static mut JAVA_CLASS_TS_SETTER_SIGNATURE: Option<JavaSwc4jAstTsSetterSignature> = None;
static mut JAVA_CLASS_TS_THIS_TYPE: Option<JavaSwc4jAstTsThisType> = None;
static mut JAVA_CLASS_TS_TPL_LIT_TYPE: Option<JavaSwc4jAstTsTplLitType> = None;
static mut JAVA_CLASS_TS_TUPLE_ELEMENT: Option<JavaSwc4jAstTsTupleElement> = None;
static mut JAVA_CLASS_TS_TUPLE_TYPE: Option<JavaSwc4jAstTsTupleType> = None;
static mut JAVA_CLASS_TS_TYPE_ALIAS_DECL: Option<JavaSwc4jAstTsTypeAliasDecl> = None;
static mut JAVA_CLASS_TS_TYPE_ANN: Option<JavaSwc4jAstTsTypeAnn> = None;
static mut JAVA_CLASS_TS_TYPE_ASSERTION: Option<JavaSwc4jAstTsTypeAssertion> = None;
static mut JAVA_CLASS_TS_TYPE_LIT: Option<JavaSwc4jAstTsTypeLit> = None;
static mut JAVA_CLASS_TS_TYPE_OPERATOR: Option<JavaSwc4jAstTsTypeOperator> = None;
static mut JAVA_CLASS_TS_TYPE_PARAM: Option<JavaSwc4jAstTsTypeParam> = None;
static mut JAVA_CLASS_TS_TYPE_PARAM_DECL: Option<JavaSwc4jAstTsTypeParamDecl> = None;
static mut JAVA_CLASS_TS_TYPE_PARAM_INSTANTIATION: Option<JavaSwc4jAstTsTypeParamInstantiation> = None;
static mut JAVA_CLASS_TS_TYPE_PREDICATE: Option<JavaSwc4jAstTsTypePredicate> = None;
static mut JAVA_CLASS_TS_TYPE_QUERY: Option<JavaSwc4jAstTsTypeQuery> = None;
static mut JAVA_CLASS_TS_TYPE_REF: Option<JavaSwc4jAstTsTypeRef> = None;
static mut JAVA_CLASS_TS_UNION_TYPE: Option<JavaSwc4jAstTsUnionType> = None;
static mut JAVA_CLASS_UNARY_EXPR: Option<JavaSwc4jAstUnaryExpr> = None;
static mut JAVA_CLASS_UPDATE_EXPR: Option<JavaSwc4jAstUpdateExpr> = None;
static mut JAVA_CLASS_USING_DECL: Option<JavaSwc4jAstUsingDecl> = None;
static mut JAVA_CLASS_VAR_DECL: Option<JavaSwc4jAstVarDecl> = None;
static mut JAVA_CLASS_VAR_DECLARATOR: Option<JavaSwc4jAstVarDeclarator> = None;
static mut JAVA_CLASS_WHILE_STMT: Option<JavaSwc4jAstWhileStmt> = None;
static mut JAVA_CLASS_WITH_STMT: Option<JavaSwc4jAstWithStmt> = None;
static mut JAVA_CLASS_YIELD_EXPR: Option<JavaSwc4jAstYieldExpr> = None;

pub fn init<'local>(env: &mut JNIEnv<'local>) {
  log::debug!("init()");
  unsafe {
    JAVA_CLASS_ = Some(JavaISwc4jAst::new(env));
    JAVA_CLASS_ASSIGN_TARGET = Some(JavaISwc4jAstAssignTarget::new(env));
    JAVA_CLASS_ASSIGN_TARGET_PAT = Some(JavaISwc4jAstAssignTargetPat::new(env));
    JAVA_CLASS_BLOCK_STMT_OR_EXPR = Some(JavaISwc4jAstBlockStmtOrExpr::new(env));
    JAVA_CLASS_CALLEE = Some(JavaISwc4jAstCallee::new(env));
    JAVA_CLASS_CLASS_MEMBER = Some(JavaISwc4jAstClassMember::new(env));
    JAVA_CLASS_DECL = Some(JavaISwc4jAstDecl::new(env));
    JAVA_CLASS_DEFAULT_DECL = Some(JavaISwc4jAstDefaultDecl::new(env));
    JAVA_CLASS_EXPORT_SPECIFIER = Some(JavaISwc4jAstExportSpecifier::new(env));
    JAVA_CLASS_EXPR = Some(JavaISwc4jAstExpr::new(env));
    JAVA_CLASS_FOR_HEAD = Some(JavaISwc4jAstForHead::new(env));
    JAVA_CLASS_IMPORT_SPECIFIER = Some(JavaISwc4jAstImportSpecifier::new(env));
    JAVA_CLASS_JSX_ATTR_NAME = Some(JavaISwc4jAstJsxAttrName::new(env));
    JAVA_CLASS_JSX_ATTR_OR_SPREAD = Some(JavaISwc4jAstJsxAttrOrSpread::new(env));
    JAVA_CLASS_JSX_ATTR_VALUE = Some(JavaISwc4jAstJsxAttrValue::new(env));
    JAVA_CLASS_JSX_ELEMENT_CHILD = Some(JavaISwc4jAstJsxElementChild::new(env));
    JAVA_CLASS_JSX_ELEMENT_NAME = Some(JavaISwc4jAstJsxElementName::new(env));
    JAVA_CLASS_JSX_EXPR = Some(JavaISwc4jAstJsxExpr::new(env));
    JAVA_CLASS_JSX_OBJECT = Some(JavaISwc4jAstJsxObject::new(env));
    JAVA_CLASS_KEY = Some(JavaISwc4jAstKey::new(env));
    JAVA_CLASS_LIT = Some(JavaISwc4jAstLit::new(env));
    JAVA_CLASS_MEMBER_PROP = Some(JavaISwc4jAstMemberProp::new(env));
    JAVA_CLASS_MODULE_DECL = Some(JavaISwc4jAstModuleDecl::new(env));
    JAVA_CLASS_MODULE_EXPORT_NAME = Some(JavaISwc4jAstModuleExportName::new(env));
    JAVA_CLASS_MODULE_ITEM = Some(JavaISwc4jAstModuleItem::new(env));
    JAVA_CLASS_OBJECT_PAT_PROP = Some(JavaISwc4jAstObjectPatProp::new(env));
    JAVA_CLASS_OPT_CHAIN_BASE = Some(JavaISwc4jAstOptChainBase::new(env));
    JAVA_CLASS_PARAM_OR_TS_PARAM_PROP = Some(JavaISwc4jAstParamOrTsParamProp::new(env));
    JAVA_CLASS_PAT = Some(JavaISwc4jAstPat::new(env));
    JAVA_CLASS_PROGRAM = Some(JavaISwc4jAstProgram::new(env));
    JAVA_CLASS_PROP = Some(JavaISwc4jAstProp::new(env));
    JAVA_CLASS_PROP_NAME = Some(JavaISwc4jAstPropName::new(env));
    JAVA_CLASS_PROP_OR_SPREAD = Some(JavaISwc4jAstPropOrSpread::new(env));
    JAVA_CLASS_SIMPLE_ASSIGN_TARGET = Some(JavaISwc4jAstSimpleAssignTarget::new(env));
    JAVA_CLASS_STMT = Some(JavaISwc4jAstStmt::new(env));
    JAVA_CLASS_SUPER_PROP = Some(JavaISwc4jAstSuperProp::new(env));
    JAVA_CLASS_TS_ENTITY_NAME = Some(JavaISwc4jAstTsEntityName::new(env));
    JAVA_CLASS_TS_ENUM_MEMBER_ID = Some(JavaISwc4jAstTsEnumMemberId::new(env));
    JAVA_CLASS_TS_FN_OR_CONSTRUCTOR_TYPE = Some(JavaISwc4jAstTsFnOrConstructorType::new(env));
    JAVA_CLASS_TS_FN_PARAM = Some(JavaISwc4jAstTsFnParam::new(env));
    JAVA_CLASS_TS_LIT = Some(JavaISwc4jAstTsLit::new(env));
    JAVA_CLASS_TS_MODULE_NAME = Some(JavaISwc4jAstTsModuleName::new(env));
    JAVA_CLASS_TS_MODULE_REF = Some(JavaISwc4jAstTsModuleRef::new(env));
    JAVA_CLASS_TS_NAMESPACE_BODY = Some(JavaISwc4jAstTsNamespaceBody::new(env));
    JAVA_CLASS_TS_PARAM_PROP_PARAM = Some(JavaISwc4jAstTsParamPropParam::new(env));
    JAVA_CLASS_TS_THIS_TYPE_OR_IDENT = Some(JavaISwc4jAstTsThisTypeOrIdent::new(env));
    JAVA_CLASS_TS_TYPE = Some(JavaISwc4jAstTsType::new(env));
    JAVA_CLASS_TS_TYPE_ELEMENT = Some(JavaISwc4jAstTsTypeElement::new(env));
    JAVA_CLASS_TS_TYPE_QUERY_EXPR = Some(JavaISwc4jAstTsTypeQueryExpr::new(env));
    JAVA_CLASS_TS_UNION_OR_INTERSECTION_TYPE = Some(JavaISwc4jAstTsUnionOrIntersectionType::new(env));
    JAVA_CLASS_VAR_DECL_OR_EXPR = Some(JavaISwc4jAstVarDeclOrExpr::new(env));
    JAVA_CLASS_ARRAY_LIT = Some(JavaSwc4jAstArrayLit::new(env));
    JAVA_CLASS_ARRAY_PAT = Some(JavaSwc4jAstArrayPat::new(env));
    JAVA_CLASS_ARROW_EXPR = Some(JavaSwc4jAstArrowExpr::new(env));
    JAVA_CLASS_ASSIGN_EXPR = Some(JavaSwc4jAstAssignExpr::new(env));
    JAVA_CLASS_ASSIGN_PAT = Some(JavaSwc4jAstAssignPat::new(env));
    JAVA_CLASS_ASSIGN_PAT_PROP = Some(JavaSwc4jAstAssignPatProp::new(env));
    JAVA_CLASS_ASSIGN_PROP = Some(JavaSwc4jAstAssignProp::new(env));
    JAVA_CLASS_AUTO_ACCESSOR = Some(JavaSwc4jAstAutoAccessor::new(env));
    JAVA_CLASS_AWAIT_EXPR = Some(JavaSwc4jAstAwaitExpr::new(env));
    JAVA_CLASS_BIG_INT = Some(JavaSwc4jAstBigInt::new(env));
    JAVA_CLASS_BIN_EXPR = Some(JavaSwc4jAstBinExpr::new(env));
    JAVA_CLASS_BINDING_IDENT = Some(JavaSwc4jAstBindingIdent::new(env));
    JAVA_CLASS_BLOCK_STMT = Some(JavaSwc4jAstBlockStmt::new(env));
    JAVA_CLASS_BOOL = Some(JavaSwc4jAstBool::new(env));
    JAVA_CLASS_BREAK_STMT = Some(JavaSwc4jAstBreakStmt::new(env));
    JAVA_CLASS_CALL_EXPR = Some(JavaSwc4jAstCallExpr::new(env));
    JAVA_CLASS_CATCH_CLAUSE = Some(JavaSwc4jAstCatchClause::new(env));
    JAVA_CLASS_CLASS = Some(JavaSwc4jAstClass::new(env));
    JAVA_CLASS_CLASS_DECL = Some(JavaSwc4jAstClassDecl::new(env));
    JAVA_CLASS_CLASS_EXPR = Some(JavaSwc4jAstClassExpr::new(env));
    JAVA_CLASS_CLASS_METHOD = Some(JavaSwc4jAstClassMethod::new(env));
    JAVA_CLASS_CLASS_PROP = Some(JavaSwc4jAstClassProp::new(env));
    JAVA_CLASS_COMPUTED_PROP_NAME = Some(JavaSwc4jAstComputedPropName::new(env));
    JAVA_CLASS_COND_EXPR = Some(JavaSwc4jAstCondExpr::new(env));
    JAVA_CLASS_CONSTRUCTOR = Some(JavaSwc4jAstConstructor::new(env));
    JAVA_CLASS_CONTINUE_STMT = Some(JavaSwc4jAstContinueStmt::new(env));
    JAVA_CLASS_DEBUGGER_STMT = Some(JavaSwc4jAstDebuggerStmt::new(env));
    JAVA_CLASS_DECORATOR = Some(JavaSwc4jAstDecorator::new(env));
    JAVA_CLASS_DO_WHILE_STMT = Some(JavaSwc4jAstDoWhileStmt::new(env));
    JAVA_CLASS_EMPTY_STMT = Some(JavaSwc4jAstEmptyStmt::new(env));
    JAVA_CLASS_EXPORT_ALL = Some(JavaSwc4jAstExportAll::new(env));
    JAVA_CLASS_EXPORT_DECL = Some(JavaSwc4jAstExportDecl::new(env));
    JAVA_CLASS_EXPORT_DEFAULT_DECL = Some(JavaSwc4jAstExportDefaultDecl::new(env));
    JAVA_CLASS_EXPORT_DEFAULT_EXPR = Some(JavaSwc4jAstExportDefaultExpr::new(env));
    JAVA_CLASS_EXPORT_DEFAULT_SPECIFIER = Some(JavaSwc4jAstExportDefaultSpecifier::new(env));
    JAVA_CLASS_EXPORT_NAMED_SPECIFIER = Some(JavaSwc4jAstExportNamedSpecifier::new(env));
    JAVA_CLASS_EXPORT_NAMESPACE_SPECIFIER = Some(JavaSwc4jAstExportNamespaceSpecifier::new(env));
    JAVA_CLASS_EXPR_OR_SPREAD = Some(JavaSwc4jAstExprOrSpread::new(env));
    JAVA_CLASS_EXPR_STMT = Some(JavaSwc4jAstExprStmt::new(env));
    JAVA_CLASS_FN_DECL = Some(JavaSwc4jAstFnDecl::new(env));
    JAVA_CLASS_FN_EXPR = Some(JavaSwc4jAstFnExpr::new(env));
    JAVA_CLASS_FOR_IN_STMT = Some(JavaSwc4jAstForInStmt::new(env));
    JAVA_CLASS_FOR_OF_STMT = Some(JavaSwc4jAstForOfStmt::new(env));
    JAVA_CLASS_FOR_STMT = Some(JavaSwc4jAstForStmt::new(env));
    JAVA_CLASS_FUNCTION = Some(JavaSwc4jAstFunction::new(env));
    JAVA_CLASS_GETTER_PROP = Some(JavaSwc4jAstGetterProp::new(env));
    JAVA_CLASS_IDENT = Some(JavaSwc4jAstIdent::new(env));
    JAVA_CLASS_IDENT_NAME = Some(JavaSwc4jAstIdentName::new(env));
    JAVA_CLASS_IF_STMT = Some(JavaSwc4jAstIfStmt::new(env));
    JAVA_CLASS_IMPORT = Some(JavaSwc4jAstImport::new(env));
    JAVA_CLASS_IMPORT_DECL = Some(JavaSwc4jAstImportDecl::new(env));
    JAVA_CLASS_IMPORT_DEFAULT_SPECIFIER = Some(JavaSwc4jAstImportDefaultSpecifier::new(env));
    JAVA_CLASS_IMPORT_NAMED_SPECIFIER = Some(JavaSwc4jAstImportNamedSpecifier::new(env));
    JAVA_CLASS_IMPORT_STAR_AS_SPECIFIER = Some(JavaSwc4jAstImportStarAsSpecifier::new(env));
    JAVA_CLASS_INVALID = Some(JavaSwc4jAstInvalid::new(env));
    JAVA_CLASS_JSX_ATTR = Some(JavaSwc4jAstJsxAttr::new(env));
    JAVA_CLASS_JSX_CLOSING_ELEMENT = Some(JavaSwc4jAstJsxClosingElement::new(env));
    JAVA_CLASS_JSX_CLOSING_FRAGMENT = Some(JavaSwc4jAstJsxClosingFragment::new(env));
    JAVA_CLASS_JSX_ELEMENT = Some(JavaSwc4jAstJsxElement::new(env));
    JAVA_CLASS_JSX_EMPTY_EXPR = Some(JavaSwc4jAstJsxEmptyExpr::new(env));
    JAVA_CLASS_JSX_EXPR_CONTAINER = Some(JavaSwc4jAstJsxExprContainer::new(env));
    JAVA_CLASS_JSX_FRAGMENT = Some(JavaSwc4jAstJsxFragment::new(env));
    JAVA_CLASS_JSX_MEMBER_EXPR = Some(JavaSwc4jAstJsxMemberExpr::new(env));
    JAVA_CLASS_JSX_NAMESPACED_NAME = Some(JavaSwc4jAstJsxNamespacedName::new(env));
    JAVA_CLASS_JSX_OPENING_ELEMENT = Some(JavaSwc4jAstJsxOpeningElement::new(env));
    JAVA_CLASS_JSX_OPENING_FRAGMENT = Some(JavaSwc4jAstJsxOpeningFragment::new(env));
    JAVA_CLASS_JSX_SPREAD_CHILD = Some(JavaSwc4jAstJsxSpreadChild::new(env));
    JAVA_CLASS_JSX_TEXT = Some(JavaSwc4jAstJsxText::new(env));
    JAVA_CLASS_KEY_VALUE_PAT_PROP = Some(JavaSwc4jAstKeyValuePatProp::new(env));
    JAVA_CLASS_KEY_VALUE_PROP = Some(JavaSwc4jAstKeyValueProp::new(env));
    JAVA_CLASS_LABELED_STMT = Some(JavaSwc4jAstLabeledStmt::new(env));
    JAVA_CLASS_MEMBER_EXPR = Some(JavaSwc4jAstMemberExpr::new(env));
    JAVA_CLASS_META_PROP_EXPR = Some(JavaSwc4jAstMetaPropExpr::new(env));
    JAVA_CLASS_METHOD_PROP = Some(JavaSwc4jAstMethodProp::new(env));
    JAVA_CLASS_MODULE = Some(JavaSwc4jAstModule::new(env));
    JAVA_CLASS_NAMED_EXPORT = Some(JavaSwc4jAstNamedExport::new(env));
    JAVA_CLASS_NEW_EXPR = Some(JavaSwc4jAstNewExpr::new(env));
    JAVA_CLASS_NULL = Some(JavaSwc4jAstNull::new(env));
    JAVA_CLASS_NUMBER = Some(JavaSwc4jAstNumber::new(env));
    JAVA_CLASS_OBJECT_LIT = Some(JavaSwc4jAstObjectLit::new(env));
    JAVA_CLASS_OBJECT_PAT = Some(JavaSwc4jAstObjectPat::new(env));
    JAVA_CLASS_OPT_CALL = Some(JavaSwc4jAstOptCall::new(env));
    JAVA_CLASS_OPT_CHAIN_EXPR = Some(JavaSwc4jAstOptChainExpr::new(env));
    JAVA_CLASS_PARAM = Some(JavaSwc4jAstParam::new(env));
    JAVA_CLASS_PAREN_EXPR = Some(JavaSwc4jAstParenExpr::new(env));
    JAVA_CLASS_PRIVATE_METHOD = Some(JavaSwc4jAstPrivateMethod::new(env));
    JAVA_CLASS_PRIVATE_NAME = Some(JavaSwc4jAstPrivateName::new(env));
    JAVA_CLASS_PRIVATE_PROP = Some(JavaSwc4jAstPrivateProp::new(env));
    JAVA_CLASS_REGEX = Some(JavaSwc4jAstRegex::new(env));
    JAVA_CLASS_REST_PAT = Some(JavaSwc4jAstRestPat::new(env));
    JAVA_CLASS_RETURN_STMT = Some(JavaSwc4jAstReturnStmt::new(env));
    JAVA_CLASS_SCRIPT = Some(JavaSwc4jAstScript::new(env));
    JAVA_CLASS_SEQ_EXPR = Some(JavaSwc4jAstSeqExpr::new(env));
    JAVA_CLASS_SETTER_PROP = Some(JavaSwc4jAstSetterProp::new(env));
    JAVA_CLASS_SPREAD_ELEMENT = Some(JavaSwc4jAstSpreadElement::new(env));
    JAVA_CLASS_STATIC_BLOCK = Some(JavaSwc4jAstStaticBlock::new(env));
    JAVA_CLASS_STR = Some(JavaSwc4jAstStr::new(env));
    JAVA_CLASS_SUPER = Some(JavaSwc4jAstSuper::new(env));
    JAVA_CLASS_SUPER_PROP_EXPR = Some(JavaSwc4jAstSuperPropExpr::new(env));
    JAVA_CLASS_SWITCH_CASE = Some(JavaSwc4jAstSwitchCase::new(env));
    JAVA_CLASS_SWITCH_STMT = Some(JavaSwc4jAstSwitchStmt::new(env));
    JAVA_CLASS_TAGGED_TPL = Some(JavaSwc4jAstTaggedTpl::new(env));
    JAVA_CLASS_THIS_EXPR = Some(JavaSwc4jAstThisExpr::new(env));
    JAVA_CLASS_THROW_STMT = Some(JavaSwc4jAstThrowStmt::new(env));
    JAVA_CLASS_TPL = Some(JavaSwc4jAstTpl::new(env));
    JAVA_CLASS_TPL_ELEMENT = Some(JavaSwc4jAstTplElement::new(env));
    JAVA_CLASS_TRY_STMT = Some(JavaSwc4jAstTryStmt::new(env));
    JAVA_CLASS_TS_ARRAY_TYPE = Some(JavaSwc4jAstTsArrayType::new(env));
    JAVA_CLASS_TS_AS_EXPR = Some(JavaSwc4jAstTsAsExpr::new(env));
    JAVA_CLASS_TS_CALL_SIGNATURE_DECL = Some(JavaSwc4jAstTsCallSignatureDecl::new(env));
    JAVA_CLASS_TS_CONDITIONAL_TYPE = Some(JavaSwc4jAstTsConditionalType::new(env));
    JAVA_CLASS_TS_CONST_ASSERTION = Some(JavaSwc4jAstTsConstAssertion::new(env));
    JAVA_CLASS_TS_CONSTRUCT_SIGNATURE_DECL = Some(JavaSwc4jAstTsConstructSignatureDecl::new(env));
    JAVA_CLASS_TS_CONSTRUCTOR_TYPE = Some(JavaSwc4jAstTsConstructorType::new(env));
    JAVA_CLASS_TS_ENUM_DECL = Some(JavaSwc4jAstTsEnumDecl::new(env));
    JAVA_CLASS_TS_ENUM_MEMBER = Some(JavaSwc4jAstTsEnumMember::new(env));
    JAVA_CLASS_TS_EXPORT_ASSIGNMENT = Some(JavaSwc4jAstTsExportAssignment::new(env));
    JAVA_CLASS_TS_EXPR_WITH_TYPE_ARGS = Some(JavaSwc4jAstTsExprWithTypeArgs::new(env));
    JAVA_CLASS_TS_EXTERNAL_MODULE_REF = Some(JavaSwc4jAstTsExternalModuleRef::new(env));
    JAVA_CLASS_TS_FN_TYPE = Some(JavaSwc4jAstTsFnType::new(env));
    JAVA_CLASS_TS_GETTER_SIGNATURE = Some(JavaSwc4jAstTsGetterSignature::new(env));
    JAVA_CLASS_TS_IMPORT_EQUALS_DECL = Some(JavaSwc4jAstTsImportEqualsDecl::new(env));
    JAVA_CLASS_TS_IMPORT_TYPE = Some(JavaSwc4jAstTsImportType::new(env));
    JAVA_CLASS_TS_INDEX_SIGNATURE = Some(JavaSwc4jAstTsIndexSignature::new(env));
    JAVA_CLASS_TS_INDEXED_ACCESS_TYPE = Some(JavaSwc4jAstTsIndexedAccessType::new(env));
    JAVA_CLASS_TS_INFER_TYPE = Some(JavaSwc4jAstTsInferType::new(env));
    JAVA_CLASS_TS_INSTANTIATION = Some(JavaSwc4jAstTsInstantiation::new(env));
    JAVA_CLASS_TS_INTERFACE_BODY = Some(JavaSwc4jAstTsInterfaceBody::new(env));
    JAVA_CLASS_TS_INTERFACE_DECL = Some(JavaSwc4jAstTsInterfaceDecl::new(env));
    JAVA_CLASS_TS_INTERSECTION_TYPE = Some(JavaSwc4jAstTsIntersectionType::new(env));
    JAVA_CLASS_TS_KEYWORD_TYPE = Some(JavaSwc4jAstTsKeywordType::new(env));
    JAVA_CLASS_TS_LIT_TYPE = Some(JavaSwc4jAstTsLitType::new(env));
    JAVA_CLASS_TS_MAPPED_TYPE = Some(JavaSwc4jAstTsMappedType::new(env));
    JAVA_CLASS_TS_METHOD_SIGNATURE = Some(JavaSwc4jAstTsMethodSignature::new(env));
    JAVA_CLASS_TS_MODULE_BLOCK = Some(JavaSwc4jAstTsModuleBlock::new(env));
    JAVA_CLASS_TS_MODULE_DECL = Some(JavaSwc4jAstTsModuleDecl::new(env));
    JAVA_CLASS_TS_NAMESPACE_DECL = Some(JavaSwc4jAstTsNamespaceDecl::new(env));
    JAVA_CLASS_TS_NAMESPACE_EXPORT_DECL = Some(JavaSwc4jAstTsNamespaceExportDecl::new(env));
    JAVA_CLASS_TS_NON_NULL_EXPR = Some(JavaSwc4jAstTsNonNullExpr::new(env));
    JAVA_CLASS_TS_OPTIONAL_TYPE = Some(JavaSwc4jAstTsOptionalType::new(env));
    JAVA_CLASS_TS_PARAM_PROP = Some(JavaSwc4jAstTsParamProp::new(env));
    JAVA_CLASS_TS_PARENTHESIZED_TYPE = Some(JavaSwc4jAstTsParenthesizedType::new(env));
    JAVA_CLASS_TS_PROPERTY_SIGNATURE = Some(JavaSwc4jAstTsPropertySignature::new(env));
    JAVA_CLASS_TS_QUALIFIED_NAME = Some(JavaSwc4jAstTsQualifiedName::new(env));
    JAVA_CLASS_TS_REST_TYPE = Some(JavaSwc4jAstTsRestType::new(env));
    JAVA_CLASS_TS_SATISFIES_EXPR = Some(JavaSwc4jAstTsSatisfiesExpr::new(env));
    JAVA_CLASS_TS_SETTER_SIGNATURE = Some(JavaSwc4jAstTsSetterSignature::new(env));
    JAVA_CLASS_TS_THIS_TYPE = Some(JavaSwc4jAstTsThisType::new(env));
    JAVA_CLASS_TS_TPL_LIT_TYPE = Some(JavaSwc4jAstTsTplLitType::new(env));
    JAVA_CLASS_TS_TUPLE_ELEMENT = Some(JavaSwc4jAstTsTupleElement::new(env));
    JAVA_CLASS_TS_TUPLE_TYPE = Some(JavaSwc4jAstTsTupleType::new(env));
    JAVA_CLASS_TS_TYPE_ALIAS_DECL = Some(JavaSwc4jAstTsTypeAliasDecl::new(env));
    JAVA_CLASS_TS_TYPE_ANN = Some(JavaSwc4jAstTsTypeAnn::new(env));
    JAVA_CLASS_TS_TYPE_ASSERTION = Some(JavaSwc4jAstTsTypeAssertion::new(env));
    JAVA_CLASS_TS_TYPE_LIT = Some(JavaSwc4jAstTsTypeLit::new(env));
    JAVA_CLASS_TS_TYPE_OPERATOR = Some(JavaSwc4jAstTsTypeOperator::new(env));
    JAVA_CLASS_TS_TYPE_PARAM = Some(JavaSwc4jAstTsTypeParam::new(env));
    JAVA_CLASS_TS_TYPE_PARAM_DECL = Some(JavaSwc4jAstTsTypeParamDecl::new(env));
    JAVA_CLASS_TS_TYPE_PARAM_INSTANTIATION = Some(JavaSwc4jAstTsTypeParamInstantiation::new(env));
    JAVA_CLASS_TS_TYPE_PREDICATE = Some(JavaSwc4jAstTsTypePredicate::new(env));
    JAVA_CLASS_TS_TYPE_QUERY = Some(JavaSwc4jAstTsTypeQuery::new(env));
    JAVA_CLASS_TS_TYPE_REF = Some(JavaSwc4jAstTsTypeRef::new(env));
    JAVA_CLASS_TS_UNION_TYPE = Some(JavaSwc4jAstTsUnionType::new(env));
    JAVA_CLASS_UNARY_EXPR = Some(JavaSwc4jAstUnaryExpr::new(env));
    JAVA_CLASS_UPDATE_EXPR = Some(JavaSwc4jAstUpdateExpr::new(env));
    JAVA_CLASS_USING_DECL = Some(JavaSwc4jAstUsingDecl::new(env));
    JAVA_CLASS_VAR_DECL = Some(JavaSwc4jAstVarDecl::new(env));
    JAVA_CLASS_VAR_DECLARATOR = Some(JavaSwc4jAstVarDeclarator::new(env));
    JAVA_CLASS_WHILE_STMT = Some(JavaSwc4jAstWhileStmt::new(env));
    JAVA_CLASS_WITH_STMT = Some(JavaSwc4jAstWithStmt::new(env));
    JAVA_CLASS_YIELD_EXPR = Some(JavaSwc4jAstYieldExpr::new(env));
  }
}
/* JNI End */

/* Enum Begin */
impl RegisterWithMap<ByteToIndexMap> for AssignTarget {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      AssignTarget::Pat(node) => node.register_with_map(map),
      AssignTarget::Simple(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for AssignTarget {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      AssignTarget::Pat(node) => node.to_java_with_map(env, map),
      AssignTarget::Simple(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for AssignTarget {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_ASSIGN_TARGET_PAT.as_ref().unwrap()}.class)).unwrap_or(false) {
        AssignTarget::Pat(*AssignTargetPat::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_SIMPLE_ASSIGN_TARGET.as_ref().unwrap()}.class)).unwrap_or(false) {
        AssignTarget::Simple(*SimpleAssignTarget::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by AssignTarget", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for AssignTargetPat {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      AssignTargetPat::Array(node) => node.register_with_map(map),
      AssignTargetPat::Invalid(node) => node.register_with_map(map),
      AssignTargetPat::Object(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for AssignTargetPat {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      AssignTargetPat::Array(node) => node.to_java_with_map(env, map),
      AssignTargetPat::Invalid(node) => node.to_java_with_map(env, map),
      AssignTargetPat::Object(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for AssignTargetPat {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_ARRAY_PAT.as_ref().unwrap()}.class)).unwrap_or(false) {
        AssignTargetPat::Array(*ArrayPat::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_INVALID.as_ref().unwrap()}.class)).unwrap_or(false) {
        AssignTargetPat::Invalid(*Invalid::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_OBJECT_PAT.as_ref().unwrap()}.class)).unwrap_or(false) {
        AssignTargetPat::Object(*ObjectPat::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by AssignTargetPat", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for BlockStmtOrExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      BlockStmtOrExpr::BlockStmt(node) => node.register_with_map(map),
      BlockStmtOrExpr::Expr(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for BlockStmtOrExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      BlockStmtOrExpr::BlockStmt(node) => node.to_java_with_map(env, map),
      BlockStmtOrExpr::Expr(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for BlockStmtOrExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_BLOCK_STMT.as_ref().unwrap()}.class)).unwrap_or(false) {
        BlockStmtOrExpr::BlockStmt(*BlockStmt::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        BlockStmtOrExpr::Expr(Expr::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by BlockStmtOrExpr", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for Callee {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      Callee::Expr(node) => node.register_with_map(map),
      Callee::Import(node) => node.register_with_map(map),
      Callee::Super(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Callee {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      Callee::Expr(node) => node.to_java_with_map(env, map),
      Callee::Import(node) => node.to_java_with_map(env, map),
      Callee::Super(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for Callee {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        Callee::Expr(Expr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_IMPORT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Callee::Import(*Import::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_SUPER.as_ref().unwrap()}.class)).unwrap_or(false) {
        Callee::Super(*Super::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by Callee", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ClassMember {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      ClassMember::AutoAccessor(node) => node.register_with_map(map),
      ClassMember::ClassProp(node) => node.register_with_map(map),
      ClassMember::Constructor(node) => node.register_with_map(map),
      ClassMember::Empty(node) => node.register_with_map(map),
      ClassMember::Method(node) => node.register_with_map(map),
      ClassMember::PrivateMethod(node) => node.register_with_map(map),
      ClassMember::PrivateProp(node) => node.register_with_map(map),
      ClassMember::StaticBlock(node) => node.register_with_map(map),
      ClassMember::TsIndexSignature(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ClassMember {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      ClassMember::AutoAccessor(node) => node.to_java_with_map(env, map),
      ClassMember::ClassProp(node) => node.to_java_with_map(env, map),
      ClassMember::Constructor(node) => node.to_java_with_map(env, map),
      ClassMember::Empty(node) => node.to_java_with_map(env, map),
      ClassMember::Method(node) => node.to_java_with_map(env, map),
      ClassMember::PrivateMethod(node) => node.to_java_with_map(env, map),
      ClassMember::PrivateProp(node) => node.to_java_with_map(env, map),
      ClassMember::StaticBlock(node) => node.to_java_with_map(env, map),
      ClassMember::TsIndexSignature(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for ClassMember {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_AUTO_ACCESSOR.as_ref().unwrap()}.class)).unwrap_or(false) {
        ClassMember::AutoAccessor(*AutoAccessor::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_CLASS_PROP.as_ref().unwrap()}.class)).unwrap_or(false) {
        ClassMember::ClassProp(*ClassProp::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_CONSTRUCTOR.as_ref().unwrap()}.class)).unwrap_or(false) {
        ClassMember::Constructor(*Constructor::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_EMPTY_STMT.as_ref().unwrap()}.class)).unwrap_or(false) {
        ClassMember::Empty(*EmptyStmt::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_CLASS_METHOD.as_ref().unwrap()}.class)).unwrap_or(false) {
        ClassMember::Method(*ClassMethod::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_PRIVATE_METHOD.as_ref().unwrap()}.class)).unwrap_or(false) {
        ClassMember::PrivateMethod(*PrivateMethod::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_PRIVATE_PROP.as_ref().unwrap()}.class)).unwrap_or(false) {
        ClassMember::PrivateProp(*PrivateProp::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_STATIC_BLOCK.as_ref().unwrap()}.class)).unwrap_or(false) {
        ClassMember::StaticBlock(*StaticBlock::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_INDEX_SIGNATURE.as_ref().unwrap()}.class)).unwrap_or(false) {
        ClassMember::TsIndexSignature(*TsIndexSignature::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by ClassMember", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for Decl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      Decl::Class(node) => node.register_with_map(map),
      Decl::Fn(node) => node.register_with_map(map),
      Decl::TsEnum(node) => node.register_with_map(map),
      Decl::TsInterface(node) => node.register_with_map(map),
      Decl::TsModule(node) => node.register_with_map(map),
      Decl::TsTypeAlias(node) => node.register_with_map(map),
      Decl::Using(node) => node.register_with_map(map),
      Decl::Var(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Decl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      Decl::Class(node) => node.to_java_with_map(env, map),
      Decl::Fn(node) => node.to_java_with_map(env, map),
      Decl::TsEnum(node) => node.to_java_with_map(env, map),
      Decl::TsInterface(node) => node.to_java_with_map(env, map),
      Decl::TsModule(node) => node.to_java_with_map(env, map),
      Decl::TsTypeAlias(node) => node.to_java_with_map(env, map),
      Decl::Using(node) => node.to_java_with_map(env, map),
      Decl::Var(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for Decl {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_CLASS_DECL.as_ref().unwrap()}.class)).unwrap_or(false) {
        Decl::Class(*ClassDecl::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_FN_DECL.as_ref().unwrap()}.class)).unwrap_or(false) {
        Decl::Fn(*FnDecl::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_ENUM_DECL.as_ref().unwrap()}.class)).unwrap_or(false) {
        Decl::TsEnum(TsEnumDecl::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_INTERFACE_DECL.as_ref().unwrap()}.class)).unwrap_or(false) {
        Decl::TsInterface(TsInterfaceDecl::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_MODULE_DECL.as_ref().unwrap()}.class)).unwrap_or(false) {
        Decl::TsModule(TsModuleDecl::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_TYPE_ALIAS_DECL.as_ref().unwrap()}.class)).unwrap_or(false) {
        Decl::TsTypeAlias(TsTypeAliasDecl::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_USING_DECL.as_ref().unwrap()}.class)).unwrap_or(false) {
        Decl::Using(UsingDecl::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_VAR_DECL.as_ref().unwrap()}.class)).unwrap_or(false) {
        Decl::Var(VarDecl::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by Decl", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for DefaultDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      DefaultDecl::Class(node) => node.register_with_map(map),
      DefaultDecl::Fn(node) => node.register_with_map(map),
      DefaultDecl::TsInterfaceDecl(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for DefaultDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      DefaultDecl::Class(node) => node.to_java_with_map(env, map),
      DefaultDecl::Fn(node) => node.to_java_with_map(env, map),
      DefaultDecl::TsInterfaceDecl(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for DefaultDecl {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_CLASS_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        DefaultDecl::Class(*ClassExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_FN_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        DefaultDecl::Fn(*FnExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_INTERFACE_DECL.as_ref().unwrap()}.class)).unwrap_or(false) {
        DefaultDecl::TsInterfaceDecl(TsInterfaceDecl::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by DefaultDecl", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ExportSpecifier {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      ExportSpecifier::Default(node) => node.register_with_map(map),
      ExportSpecifier::Named(node) => node.register_with_map(map),
      ExportSpecifier::Namespace(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ExportSpecifier {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      ExportSpecifier::Default(node) => node.to_java_with_map(env, map),
      ExportSpecifier::Named(node) => node.to_java_with_map(env, map),
      ExportSpecifier::Namespace(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for ExportSpecifier {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_EXPORT_DEFAULT_SPECIFIER.as_ref().unwrap()}.class)).unwrap_or(false) {
        ExportSpecifier::Default(*ExportDefaultSpecifier::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_EXPORT_NAMED_SPECIFIER.as_ref().unwrap()}.class)).unwrap_or(false) {
        ExportSpecifier::Named(*ExportNamedSpecifier::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_EXPORT_NAMESPACE_SPECIFIER.as_ref().unwrap()}.class)).unwrap_or(false) {
        ExportSpecifier::Namespace(*ExportNamespaceSpecifier::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by ExportSpecifier", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for Expr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      Expr::Array(node) => node.register_with_map(map),
      Expr::Arrow(node) => node.register_with_map(map),
      Expr::Assign(node) => node.register_with_map(map),
      Expr::Await(node) => node.register_with_map(map),
      Expr::Bin(node) => node.register_with_map(map),
      Expr::Call(node) => node.register_with_map(map),
      Expr::Class(node) => node.register_with_map(map),
      Expr::Cond(node) => node.register_with_map(map),
      Expr::Fn(node) => node.register_with_map(map),
      Expr::Ident(node) => node.register_with_map(map),
      Expr::Invalid(node) => node.register_with_map(map),
      Expr::JSXElement(node) => node.register_with_map(map),
      Expr::JSXEmpty(node) => node.register_with_map(map),
      Expr::JSXFragment(node) => node.register_with_map(map),
      Expr::JSXMember(node) => node.register_with_map(map),
      Expr::JSXNamespacedName(node) => node.register_with_map(map),
      Expr::Lit(node) => node.register_with_map(map),
      Expr::Member(node) => node.register_with_map(map),
      Expr::MetaProp(node) => node.register_with_map(map),
      Expr::New(node) => node.register_with_map(map),
      Expr::Object(node) => node.register_with_map(map),
      Expr::OptChain(node) => node.register_with_map(map),
      Expr::Paren(node) => node.register_with_map(map),
      Expr::PrivateName(node) => node.register_with_map(map),
      Expr::Seq(node) => node.register_with_map(map),
      Expr::SuperProp(node) => node.register_with_map(map),
      Expr::TaggedTpl(node) => node.register_with_map(map),
      Expr::This(node) => node.register_with_map(map),
      Expr::Tpl(node) => node.register_with_map(map),
      Expr::TsAs(node) => node.register_with_map(map),
      Expr::TsConstAssertion(node) => node.register_with_map(map),
      Expr::TsInstantiation(node) => node.register_with_map(map),
      Expr::TsNonNull(node) => node.register_with_map(map),
      Expr::TsSatisfies(node) => node.register_with_map(map),
      Expr::TsTypeAssertion(node) => node.register_with_map(map),
      Expr::Unary(node) => node.register_with_map(map),
      Expr::Update(node) => node.register_with_map(map),
      Expr::Yield(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Expr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      Expr::Array(node) => node.to_java_with_map(env, map),
      Expr::Arrow(node) => node.to_java_with_map(env, map),
      Expr::Assign(node) => node.to_java_with_map(env, map),
      Expr::Await(node) => node.to_java_with_map(env, map),
      Expr::Bin(node) => node.to_java_with_map(env, map),
      Expr::Call(node) => node.to_java_with_map(env, map),
      Expr::Class(node) => node.to_java_with_map(env, map),
      Expr::Cond(node) => node.to_java_with_map(env, map),
      Expr::Fn(node) => node.to_java_with_map(env, map),
      Expr::Ident(node) => node.to_java_with_map(env, map),
      Expr::Invalid(node) => node.to_java_with_map(env, map),
      Expr::JSXElement(node) => node.to_java_with_map(env, map),
      Expr::JSXEmpty(node) => node.to_java_with_map(env, map),
      Expr::JSXFragment(node) => node.to_java_with_map(env, map),
      Expr::JSXMember(node) => node.to_java_with_map(env, map),
      Expr::JSXNamespacedName(node) => node.to_java_with_map(env, map),
      Expr::Lit(node) => node.to_java_with_map(env, map),
      Expr::Member(node) => node.to_java_with_map(env, map),
      Expr::MetaProp(node) => node.to_java_with_map(env, map),
      Expr::New(node) => node.to_java_with_map(env, map),
      Expr::Object(node) => node.to_java_with_map(env, map),
      Expr::OptChain(node) => node.to_java_with_map(env, map),
      Expr::Paren(node) => node.to_java_with_map(env, map),
      Expr::PrivateName(node) => node.to_java_with_map(env, map),
      Expr::Seq(node) => node.to_java_with_map(env, map),
      Expr::SuperProp(node) => node.to_java_with_map(env, map),
      Expr::TaggedTpl(node) => node.to_java_with_map(env, map),
      Expr::This(node) => node.to_java_with_map(env, map),
      Expr::Tpl(node) => node.to_java_with_map(env, map),
      Expr::TsAs(node) => node.to_java_with_map(env, map),
      Expr::TsConstAssertion(node) => node.to_java_with_map(env, map),
      Expr::TsInstantiation(node) => node.to_java_with_map(env, map),
      Expr::TsNonNull(node) => node.to_java_with_map(env, map),
      Expr::TsSatisfies(node) => node.to_java_with_map(env, map),
      Expr::TsTypeAssertion(node) => node.to_java_with_map(env, map),
      Expr::Unary(node) => node.to_java_with_map(env, map),
      Expr::Update(node) => node.to_java_with_map(env, map),
      Expr::Yield(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for Expr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_ARRAY_LIT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::Array(*ArrayLit::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_ARROW_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::Arrow(*ArrowExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_ASSIGN_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::Assign(*AssignExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_AWAIT_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::Await(*AwaitExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_BIN_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::Bin(*BinExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_CALL_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::Call(*CallExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_CLASS_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::Class(*ClassExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_COND_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::Cond(*CondExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_FN_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::Fn(*FnExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_IDENT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::Ident(*Ident::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_INVALID.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::Invalid(*Invalid::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_JSX_ELEMENT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::JSXElement(JSXElement::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_JSX_EMPTY_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::JSXEmpty(*JSXEmptyExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_JSX_FRAGMENT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::JSXFragment(*JSXFragment::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_JSX_MEMBER_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::JSXMember(*JSXMemberExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_JSX_NAMESPACED_NAME.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::JSXNamespacedName(*JSXNamespacedName::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_LIT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::Lit(*Lit::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_MEMBER_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::Member(*MemberExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_META_PROP_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::MetaProp(*MetaPropExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_NEW_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::New(*NewExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_OBJECT_LIT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::Object(*ObjectLit::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_OPT_CHAIN_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::OptChain(*OptChainExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_PAREN_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::Paren(*ParenExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_PRIVATE_NAME.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::PrivateName(*PrivateName::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_SEQ_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::Seq(*SeqExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_SUPER_PROP_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::SuperProp(*SuperPropExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TAGGED_TPL.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::TaggedTpl(*TaggedTpl::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_THIS_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::This(*ThisExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TPL.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::Tpl(*Tpl::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_AS_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::TsAs(*TsAsExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_CONST_ASSERTION.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::TsConstAssertion(*TsConstAssertion::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_INSTANTIATION.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::TsInstantiation(*TsInstantiation::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_NON_NULL_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::TsNonNull(*TsNonNullExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_SATISFIES_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::TsSatisfies(*TsSatisfiesExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_TYPE_ASSERTION.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::TsTypeAssertion(*TsTypeAssertion::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_UNARY_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::Unary(*UnaryExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_UPDATE_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::Update(*UpdateExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_YIELD_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        Expr::Yield(*YieldExpr::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by Expr", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ForHead {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      ForHead::Pat(node) => node.register_with_map(map),
      ForHead::UsingDecl(node) => node.register_with_map(map),
      ForHead::VarDecl(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ForHead {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      ForHead::Pat(node) => node.to_java_with_map(env, map),
      ForHead::UsingDecl(node) => node.to_java_with_map(env, map),
      ForHead::VarDecl(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for ForHead {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_PAT.as_ref().unwrap()}.class)).unwrap_or(false) {
        ForHead::Pat(Pat::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_USING_DECL.as_ref().unwrap()}.class)).unwrap_or(false) {
        ForHead::UsingDecl(UsingDecl::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_VAR_DECL.as_ref().unwrap()}.class)).unwrap_or(false) {
        ForHead::VarDecl(VarDecl::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by ForHead", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ImportSpecifier {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      ImportSpecifier::Default(node) => node.register_with_map(map),
      ImportSpecifier::Named(node) => node.register_with_map(map),
      ImportSpecifier::Namespace(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ImportSpecifier {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      ImportSpecifier::Default(node) => node.to_java_with_map(env, map),
      ImportSpecifier::Named(node) => node.to_java_with_map(env, map),
      ImportSpecifier::Namespace(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for ImportSpecifier {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_IMPORT_DEFAULT_SPECIFIER.as_ref().unwrap()}.class)).unwrap_or(false) {
        ImportSpecifier::Default(*ImportDefaultSpecifier::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_IMPORT_NAMED_SPECIFIER.as_ref().unwrap()}.class)).unwrap_or(false) {
        ImportSpecifier::Named(*ImportNamedSpecifier::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_IMPORT_STAR_AS_SPECIFIER.as_ref().unwrap()}.class)).unwrap_or(false) {
        ImportSpecifier::Namespace(*ImportStarAsSpecifier::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by ImportSpecifier", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXAttrName {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      JSXAttrName::Ident(node) => node.register_with_map(map),
      JSXAttrName::JSXNamespacedName(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXAttrName {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      JSXAttrName::Ident(node) => node.to_java_with_map(env, map),
      JSXAttrName::JSXNamespacedName(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for JSXAttrName {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_IDENT_NAME.as_ref().unwrap()}.class)).unwrap_or(false) {
        JSXAttrName::Ident(*IdentName::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_JSX_NAMESPACED_NAME.as_ref().unwrap()}.class)).unwrap_or(false) {
        JSXAttrName::JSXNamespacedName(*JSXNamespacedName::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by JSXAttrName", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXAttrOrSpread {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      JSXAttrOrSpread::JSXAttr(node) => node.register_with_map(map),
      JSXAttrOrSpread::SpreadElement(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXAttrOrSpread {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      JSXAttrOrSpread::JSXAttr(node) => node.to_java_with_map(env, map),
      JSXAttrOrSpread::SpreadElement(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for JSXAttrOrSpread {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_JSX_ATTR.as_ref().unwrap()}.class)).unwrap_or(false) {
        JSXAttrOrSpread::JSXAttr(*JSXAttr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_SPREAD_ELEMENT.as_ref().unwrap()}.class)).unwrap_or(false) {
        JSXAttrOrSpread::SpreadElement(*SpreadElement::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by JSXAttrOrSpread", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXAttrValue {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      JSXAttrValue::JSXElement(node) => node.register_with_map(map),
      JSXAttrValue::JSXExprContainer(node) => node.register_with_map(map),
      JSXAttrValue::JSXFragment(node) => node.register_with_map(map),
      JSXAttrValue::Lit(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXAttrValue {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      JSXAttrValue::JSXElement(node) => node.to_java_with_map(env, map),
      JSXAttrValue::JSXExprContainer(node) => node.to_java_with_map(env, map),
      JSXAttrValue::JSXFragment(node) => node.to_java_with_map(env, map),
      JSXAttrValue::Lit(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for JSXAttrValue {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_JSX_ELEMENT.as_ref().unwrap()}.class)).unwrap_or(false) {
        JSXAttrValue::JSXElement(JSXElement::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_JSX_EXPR_CONTAINER.as_ref().unwrap()}.class)).unwrap_or(false) {
        JSXAttrValue::JSXExprContainer(*JSXExprContainer::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_JSX_FRAGMENT.as_ref().unwrap()}.class)).unwrap_or(false) {
        JSXAttrValue::JSXFragment(*JSXFragment::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_LIT.as_ref().unwrap()}.class)).unwrap_or(false) {
        JSXAttrValue::Lit(*Lit::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by JSXAttrValue", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXElementChild {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      JSXElementChild::JSXElement(node) => node.register_with_map(map),
      JSXElementChild::JSXExprContainer(node) => node.register_with_map(map),
      JSXElementChild::JSXFragment(node) => node.register_with_map(map),
      JSXElementChild::JSXSpreadChild(node) => node.register_with_map(map),
      JSXElementChild::JSXText(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXElementChild {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      JSXElementChild::JSXElement(node) => node.to_java_with_map(env, map),
      JSXElementChild::JSXExprContainer(node) => node.to_java_with_map(env, map),
      JSXElementChild::JSXFragment(node) => node.to_java_with_map(env, map),
      JSXElementChild::JSXSpreadChild(node) => node.to_java_with_map(env, map),
      JSXElementChild::JSXText(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for JSXElementChild {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_JSX_ELEMENT.as_ref().unwrap()}.class)).unwrap_or(false) {
        JSXElementChild::JSXElement(JSXElement::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_JSX_EXPR_CONTAINER.as_ref().unwrap()}.class)).unwrap_or(false) {
        JSXElementChild::JSXExprContainer(*JSXExprContainer::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_JSX_FRAGMENT.as_ref().unwrap()}.class)).unwrap_or(false) {
        JSXElementChild::JSXFragment(*JSXFragment::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_JSX_SPREAD_CHILD.as_ref().unwrap()}.class)).unwrap_or(false) {
        JSXElementChild::JSXSpreadChild(*JSXSpreadChild::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_JSX_TEXT.as_ref().unwrap()}.class)).unwrap_or(false) {
        JSXElementChild::JSXText(*JSXText::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by JSXElementChild", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXElementName {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      JSXElementName::Ident(node) => node.register_with_map(map),
      JSXElementName::JSXMemberExpr(node) => node.register_with_map(map),
      JSXElementName::JSXNamespacedName(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXElementName {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      JSXElementName::Ident(node) => node.to_java_with_map(env, map),
      JSXElementName::JSXMemberExpr(node) => node.to_java_with_map(env, map),
      JSXElementName::JSXNamespacedName(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for JSXElementName {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_IDENT.as_ref().unwrap()}.class)).unwrap_or(false) {
        JSXElementName::Ident(*Ident::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_JSX_MEMBER_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        JSXElementName::JSXMemberExpr(*JSXMemberExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_JSX_NAMESPACED_NAME.as_ref().unwrap()}.class)).unwrap_or(false) {
        JSXElementName::JSXNamespacedName(*JSXNamespacedName::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by JSXElementName", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      JSXExpr::Expr(node) => node.register_with_map(map),
      JSXExpr::JSXEmptyExpr(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      JSXExpr::Expr(node) => node.to_java_with_map(env, map),
      JSXExpr::JSXEmptyExpr(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for JSXExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        JSXExpr::Expr(Expr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_JSX_EMPTY_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        JSXExpr::JSXEmptyExpr(*JSXEmptyExpr::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by JSXExpr", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXObject {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      JSXObject::Ident(node) => node.register_with_map(map),
      JSXObject::JSXMemberExpr(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXObject {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      JSXObject::Ident(node) => node.to_java_with_map(env, map),
      JSXObject::JSXMemberExpr(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for JSXObject {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_IDENT.as_ref().unwrap()}.class)).unwrap_or(false) {
        JSXObject::Ident(*Ident::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_JSX_MEMBER_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        JSXObject::JSXMemberExpr(JSXMemberExpr::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by JSXObject", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for Key {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      Key::Private(node) => node.register_with_map(map),
      Key::Public(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Key {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      Key::Private(node) => node.to_java_with_map(env, map),
      Key::Public(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for Key {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_PRIVATE_NAME.as_ref().unwrap()}.class)).unwrap_or(false) {
        Key::Private(*PrivateName::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_PROP_NAME.as_ref().unwrap()}.class)).unwrap_or(false) {
        Key::Public(*PropName::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by Key", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for Lit {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      Lit::BigInt(node) => node.register_with_map(map),
      Lit::Bool(node) => node.register_with_map(map),
      Lit::JSXText(node) => node.register_with_map(map),
      Lit::Null(node) => node.register_with_map(map),
      Lit::Num(node) => node.register_with_map(map),
      Lit::Regex(node) => node.register_with_map(map),
      Lit::Str(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Lit {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      Lit::BigInt(node) => node.to_java_with_map(env, map),
      Lit::Bool(node) => node.to_java_with_map(env, map),
      Lit::JSXText(node) => node.to_java_with_map(env, map),
      Lit::Null(node) => node.to_java_with_map(env, map),
      Lit::Num(node) => node.to_java_with_map(env, map),
      Lit::Regex(node) => node.to_java_with_map(env, map),
      Lit::Str(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for Lit {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_BIG_INT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Lit::BigInt(*BigInt::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_BOOL.as_ref().unwrap()}.class)).unwrap_or(false) {
        Lit::Bool(*Bool::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_JSX_TEXT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Lit::JSXText(*JSXText::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_NULL.as_ref().unwrap()}.class)).unwrap_or(false) {
        Lit::Null(*Null::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_NUMBER.as_ref().unwrap()}.class)).unwrap_or(false) {
        Lit::Num(*Number::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_REGEX.as_ref().unwrap()}.class)).unwrap_or(false) {
        Lit::Regex(*Regex::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_STR.as_ref().unwrap()}.class)).unwrap_or(false) {
        Lit::Str(*Str::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by Lit", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for MemberProp {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      MemberProp::Computed(node) => node.register_with_map(map),
      MemberProp::Ident(node) => node.register_with_map(map),
      MemberProp::PrivateName(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for MemberProp {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      MemberProp::Computed(node) => node.to_java_with_map(env, map),
      MemberProp::Ident(node) => node.to_java_with_map(env, map),
      MemberProp::PrivateName(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for MemberProp {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_COMPUTED_PROP_NAME.as_ref().unwrap()}.class)).unwrap_or(false) {
        MemberProp::Computed(*ComputedPropName::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_IDENT_NAME.as_ref().unwrap()}.class)).unwrap_or(false) {
        MemberProp::Ident(*IdentName::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_PRIVATE_NAME.as_ref().unwrap()}.class)).unwrap_or(false) {
        MemberProp::PrivateName(*PrivateName::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by MemberProp", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ModuleDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      ModuleDecl::ExportAll(node) => node.register_with_map(map),
      ModuleDecl::ExportDecl(node) => node.register_with_map(map),
      ModuleDecl::ExportDefaultDecl(node) => node.register_with_map(map),
      ModuleDecl::ExportDefaultExpr(node) => node.register_with_map(map),
      ModuleDecl::ExportNamed(node) => node.register_with_map(map),
      ModuleDecl::Import(node) => node.register_with_map(map),
      ModuleDecl::TsExportAssignment(node) => node.register_with_map(map),
      ModuleDecl::TsImportEquals(node) => node.register_with_map(map),
      ModuleDecl::TsNamespaceExport(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ModuleDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      ModuleDecl::ExportAll(node) => node.to_java_with_map(env, map),
      ModuleDecl::ExportDecl(node) => node.to_java_with_map(env, map),
      ModuleDecl::ExportDefaultDecl(node) => node.to_java_with_map(env, map),
      ModuleDecl::ExportDefaultExpr(node) => node.to_java_with_map(env, map),
      ModuleDecl::ExportNamed(node) => node.to_java_with_map(env, map),
      ModuleDecl::Import(node) => node.to_java_with_map(env, map),
      ModuleDecl::TsExportAssignment(node) => node.to_java_with_map(env, map),
      ModuleDecl::TsImportEquals(node) => node.to_java_with_map(env, map),
      ModuleDecl::TsNamespaceExport(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for ModuleDecl {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_EXPORT_ALL.as_ref().unwrap()}.class)).unwrap_or(false) {
        ModuleDecl::ExportAll(*ExportAll::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_EXPORT_DECL.as_ref().unwrap()}.class)).unwrap_or(false) {
        ModuleDecl::ExportDecl(*ExportDecl::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_EXPORT_DEFAULT_DECL.as_ref().unwrap()}.class)).unwrap_or(false) {
        ModuleDecl::ExportDefaultDecl(*ExportDefaultDecl::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_EXPORT_DEFAULT_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        ModuleDecl::ExportDefaultExpr(*ExportDefaultExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_NAMED_EXPORT.as_ref().unwrap()}.class)).unwrap_or(false) {
        ModuleDecl::ExportNamed(*NamedExport::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_IMPORT_DECL.as_ref().unwrap()}.class)).unwrap_or(false) {
        ModuleDecl::Import(*ImportDecl::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_EXPORT_ASSIGNMENT.as_ref().unwrap()}.class)).unwrap_or(false) {
        ModuleDecl::TsExportAssignment(*TsExportAssignment::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_IMPORT_EQUALS_DECL.as_ref().unwrap()}.class)).unwrap_or(false) {
        ModuleDecl::TsImportEquals(TsImportEqualsDecl::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_NAMESPACE_EXPORT_DECL.as_ref().unwrap()}.class)).unwrap_or(false) {
        ModuleDecl::TsNamespaceExport(*TsNamespaceExportDecl::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by ModuleDecl", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ModuleExportName {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      ModuleExportName::Ident(node) => node.register_with_map(map),
      ModuleExportName::Str(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ModuleExportName {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      ModuleExportName::Ident(node) => node.to_java_with_map(env, map),
      ModuleExportName::Str(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for ModuleExportName {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_IDENT.as_ref().unwrap()}.class)).unwrap_or(false) {
        ModuleExportName::Ident(*Ident::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_STR.as_ref().unwrap()}.class)).unwrap_or(false) {
        ModuleExportName::Str(*Str::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by ModuleExportName", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ModuleItem {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      ModuleItem::ModuleDecl(node) => node.register_with_map(map),
      ModuleItem::Stmt(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ModuleItem {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      ModuleItem::ModuleDecl(node) => node.to_java_with_map(env, map),
      ModuleItem::Stmt(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for ModuleItem {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_MODULE_DECL.as_ref().unwrap()}.class)).unwrap_or(false) {
        ModuleItem::ModuleDecl(*ModuleDecl::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_STMT.as_ref().unwrap()}.class)).unwrap_or(false) {
        ModuleItem::Stmt(*Stmt::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by ModuleItem", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ObjectPatProp {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      ObjectPatProp::Assign(node) => node.register_with_map(map),
      ObjectPatProp::KeyValue(node) => node.register_with_map(map),
      ObjectPatProp::Rest(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ObjectPatProp {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      ObjectPatProp::Assign(node) => node.to_java_with_map(env, map),
      ObjectPatProp::KeyValue(node) => node.to_java_with_map(env, map),
      ObjectPatProp::Rest(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for ObjectPatProp {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_ASSIGN_PAT_PROP.as_ref().unwrap()}.class)).unwrap_or(false) {
        ObjectPatProp::Assign(*AssignPatProp::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_KEY_VALUE_PAT_PROP.as_ref().unwrap()}.class)).unwrap_or(false) {
        ObjectPatProp::KeyValue(*KeyValuePatProp::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_REST_PAT.as_ref().unwrap()}.class)).unwrap_or(false) {
        ObjectPatProp::Rest(*RestPat::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by ObjectPatProp", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for OptChainBase {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      OptChainBase::Call(node) => node.register_with_map(map),
      OptChainBase::Member(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for OptChainBase {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      OptChainBase::Call(node) => node.to_java_with_map(env, map),
      OptChainBase::Member(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for OptChainBase {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_OPT_CALL.as_ref().unwrap()}.class)).unwrap_or(false) {
        OptChainBase::Call(*OptCall::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_MEMBER_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        OptChainBase::Member(*MemberExpr::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by OptChainBase", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ParamOrTsParamProp {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      ParamOrTsParamProp::Param(node) => node.register_with_map(map),
      ParamOrTsParamProp::TsParamProp(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ParamOrTsParamProp {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      ParamOrTsParamProp::Param(node) => node.to_java_with_map(env, map),
      ParamOrTsParamProp::TsParamProp(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for ParamOrTsParamProp {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_PARAM.as_ref().unwrap()}.class)).unwrap_or(false) {
        ParamOrTsParamProp::Param(*Param::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_PARAM_PROP.as_ref().unwrap()}.class)).unwrap_or(false) {
        ParamOrTsParamProp::TsParamProp(*TsParamProp::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by ParamOrTsParamProp", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for Pat {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      Pat::Array(node) => node.register_with_map(map),
      Pat::Assign(node) => node.register_with_map(map),
      Pat::Expr(node) => node.register_with_map(map),
      Pat::Ident(node) => node.register_with_map(map),
      Pat::Invalid(node) => node.register_with_map(map),
      Pat::Object(node) => node.register_with_map(map),
      Pat::Rest(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Pat {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      Pat::Array(node) => node.to_java_with_map(env, map),
      Pat::Assign(node) => node.to_java_with_map(env, map),
      Pat::Expr(node) => node.to_java_with_map(env, map),
      Pat::Ident(node) => node.to_java_with_map(env, map),
      Pat::Invalid(node) => node.to_java_with_map(env, map),
      Pat::Object(node) => node.to_java_with_map(env, map),
      Pat::Rest(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for Pat {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_ARRAY_PAT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Pat::Array(*ArrayPat::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_ASSIGN_PAT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Pat::Assign(*AssignPat::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        Pat::Expr(Expr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_BINDING_IDENT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Pat::Ident(*BindingIdent::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_INVALID.as_ref().unwrap()}.class)).unwrap_or(false) {
        Pat::Invalid(*Invalid::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_OBJECT_PAT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Pat::Object(*ObjectPat::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_REST_PAT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Pat::Rest(*RestPat::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by Pat", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for Program {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      Program::Module(node) => node.register_with_map(map),
      Program::Script(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Program {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      Program::Module(node) => node.to_java_with_map(env, map),
      Program::Script(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for Program {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_MODULE.as_ref().unwrap()}.class)).unwrap_or(false) {
        Program::Module(*Module::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_SCRIPT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Program::Script(*Script::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by Program", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for Prop {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      Prop::Assign(node) => node.register_with_map(map),
      Prop::Getter(node) => node.register_with_map(map),
      Prop::KeyValue(node) => node.register_with_map(map),
      Prop::Method(node) => node.register_with_map(map),
      Prop::Setter(node) => node.register_with_map(map),
      Prop::Shorthand(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Prop {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      Prop::Assign(node) => node.to_java_with_map(env, map),
      Prop::Getter(node) => node.to_java_with_map(env, map),
      Prop::KeyValue(node) => node.to_java_with_map(env, map),
      Prop::Method(node) => node.to_java_with_map(env, map),
      Prop::Setter(node) => node.to_java_with_map(env, map),
      Prop::Shorthand(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for Prop {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_ASSIGN_PROP.as_ref().unwrap()}.class)).unwrap_or(false) {
        Prop::Assign(*AssignProp::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_GETTER_PROP.as_ref().unwrap()}.class)).unwrap_or(false) {
        Prop::Getter(*GetterProp::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_KEY_VALUE_PROP.as_ref().unwrap()}.class)).unwrap_or(false) {
        Prop::KeyValue(*KeyValueProp::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_METHOD_PROP.as_ref().unwrap()}.class)).unwrap_or(false) {
        Prop::Method(*MethodProp::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_SETTER_PROP.as_ref().unwrap()}.class)).unwrap_or(false) {
        Prop::Setter(*SetterProp::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_IDENT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Prop::Shorthand(*Ident::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by Prop", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for PropName {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      PropName::BigInt(node) => node.register_with_map(map),
      PropName::Computed(node) => node.register_with_map(map),
      PropName::Ident(node) => node.register_with_map(map),
      PropName::Num(node) => node.register_with_map(map),
      PropName::Str(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for PropName {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      PropName::BigInt(node) => node.to_java_with_map(env, map),
      PropName::Computed(node) => node.to_java_with_map(env, map),
      PropName::Ident(node) => node.to_java_with_map(env, map),
      PropName::Num(node) => node.to_java_with_map(env, map),
      PropName::Str(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for PropName {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_BIG_INT.as_ref().unwrap()}.class)).unwrap_or(false) {
        PropName::BigInt(*BigInt::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_COMPUTED_PROP_NAME.as_ref().unwrap()}.class)).unwrap_or(false) {
        PropName::Computed(*ComputedPropName::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_IDENT_NAME.as_ref().unwrap()}.class)).unwrap_or(false) {
        PropName::Ident(*IdentName::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_NUMBER.as_ref().unwrap()}.class)).unwrap_or(false) {
        PropName::Num(*Number::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_STR.as_ref().unwrap()}.class)).unwrap_or(false) {
        PropName::Str(*Str::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by PropName", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for PropOrSpread {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      PropOrSpread::Prop(node) => node.register_with_map(map),
      PropOrSpread::Spread(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for PropOrSpread {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      PropOrSpread::Prop(node) => node.to_java_with_map(env, map),
      PropOrSpread::Spread(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for PropOrSpread {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_PROP.as_ref().unwrap()}.class)).unwrap_or(false) {
        PropOrSpread::Prop(Prop::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_SPREAD_ELEMENT.as_ref().unwrap()}.class)).unwrap_or(false) {
        PropOrSpread::Spread(*SpreadElement::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by PropOrSpread", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for SimpleAssignTarget {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      SimpleAssignTarget::Ident(node) => node.register_with_map(map),
      SimpleAssignTarget::Invalid(node) => node.register_with_map(map),
      SimpleAssignTarget::Member(node) => node.register_with_map(map),
      SimpleAssignTarget::OptChain(node) => node.register_with_map(map),
      SimpleAssignTarget::Paren(node) => node.register_with_map(map),
      SimpleAssignTarget::SuperProp(node) => node.register_with_map(map),
      SimpleAssignTarget::TsAs(node) => node.register_with_map(map),
      SimpleAssignTarget::TsInstantiation(node) => node.register_with_map(map),
      SimpleAssignTarget::TsNonNull(node) => node.register_with_map(map),
      SimpleAssignTarget::TsSatisfies(node) => node.register_with_map(map),
      SimpleAssignTarget::TsTypeAssertion(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for SimpleAssignTarget {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      SimpleAssignTarget::Ident(node) => node.to_java_with_map(env, map),
      SimpleAssignTarget::Invalid(node) => node.to_java_with_map(env, map),
      SimpleAssignTarget::Member(node) => node.to_java_with_map(env, map),
      SimpleAssignTarget::OptChain(node) => node.to_java_with_map(env, map),
      SimpleAssignTarget::Paren(node) => node.to_java_with_map(env, map),
      SimpleAssignTarget::SuperProp(node) => node.to_java_with_map(env, map),
      SimpleAssignTarget::TsAs(node) => node.to_java_with_map(env, map),
      SimpleAssignTarget::TsInstantiation(node) => node.to_java_with_map(env, map),
      SimpleAssignTarget::TsNonNull(node) => node.to_java_with_map(env, map),
      SimpleAssignTarget::TsSatisfies(node) => node.to_java_with_map(env, map),
      SimpleAssignTarget::TsTypeAssertion(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for SimpleAssignTarget {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_BINDING_IDENT.as_ref().unwrap()}.class)).unwrap_or(false) {
        SimpleAssignTarget::Ident(*BindingIdent::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_INVALID.as_ref().unwrap()}.class)).unwrap_or(false) {
        SimpleAssignTarget::Invalid(*Invalid::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_MEMBER_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        SimpleAssignTarget::Member(*MemberExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_OPT_CHAIN_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        SimpleAssignTarget::OptChain(*OptChainExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_PAREN_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        SimpleAssignTarget::Paren(*ParenExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_SUPER_PROP_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        SimpleAssignTarget::SuperProp(*SuperPropExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_AS_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        SimpleAssignTarget::TsAs(*TsAsExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_INSTANTIATION.as_ref().unwrap()}.class)).unwrap_or(false) {
        SimpleAssignTarget::TsInstantiation(*TsInstantiation::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_NON_NULL_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        SimpleAssignTarget::TsNonNull(*TsNonNullExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_SATISFIES_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        SimpleAssignTarget::TsSatisfies(*TsSatisfiesExpr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_TYPE_ASSERTION.as_ref().unwrap()}.class)).unwrap_or(false) {
        SimpleAssignTarget::TsTypeAssertion(*TsTypeAssertion::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by SimpleAssignTarget", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for Stmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      Stmt::Block(node) => node.register_with_map(map),
      Stmt::Break(node) => node.register_with_map(map),
      Stmt::Continue(node) => node.register_with_map(map),
      Stmt::Debugger(node) => node.register_with_map(map),
      Stmt::Decl(node) => node.register_with_map(map),
      Stmt::DoWhile(node) => node.register_with_map(map),
      Stmt::Empty(node) => node.register_with_map(map),
      Stmt::Expr(node) => node.register_with_map(map),
      Stmt::For(node) => node.register_with_map(map),
      Stmt::ForIn(node) => node.register_with_map(map),
      Stmt::ForOf(node) => node.register_with_map(map),
      Stmt::If(node) => node.register_with_map(map),
      Stmt::Labeled(node) => node.register_with_map(map),
      Stmt::Return(node) => node.register_with_map(map),
      Stmt::Switch(node) => node.register_with_map(map),
      Stmt::Throw(node) => node.register_with_map(map),
      Stmt::Try(node) => node.register_with_map(map),
      Stmt::While(node) => node.register_with_map(map),
      Stmt::With(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Stmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      Stmt::Block(node) => node.to_java_with_map(env, map),
      Stmt::Break(node) => node.to_java_with_map(env, map),
      Stmt::Continue(node) => node.to_java_with_map(env, map),
      Stmt::Debugger(node) => node.to_java_with_map(env, map),
      Stmt::Decl(node) => node.to_java_with_map(env, map),
      Stmt::DoWhile(node) => node.to_java_with_map(env, map),
      Stmt::Empty(node) => node.to_java_with_map(env, map),
      Stmt::Expr(node) => node.to_java_with_map(env, map),
      Stmt::For(node) => node.to_java_with_map(env, map),
      Stmt::ForIn(node) => node.to_java_with_map(env, map),
      Stmt::ForOf(node) => node.to_java_with_map(env, map),
      Stmt::If(node) => node.to_java_with_map(env, map),
      Stmt::Labeled(node) => node.to_java_with_map(env, map),
      Stmt::Return(node) => node.to_java_with_map(env, map),
      Stmt::Switch(node) => node.to_java_with_map(env, map),
      Stmt::Throw(node) => node.to_java_with_map(env, map),
      Stmt::Try(node) => node.to_java_with_map(env, map),
      Stmt::While(node) => node.to_java_with_map(env, map),
      Stmt::With(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for Stmt {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_BLOCK_STMT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Stmt::Block(*BlockStmt::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_BREAK_STMT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Stmt::Break(*BreakStmt::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_CONTINUE_STMT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Stmt::Continue(*ContinueStmt::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_DEBUGGER_STMT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Stmt::Debugger(*DebuggerStmt::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_DECL.as_ref().unwrap()}.class)).unwrap_or(false) {
        Stmt::Decl(*Decl::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_DO_WHILE_STMT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Stmt::DoWhile(*DoWhileStmt::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_EMPTY_STMT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Stmt::Empty(*EmptyStmt::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_EXPR_STMT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Stmt::Expr(*ExprStmt::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_FOR_STMT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Stmt::For(*ForStmt::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_FOR_IN_STMT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Stmt::ForIn(*ForInStmt::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_FOR_OF_STMT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Stmt::ForOf(*ForOfStmt::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_IF_STMT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Stmt::If(*IfStmt::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_LABELED_STMT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Stmt::Labeled(*LabeledStmt::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_RETURN_STMT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Stmt::Return(*ReturnStmt::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_SWITCH_STMT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Stmt::Switch(*SwitchStmt::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_THROW_STMT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Stmt::Throw(*ThrowStmt::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TRY_STMT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Stmt::Try(TryStmt::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_WHILE_STMT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Stmt::While(*WhileStmt::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_WITH_STMT.as_ref().unwrap()}.class)).unwrap_or(false) {
        Stmt::With(*WithStmt::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by Stmt", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for SuperProp {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      SuperProp::Computed(node) => node.register_with_map(map),
      SuperProp::Ident(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for SuperProp {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      SuperProp::Computed(node) => node.to_java_with_map(env, map),
      SuperProp::Ident(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for SuperProp {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_COMPUTED_PROP_NAME.as_ref().unwrap()}.class)).unwrap_or(false) {
        SuperProp::Computed(*ComputedPropName::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_IDENT_NAME.as_ref().unwrap()}.class)).unwrap_or(false) {
        SuperProp::Ident(*IdentName::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by SuperProp", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsEntityName {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      TsEntityName::Ident(node) => node.register_with_map(map),
      TsEntityName::TsQualifiedName(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsEntityName {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      TsEntityName::Ident(node) => node.to_java_with_map(env, map),
      TsEntityName::TsQualifiedName(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for TsEntityName {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_IDENT.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsEntityName::Ident(*Ident::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_QUALIFIED_NAME.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsEntityName::TsQualifiedName(TsQualifiedName::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by TsEntityName", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsEnumMemberId {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      TsEnumMemberId::Ident(node) => node.register_with_map(map),
      TsEnumMemberId::Str(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsEnumMemberId {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      TsEnumMemberId::Ident(node) => node.to_java_with_map(env, map),
      TsEnumMemberId::Str(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for TsEnumMemberId {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_IDENT.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsEnumMemberId::Ident(*Ident::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_STR.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsEnumMemberId::Str(*Str::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by TsEnumMemberId", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsFnOrConstructorType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      TsFnOrConstructorType::TsConstructorType(node) => node.register_with_map(map),
      TsFnOrConstructorType::TsFnType(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsFnOrConstructorType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      TsFnOrConstructorType::TsConstructorType(node) => node.to_java_with_map(env, map),
      TsFnOrConstructorType::TsFnType(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for TsFnOrConstructorType {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_CONSTRUCTOR_TYPE.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsFnOrConstructorType::TsConstructorType(*TsConstructorType::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_FN_TYPE.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsFnOrConstructorType::TsFnType(*TsFnType::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by TsFnOrConstructorType", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsFnParam {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      TsFnParam::Array(node) => node.register_with_map(map),
      TsFnParam::Ident(node) => node.register_with_map(map),
      TsFnParam::Object(node) => node.register_with_map(map),
      TsFnParam::Rest(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsFnParam {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      TsFnParam::Array(node) => node.to_java_with_map(env, map),
      TsFnParam::Ident(node) => node.to_java_with_map(env, map),
      TsFnParam::Object(node) => node.to_java_with_map(env, map),
      TsFnParam::Rest(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for TsFnParam {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_ARRAY_PAT.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsFnParam::Array(*ArrayPat::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_BINDING_IDENT.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsFnParam::Ident(*BindingIdent::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_OBJECT_PAT.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsFnParam::Object(*ObjectPat::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_REST_PAT.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsFnParam::Rest(*RestPat::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by TsFnParam", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsLit {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      TsLit::BigInt(node) => node.register_with_map(map),
      TsLit::Bool(node) => node.register_with_map(map),
      TsLit::Number(node) => node.register_with_map(map),
      TsLit::Str(node) => node.register_with_map(map),
      TsLit::Tpl(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsLit {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      TsLit::BigInt(node) => node.to_java_with_map(env, map),
      TsLit::Bool(node) => node.to_java_with_map(env, map),
      TsLit::Number(node) => node.to_java_with_map(env, map),
      TsLit::Str(node) => node.to_java_with_map(env, map),
      TsLit::Tpl(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for TsLit {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_BIG_INT.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsLit::BigInt(*BigInt::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_BOOL.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsLit::Bool(*Bool::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_NUMBER.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsLit::Number(*Number::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_STR.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsLit::Str(*Str::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_TPL_LIT_TYPE.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsLit::Tpl(*TsTplLitType::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by TsLit", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsModuleName {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      TsModuleName::Ident(node) => node.register_with_map(map),
      TsModuleName::Str(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsModuleName {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      TsModuleName::Ident(node) => node.to_java_with_map(env, map),
      TsModuleName::Str(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for TsModuleName {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_IDENT.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsModuleName::Ident(*Ident::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_STR.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsModuleName::Str(*Str::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by TsModuleName", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsModuleRef {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      TsModuleRef::TsEntityName(node) => node.register_with_map(map),
      TsModuleRef::TsExternalModuleRef(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsModuleRef {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      TsModuleRef::TsEntityName(node) => node.to_java_with_map(env, map),
      TsModuleRef::TsExternalModuleRef(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for TsModuleRef {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_ENTITY_NAME.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsModuleRef::TsEntityName(*TsEntityName::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_EXTERNAL_MODULE_REF.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsModuleRef::TsExternalModuleRef(*TsExternalModuleRef::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by TsModuleRef", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsNamespaceBody {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      TsNamespaceBody::TsModuleBlock(node) => node.register_with_map(map),
      TsNamespaceBody::TsNamespaceDecl(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsNamespaceBody {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      TsNamespaceBody::TsModuleBlock(node) => node.to_java_with_map(env, map),
      TsNamespaceBody::TsNamespaceDecl(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for TsNamespaceBody {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_MODULE_BLOCK.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsNamespaceBody::TsModuleBlock(*TsModuleBlock::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_NAMESPACE_DECL.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsNamespaceBody::TsNamespaceDecl(*TsNamespaceDecl::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by TsNamespaceBody", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsParamPropParam {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      TsParamPropParam::Assign(node) => node.register_with_map(map),
      TsParamPropParam::Ident(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsParamPropParam {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      TsParamPropParam::Assign(node) => node.to_java_with_map(env, map),
      TsParamPropParam::Ident(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for TsParamPropParam {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_ASSIGN_PAT.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsParamPropParam::Assign(*AssignPat::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_BINDING_IDENT.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsParamPropParam::Ident(*BindingIdent::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by TsParamPropParam", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsThisTypeOrIdent {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      TsThisTypeOrIdent::Ident(node) => node.register_with_map(map),
      TsThisTypeOrIdent::TsThisType(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsThisTypeOrIdent {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      TsThisTypeOrIdent::Ident(node) => node.to_java_with_map(env, map),
      TsThisTypeOrIdent::TsThisType(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for TsThisTypeOrIdent {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_IDENT.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsThisTypeOrIdent::Ident(*Ident::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_THIS_TYPE.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsThisTypeOrIdent::TsThisType(*TsThisType::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by TsThisTypeOrIdent", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      TsType::TsArrayType(node) => node.register_with_map(map),
      TsType::TsConditionalType(node) => node.register_with_map(map),
      TsType::TsFnOrConstructorType(node) => node.register_with_map(map),
      TsType::TsImportType(node) => node.register_with_map(map),
      TsType::TsIndexedAccessType(node) => node.register_with_map(map),
      TsType::TsInferType(node) => node.register_with_map(map),
      TsType::TsKeywordType(node) => node.register_with_map(map),
      TsType::TsLitType(node) => node.register_with_map(map),
      TsType::TsMappedType(node) => node.register_with_map(map),
      TsType::TsOptionalType(node) => node.register_with_map(map),
      TsType::TsParenthesizedType(node) => node.register_with_map(map),
      TsType::TsRestType(node) => node.register_with_map(map),
      TsType::TsThisType(node) => node.register_with_map(map),
      TsType::TsTupleType(node) => node.register_with_map(map),
      TsType::TsTypeLit(node) => node.register_with_map(map),
      TsType::TsTypeOperator(node) => node.register_with_map(map),
      TsType::TsTypePredicate(node) => node.register_with_map(map),
      TsType::TsTypeQuery(node) => node.register_with_map(map),
      TsType::TsTypeRef(node) => node.register_with_map(map),
      TsType::TsUnionOrIntersectionType(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      TsType::TsArrayType(node) => node.to_java_with_map(env, map),
      TsType::TsConditionalType(node) => node.to_java_with_map(env, map),
      TsType::TsFnOrConstructorType(node) => node.to_java_with_map(env, map),
      TsType::TsImportType(node) => node.to_java_with_map(env, map),
      TsType::TsIndexedAccessType(node) => node.to_java_with_map(env, map),
      TsType::TsInferType(node) => node.to_java_with_map(env, map),
      TsType::TsKeywordType(node) => node.to_java_with_map(env, map),
      TsType::TsLitType(node) => node.to_java_with_map(env, map),
      TsType::TsMappedType(node) => node.to_java_with_map(env, map),
      TsType::TsOptionalType(node) => node.to_java_with_map(env, map),
      TsType::TsParenthesizedType(node) => node.to_java_with_map(env, map),
      TsType::TsRestType(node) => node.to_java_with_map(env, map),
      TsType::TsThisType(node) => node.to_java_with_map(env, map),
      TsType::TsTupleType(node) => node.to_java_with_map(env, map),
      TsType::TsTypeLit(node) => node.to_java_with_map(env, map),
      TsType::TsTypeOperator(node) => node.to_java_with_map(env, map),
      TsType::TsTypePredicate(node) => node.to_java_with_map(env, map),
      TsType::TsTypeQuery(node) => node.to_java_with_map(env, map),
      TsType::TsTypeRef(node) => node.to_java_with_map(env, map),
      TsType::TsUnionOrIntersectionType(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for TsType {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_ARRAY_TYPE.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsType::TsArrayType(*TsArrayType::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_CONDITIONAL_TYPE.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsType::TsConditionalType(*TsConditionalType::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_FN_OR_CONSTRUCTOR_TYPE.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsType::TsFnOrConstructorType(*TsFnOrConstructorType::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_IMPORT_TYPE.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsType::TsImportType(*TsImportType::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_INDEXED_ACCESS_TYPE.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsType::TsIndexedAccessType(*TsIndexedAccessType::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_INFER_TYPE.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsType::TsInferType(*TsInferType::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_KEYWORD_TYPE.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsType::TsKeywordType(*TsKeywordType::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_LIT_TYPE.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsType::TsLitType(*TsLitType::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_MAPPED_TYPE.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsType::TsMappedType(*TsMappedType::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_OPTIONAL_TYPE.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsType::TsOptionalType(*TsOptionalType::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_PARENTHESIZED_TYPE.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsType::TsParenthesizedType(*TsParenthesizedType::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_REST_TYPE.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsType::TsRestType(*TsRestType::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_THIS_TYPE.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsType::TsThisType(*TsThisType::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_TUPLE_TYPE.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsType::TsTupleType(*TsTupleType::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_TYPE_LIT.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsType::TsTypeLit(*TsTypeLit::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_TYPE_OPERATOR.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsType::TsTypeOperator(*TsTypeOperator::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_TYPE_PREDICATE.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsType::TsTypePredicate(*TsTypePredicate::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_TYPE_QUERY.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsType::TsTypeQuery(*TsTypeQuery::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_TYPE_REF.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsType::TsTypeRef(*TsTypeRef::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_UNION_OR_INTERSECTION_TYPE.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsType::TsUnionOrIntersectionType(*TsUnionOrIntersectionType::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by TsType", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTypeElement {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      TsTypeElement::TsCallSignatureDecl(node) => node.register_with_map(map),
      TsTypeElement::TsConstructSignatureDecl(node) => node.register_with_map(map),
      TsTypeElement::TsGetterSignature(node) => node.register_with_map(map),
      TsTypeElement::TsIndexSignature(node) => node.register_with_map(map),
      TsTypeElement::TsMethodSignature(node) => node.register_with_map(map),
      TsTypeElement::TsPropertySignature(node) => node.register_with_map(map),
      TsTypeElement::TsSetterSignature(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTypeElement {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      TsTypeElement::TsCallSignatureDecl(node) => node.to_java_with_map(env, map),
      TsTypeElement::TsConstructSignatureDecl(node) => node.to_java_with_map(env, map),
      TsTypeElement::TsGetterSignature(node) => node.to_java_with_map(env, map),
      TsTypeElement::TsIndexSignature(node) => node.to_java_with_map(env, map),
      TsTypeElement::TsMethodSignature(node) => node.to_java_with_map(env, map),
      TsTypeElement::TsPropertySignature(node) => node.to_java_with_map(env, map),
      TsTypeElement::TsSetterSignature(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for TsTypeElement {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_CALL_SIGNATURE_DECL.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsTypeElement::TsCallSignatureDecl(*TsCallSignatureDecl::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_CONSTRUCT_SIGNATURE_DECL.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsTypeElement::TsConstructSignatureDecl(*TsConstructSignatureDecl::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_GETTER_SIGNATURE.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsTypeElement::TsGetterSignature(*TsGetterSignature::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_INDEX_SIGNATURE.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsTypeElement::TsIndexSignature(*TsIndexSignature::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_METHOD_SIGNATURE.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsTypeElement::TsMethodSignature(*TsMethodSignature::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_PROPERTY_SIGNATURE.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsTypeElement::TsPropertySignature(*TsPropertySignature::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_SETTER_SIGNATURE.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsTypeElement::TsSetterSignature(*TsSetterSignature::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by TsTypeElement", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTypeQueryExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      TsTypeQueryExpr::Import(node) => node.register_with_map(map),
      TsTypeQueryExpr::TsEntityName(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTypeQueryExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      TsTypeQueryExpr::Import(node) => node.to_java_with_map(env, map),
      TsTypeQueryExpr::TsEntityName(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for TsTypeQueryExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_IMPORT_TYPE.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsTypeQueryExpr::Import(*TsImportType::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_ENTITY_NAME.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsTypeQueryExpr::TsEntityName(*TsEntityName::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by TsTypeQueryExpr", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsUnionOrIntersectionType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      TsUnionOrIntersectionType::TsIntersectionType(node) => node.register_with_map(map),
      TsUnionOrIntersectionType::TsUnionType(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsUnionOrIntersectionType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      TsUnionOrIntersectionType::TsIntersectionType(node) => node.to_java_with_map(env, map),
      TsUnionOrIntersectionType::TsUnionType(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for TsUnionOrIntersectionType {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_INTERSECTION_TYPE.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsUnionOrIntersectionType::TsIntersectionType(*TsIntersectionType::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_TS_UNION_TYPE.as_ref().unwrap()}.class)).unwrap_or(false) {
        TsUnionOrIntersectionType::TsUnionType(*TsUnionType::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by TsUnionOrIntersectionType", ast_type);
      };
    Ok(Box::new(return_value))
  }
}

impl RegisterWithMap<ByteToIndexMap> for VarDeclOrExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    match self {
      VarDeclOrExpr::Expr(node) => node.register_with_map(map),
      VarDeclOrExpr::VarDecl(node) => node.register_with_map(map),
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for VarDeclOrExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    match self {
      VarDeclOrExpr::Expr(node) => node.to_java_with_map(env, map),
      VarDeclOrExpr::VarDecl(node) => node.to_java_with_map(env, map),
    }
  }
}

impl<'local> FromJava<'local> for VarDeclOrExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let return_value = 
      if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_EXPR.as_ref().unwrap()}.class)).unwrap_or(false) {
        VarDeclOrExpr::Expr(Expr::from_java(env, jobj)?)
      } else if env.is_instance_of(jobj, &(unsafe {JAVA_CLASS_VAR_DECL.as_ref().unwrap()}.class)).unwrap_or(false) {
        VarDeclOrExpr::VarDecl(VarDecl::from_java(env, jobj)?)
      } else {
        let java_ast_type = unsafe { JAVA_CLASS_.as_ref().unwrap() }.get_type(env, jobj)?;
        let ast_type = AstType::from_java(env, &java_ast_type);
        delete_local_ref!(env, java_ast_type);
        panic!("Type {:?} is not supported by VarDeclOrExpr", ast_type);
      };
    Ok(Box::new(return_value))
  }
}
/* Enum End */

/* AST Begin */
impl RegisterWithMap<ByteToIndexMap> for ArrayLit {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.elems.iter() {
      node.as_ref().map(|node| node.register_with_map(map));
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ArrayLit {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_elems = list_new(env, self.elems.len())?;
    for node in self.elems.iter() {
      let java_node = match node.as_ref() {
        Some(node) => node.to_java_with_map(env, map)?,
        None => Default::default(),
      };
      list_add(env, &java_elems, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let return_value = unsafe { JAVA_CLASS_ARRAY_LIT.as_ref().unwrap() }
      .construct(env, &java_elems, &java_span_ex)?;
    delete_local_ref!(env, java_elems);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ArrayLit {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_ARRAY_LIT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_elems = java_class.get_elems(env, jobj)?;
    let length = list_size(env, &java_elems)?;
    let mut elems: Vec<Option<ExprOrSpread>> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_elems, i)?;
      let element = if optional_is_present(env, &java_item)? {
        let java_inner_item = optional_get(env, &java_item)?;
        let element = *ExprOrSpread::from_java(env, &java_inner_item)?;
        delete_local_ref!(env, java_inner_item);
        Some(element)
      } else {
        None
      };
      delete_local_ref!(env, java_item);
      elems.push(element)
    }
    Ok(Box::new(ArrayLit {
      span,
      elems,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ArrayPat {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.elems.iter() {
      node.as_ref().map(|node| node.register_with_map(map));
    }
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ArrayPat {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_elems = list_new(env, self.elems.len())?;
    for node in self.elems.iter() {
      let java_node = match node.as_ref() {
        Some(node) => node.to_java_with_map(env, map)?,
        None => Default::default(),
      };
      list_add(env, &java_elems, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let optional = self.optional;
    let java_optional_type_ann = match self.type_ann.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_ARRAY_PAT.as_ref().unwrap() }
      .construct(env, &java_elems, optional, &java_optional_type_ann, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_ref!(env, java_elems);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ArrayPat {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_ARRAY_PAT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_elems = java_class.get_elems(env, jobj)?;
    let length = list_size(env, &java_elems)?;
    let mut elems: Vec<Option<Pat>> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_elems, i)?;
      let element = if optional_is_present(env, &java_item)? {
        let java_inner_item = optional_get(env, &java_item)?;
        let element = *Pat::from_java(env, &java_inner_item)?;
        delete_local_ref!(env, java_inner_item);
        Some(element)
      } else {
        None
      };
      delete_local_ref!(env, java_item);
      elems.push(element)
    }
    let optional = java_class.is_optional(env, jobj)?;
    let java_optional_type_ann = java_class.get_type_ann(env, jobj)?;
    let type_ann = if optional_is_present(env, &java_optional_type_ann)? {
      let java_type_ann = optional_get(env, &java_optional_type_ann)?;
      let type_ann = *TsTypeAnn::from_java(env, &java_type_ann)?;
      delete_local_ref!(env, java_type_ann);
      Some(type_ann)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_ann);
    let type_ann = type_ann.map(|type_ann| Box::new(type_ann));
    Ok(Box::new(ArrayPat {
      span,
      elems,
      optional,
      type_ann,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ArrowExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.params.iter() {
      node.register_with_map(map);
    }
    self.body.register_with_map(map);
    self.type_params.as_ref().map(|node| node.register_with_map(map));
    self.return_type.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ArrowExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let ctxt = self.ctxt;
    let java_params = list_new(env, self.params.len())?;
    for node in self.params.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_params, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let java_body = self.body.to_java_with_map(env, map)?;
    let is_async = self.is_async;
    let is_generator = self.is_generator;
    let java_optional_type_params = match self.type_params.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_optional_return_type = match self.return_type.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_ARROW_EXPR.as_ref().unwrap() }
      .construct(env, ctxt, &java_params, &java_body, is_async, is_generator, &java_optional_type_params, &java_optional_return_type, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_type_params);
    delete_local_optional_ref!(env, java_optional_return_type);
    delete_local_ref!(env, java_params);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ArrowExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_ARROW_EXPR.as_ref().unwrap() };
    let span = DUMMY_SP;
    let ctxt = java_class.get_ctxt(env, jobj)?;
    let ctxt = SyntaxContext::from_u32(ctxt as u32);
    let java_params = java_class.get_params(env, jobj)?;
    let length = list_size(env, &java_params)?;
    let mut params: Vec<Pat> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_params, i)?;
      let element = *Pat::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      params.push(element)
    }
    let java_body = java_class.get_body(env, jobj)?;
    let body = *BlockStmtOrExpr::from_java(env, &java_body)?;
    delete_local_ref!(env, java_body);
    let body = Box::new(body);
    let is_async = java_class.is_async(env, jobj)?;
    let is_generator = java_class.is_generator(env, jobj)?;
    let java_optional_type_params = java_class.get_type_params(env, jobj)?;
    let type_params = if optional_is_present(env, &java_optional_type_params)? {
      let java_type_params = optional_get(env, &java_optional_type_params)?;
      let type_params = *TsTypeParamDecl::from_java(env, &java_type_params)?;
      delete_local_ref!(env, java_type_params);
      Some(type_params)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_params);
    let type_params = type_params.map(|type_params| Box::new(type_params));
    let java_optional_return_type = java_class.get_return_type(env, jobj)?;
    let return_type = if optional_is_present(env, &java_optional_return_type)? {
      let java_return_type = optional_get(env, &java_optional_return_type)?;
      let return_type = *TsTypeAnn::from_java(env, &java_return_type)?;
      delete_local_ref!(env, java_return_type);
      Some(return_type)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_return_type);
    let return_type = return_type.map(|return_type| Box::new(return_type));
    Ok(Box::new(ArrowExpr {
      span,
      ctxt,
      params,
      body,
      is_async,
      is_generator,
      type_params,
      return_type,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for AssignExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.left.register_with_map(map);
    self.right.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for AssignExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_op = self.op.to_java(env)?;
    let java_left = self.left.to_java_with_map(env, map)?;
    let java_right = self.right.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_ASSIGN_EXPR.as_ref().unwrap() }
      .construct(env, &java_op, &java_left, &java_right, &java_span_ex)?;
    delete_local_ref!(env, java_op);
    delete_local_ref!(env, java_left);
    delete_local_ref!(env, java_right);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for AssignExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_ASSIGN_EXPR.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_op = java_class.get_op(env, jobj)?;
    let op = *AssignOp::from_java(env, &java_op)?;
    delete_local_ref!(env, java_op);
    let java_left = java_class.get_left(env, jobj)?;
    let left = *AssignTarget::from_java(env, &java_left)?;
    delete_local_ref!(env, java_left);
    let java_right = java_class.get_right(env, jobj)?;
    let right = *Expr::from_java(env, &java_right)?;
    delete_local_ref!(env, java_right);
    let right = Box::new(right);
    Ok(Box::new(AssignExpr {
      span,
      op,
      left,
      right,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for AssignPat {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.left.register_with_map(map);
    self.right.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for AssignPat {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_left = self.left.to_java_with_map(env, map)?;
    let java_right = self.right.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_ASSIGN_PAT.as_ref().unwrap() }
      .construct(env, &java_left, &java_right, &java_span_ex)?;
    delete_local_ref!(env, java_left);
    delete_local_ref!(env, java_right);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for AssignPat {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_ASSIGN_PAT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_left = java_class.get_left(env, jobj)?;
    let left = *Pat::from_java(env, &java_left)?;
    delete_local_ref!(env, java_left);
    let left = Box::new(left);
    let java_right = java_class.get_right(env, jobj)?;
    let right = *Expr::from_java(env, &java_right)?;
    delete_local_ref!(env, java_right);
    let right = Box::new(right);
    Ok(Box::new(AssignPat {
      span,
      left,
      right,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for AssignPatProp {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.key.register_with_map(map);
    self.value.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for AssignPatProp {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_key = self.key.to_java_with_map(env, map)?;
    let java_optional_value = match self.value.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_ASSIGN_PAT_PROP.as_ref().unwrap() }
      .construct(env, &java_key, &java_optional_value, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_value);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for AssignPatProp {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_ASSIGN_PAT_PROP.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_key = java_class.get_key(env, jobj)?;
    let key = *BindingIdent::from_java(env, &java_key)?;
    delete_local_ref!(env, java_key);
    let java_optional_value = java_class.get_value(env, jobj)?;
    let value = if optional_is_present(env, &java_optional_value)? {
      let java_value = optional_get(env, &java_optional_value)?;
      let value = *Expr::from_java(env, &java_value)?;
      delete_local_ref!(env, java_value);
      Some(value)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_value);
    let value = value.map(|value| Box::new(value));
    Ok(Box::new(AssignPatProp {
      span,
      key,
      value,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for AssignProp {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.key.register_with_map(map);
    self.value.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for AssignProp {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_key = self.key.to_java_with_map(env, map)?;
    let java_value = self.value.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_ASSIGN_PROP.as_ref().unwrap() }
      .construct(env, &java_key, &java_value, &java_span_ex)?;
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_value);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for AssignProp {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_ASSIGN_PROP.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_key = java_class.get_key(env, jobj)?;
    let key = *Ident::from_java(env, &java_key)?;
    delete_local_ref!(env, java_key);
    let java_value = java_class.get_value(env, jobj)?;
    let value = *Expr::from_java(env, &java_value)?;
    delete_local_ref!(env, java_value);
    let value = Box::new(value);
    Ok(Box::new(AssignProp {
      span,
      key,
      value,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for AutoAccessor {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.key.register_with_map(map);
    self.value.as_ref().map(|node| node.register_with_map(map));
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
    for node in self.decorators.iter() {
      node.register_with_map(map);
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for AutoAccessor {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_key = self.key.to_java_with_map(env, map)?;
    let java_optional_value = match self.value.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_optional_type_ann = match self.type_ann.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let is_static = self.is_static;
    let java_decorators = list_new(env, self.decorators.len())?;
    for node in self.decorators.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_decorators, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let java_optional_accessibility = match self.accessibility.as_ref() {
      Some(node) => Some(node.to_java(env)?),
      None => None,
    };
    let is_abstract = self.is_abstract;
    let is_override = self.is_override;
    let definite = self.definite;
    let return_value = unsafe { JAVA_CLASS_AUTO_ACCESSOR.as_ref().unwrap() }
      .construct(env, &java_key, &java_optional_value, &java_optional_type_ann, is_static, &java_decorators, &java_optional_accessibility, is_abstract, is_override, definite, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_value);
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_optional_ref!(env, java_optional_accessibility);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_decorators);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for AutoAccessor {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_AUTO_ACCESSOR.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_key = java_class.get_key(env, jobj)?;
    let key = *Key::from_java(env, &java_key)?;
    delete_local_ref!(env, java_key);
    let java_optional_value = java_class.get_value(env, jobj)?;
    let value = if optional_is_present(env, &java_optional_value)? {
      let java_value = optional_get(env, &java_optional_value)?;
      let value = *Expr::from_java(env, &java_value)?;
      delete_local_ref!(env, java_value);
      Some(value)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_value);
    let value = value.map(|value| Box::new(value));
    let java_optional_type_ann = java_class.get_type_ann(env, jobj)?;
    let type_ann = if optional_is_present(env, &java_optional_type_ann)? {
      let java_type_ann = optional_get(env, &java_optional_type_ann)?;
      let type_ann = *TsTypeAnn::from_java(env, &java_type_ann)?;
      delete_local_ref!(env, java_type_ann);
      Some(type_ann)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_ann);
    let type_ann = type_ann.map(|type_ann| Box::new(type_ann));
    let is_static = java_class.is_static(env, jobj)?;
    let java_decorators = java_class.get_decorators(env, jobj)?;
    let length = list_size(env, &java_decorators)?;
    let mut decorators: Vec<Decorator> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_decorators, i)?;
      let element = *Decorator::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      decorators.push(element)
    }
    let java_optional_accessibility = java_class.get_accessibility(env, jobj)?;
    let accessibility = if optional_is_present(env, &java_optional_accessibility)? {
      let java_accessibility = optional_get(env, &java_optional_accessibility)?;
      let accessibility = *Accessibility::from_java(env, &java_accessibility)?;
      delete_local_ref!(env, java_accessibility);
      Some(accessibility)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_accessibility);
    let is_abstract = java_class.is_abstract(env, jobj)?;
    let is_override = java_class.is_override(env, jobj)?;
    let definite = java_class.is_definite(env, jobj)?;
    Ok(Box::new(AutoAccessor {
      span,
      key,
      value,
      type_ann,
      is_static,
      decorators,
      accessibility,
      is_abstract,
      is_override,
      definite,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for AwaitExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.arg.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for AwaitExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_arg = self.arg.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_AWAIT_EXPR.as_ref().unwrap() }
      .construct(env, &java_arg, &java_span_ex)?;
    delete_local_ref!(env, java_arg);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for AwaitExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_AWAIT_EXPR.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_arg = java_class.get_arg(env, jobj)?;
    let arg = *Expr::from_java(env, &java_arg)?;
    delete_local_ref!(env, java_arg);
    let arg = Box::new(arg);
    Ok(Box::new(AwaitExpr {
      span,
      arg,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for BigInt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl RegisterWithMap<ByteToIndexMap> for BinExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.left.register_with_map(map);
    self.right.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for BinExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_op = self.op.to_java(env)?;
    let java_left = self.left.to_java_with_map(env, map)?;
    let java_right = self.right.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_BIN_EXPR.as_ref().unwrap() }
      .construct(env, &java_op, &java_left, &java_right, &java_span_ex)?;
    delete_local_ref!(env, java_op);
    delete_local_ref!(env, java_left);
    delete_local_ref!(env, java_right);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for BinExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_BIN_EXPR.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_op = java_class.get_op(env, jobj)?;
    let op = *BinaryOp::from_java(env, &java_op)?;
    delete_local_ref!(env, java_op);
    let java_left = java_class.get_left(env, jobj)?;
    let left = *Expr::from_java(env, &java_left)?;
    delete_local_ref!(env, java_left);
    let left = Box::new(left);
    let java_right = java_class.get_right(env, jobj)?;
    let right = *Expr::from_java(env, &java_right)?;
    delete_local_ref!(env, java_right);
    let right = Box::new(right);
    Ok(Box::new(BinExpr {
      span,
      op,
      left,
      right,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for BindingIdent {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span());
    self.id.register_with_map(map);
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
  }
}

impl<'local> FromJava<'local> for BindingIdent {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_BINDING_IDENT.as_ref().unwrap() };
    let java_id = java_class.get_id(env, jobj)?;
    let id = *Ident::from_java(env, &java_id)?;
    delete_local_ref!(env, java_id);
    let java_optional_type_ann = java_class.get_type_ann(env, jobj)?;
    let type_ann = if optional_is_present(env, &java_optional_type_ann)? {
      let java_type_ann = optional_get(env, &java_optional_type_ann)?;
      let type_ann = *TsTypeAnn::from_java(env, &java_type_ann)?;
      delete_local_ref!(env, java_type_ann);
      Some(type_ann)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_ann);
    let type_ann = type_ann.map(|type_ann| Box::new(type_ann));
    Ok(Box::new(BindingIdent {
      id,
      type_ann,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for BlockStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.stmts.iter() {
      node.register_with_map(map);
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for BlockStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let ctxt = self.ctxt;
    let java_stmts = list_new(env, self.stmts.len())?;
    for node in self.stmts.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_stmts, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let return_value = unsafe { JAVA_CLASS_BLOCK_STMT.as_ref().unwrap() }
      .construct(env, ctxt, &java_stmts, &java_span_ex)?;
    delete_local_ref!(env, java_stmts);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for BlockStmt {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_BLOCK_STMT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let ctxt = java_class.get_ctxt(env, jobj)?;
    let ctxt = SyntaxContext::from_u32(ctxt as u32);
    let java_stmts = java_class.get_stmts(env, jobj)?;
    let length = list_size(env, &java_stmts)?;
    let mut stmts: Vec<Stmt> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_stmts, i)?;
      let element = *Stmt::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      stmts.push(element)
    }
    Ok(Box::new(BlockStmt {
      span,
      ctxt,
      stmts,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for Bool {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Bool {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let value = self.value;
    let return_value = unsafe { JAVA_CLASS_BOOL.as_ref().unwrap() }
      .construct(env, value, &java_span_ex)?;
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for Bool {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_BOOL.as_ref().unwrap() };
    let span = DUMMY_SP;
    let value = java_class.is_value(env, jobj)?;
    Ok(Box::new(Bool {
      span,
      value,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for BreakStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.label.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for BreakStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_optional_label = match self.label.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_BREAK_STMT.as_ref().unwrap() }
      .construct(env, &java_optional_label, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_label);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for BreakStmt {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_BREAK_STMT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_optional_label = java_class.get_label(env, jobj)?;
    let label = if optional_is_present(env, &java_optional_label)? {
      let java_label = optional_get(env, &java_optional_label)?;
      let label = *Ident::from_java(env, &java_label)?;
      delete_local_ref!(env, java_label);
      Some(label)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_label);
    Ok(Box::new(BreakStmt {
      span,
      label,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for CallExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.callee.register_with_map(map);
    for node in self.args.iter() {
      node.register_with_map(map);
    }
    self.type_args.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for CallExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let ctxt = self.ctxt;
    let java_callee = self.callee.to_java_with_map(env, map)?;
    let java_args = list_new(env, self.args.len())?;
    for node in self.args.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_args, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let java_optional_type_args = match self.type_args.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_CALL_EXPR.as_ref().unwrap() }
      .construct(env, ctxt, &java_callee, &java_args, &java_optional_type_args, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_type_args);
    delete_local_ref!(env, java_callee);
    delete_local_ref!(env, java_args);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for CallExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_CALL_EXPR.as_ref().unwrap() };
    let span = DUMMY_SP;
    let ctxt = java_class.get_ctxt(env, jobj)?;
    let ctxt = SyntaxContext::from_u32(ctxt as u32);
    let java_callee = java_class.get_callee(env, jobj)?;
    let callee = *Callee::from_java(env, &java_callee)?;
    delete_local_ref!(env, java_callee);
    let java_args = java_class.get_args(env, jobj)?;
    let length = list_size(env, &java_args)?;
    let mut args: Vec<ExprOrSpread> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_args, i)?;
      let element = *ExprOrSpread::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      args.push(element)
    }
    let java_optional_type_args = java_class.get_type_args(env, jobj)?;
    let type_args = if optional_is_present(env, &java_optional_type_args)? {
      let java_type_args = optional_get(env, &java_optional_type_args)?;
      let type_args = *TsTypeParamInstantiation::from_java(env, &java_type_args)?;
      delete_local_ref!(env, java_type_args);
      Some(type_args)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_args);
    let type_args = type_args.map(|type_args| Box::new(type_args));
    Ok(Box::new(CallExpr {
      span,
      ctxt,
      callee,
      args,
      type_args,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for CatchClause {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.param.as_ref().map(|node| node.register_with_map(map));
    self.body.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for CatchClause {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_optional_param = match self.param.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_body = self.body.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_CATCH_CLAUSE.as_ref().unwrap() }
      .construct(env, &java_optional_param, &java_body, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_param);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for CatchClause {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_CATCH_CLAUSE.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_optional_param = java_class.get_param(env, jobj)?;
    let param = if optional_is_present(env, &java_optional_param)? {
      let java_param = optional_get(env, &java_optional_param)?;
      let param = *Pat::from_java(env, &java_param)?;
      delete_local_ref!(env, java_param);
      Some(param)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_param);
    let java_body = java_class.get_body(env, jobj)?;
    let body = *BlockStmt::from_java(env, &java_body)?;
    delete_local_ref!(env, java_body);
    Ok(Box::new(CatchClause {
      span,
      param,
      body,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for Class {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.decorators.iter() {
      node.register_with_map(map);
    }
    for node in self.body.iter() {
      node.register_with_map(map);
    }
    self.super_class.as_ref().map(|node| node.register_with_map(map));
    self.type_params.as_ref().map(|node| node.register_with_map(map));
    self.super_type_params.as_ref().map(|node| node.register_with_map(map));
    for node in self.implements.iter() {
      node.register_with_map(map);
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Class {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let ctxt = self.ctxt;
    let java_decorators = list_new(env, self.decorators.len())?;
    for node in self.decorators.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_decorators, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let java_body = list_new(env, self.body.len())?;
    for node in self.body.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_body, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let java_optional_super_class = match self.super_class.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let is_abstract = self.is_abstract;
    let java_optional_type_params = match self.type_params.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_optional_super_type_params = match self.super_type_params.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_implements = list_new(env, self.implements.len())?;
    for node in self.implements.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_implements, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let return_value = unsafe { JAVA_CLASS_CLASS.as_ref().unwrap() }
      .construct(env, ctxt, &java_decorators, &java_body, &java_optional_super_class, is_abstract, &java_optional_type_params, &java_optional_super_type_params, &java_implements, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_super_class);
    delete_local_optional_ref!(env, java_optional_type_params);
    delete_local_optional_ref!(env, java_optional_super_type_params);
    delete_local_ref!(env, java_decorators);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_implements);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for Class {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_CLASS.as_ref().unwrap() };
    let span = DUMMY_SP;
    let ctxt = java_class.get_ctxt(env, jobj)?;
    let ctxt = SyntaxContext::from_u32(ctxt as u32);
    let java_decorators = java_class.get_decorators(env, jobj)?;
    let length = list_size(env, &java_decorators)?;
    let mut decorators: Vec<Decorator> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_decorators, i)?;
      let element = *Decorator::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      decorators.push(element)
    }
    let java_body = java_class.get_body(env, jobj)?;
    let length = list_size(env, &java_body)?;
    let mut body: Vec<ClassMember> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_body, i)?;
      let element = *ClassMember::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      body.push(element)
    }
    let java_optional_super_class = java_class.get_super_class(env, jobj)?;
    let super_class = if optional_is_present(env, &java_optional_super_class)? {
      let java_super_class = optional_get(env, &java_optional_super_class)?;
      let super_class = *Expr::from_java(env, &java_super_class)?;
      delete_local_ref!(env, java_super_class);
      Some(super_class)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_super_class);
    let super_class = super_class.map(|super_class| Box::new(super_class));
    let is_abstract = java_class.is_abstract(env, jobj)?;
    let java_optional_type_params = java_class.get_type_params(env, jobj)?;
    let type_params = if optional_is_present(env, &java_optional_type_params)? {
      let java_type_params = optional_get(env, &java_optional_type_params)?;
      let type_params = *TsTypeParamDecl::from_java(env, &java_type_params)?;
      delete_local_ref!(env, java_type_params);
      Some(type_params)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_params);
    let type_params = type_params.map(|type_params| Box::new(type_params));
    let java_optional_super_type_params = java_class.get_super_type_params(env, jobj)?;
    let super_type_params = if optional_is_present(env, &java_optional_super_type_params)? {
      let java_super_type_params = optional_get(env, &java_optional_super_type_params)?;
      let super_type_params = *TsTypeParamInstantiation::from_java(env, &java_super_type_params)?;
      delete_local_ref!(env, java_super_type_params);
      Some(super_type_params)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_super_type_params);
    let super_type_params = super_type_params.map(|super_type_params| Box::new(super_type_params));
    let java_implements = java_class.get_implements(env, jobj)?;
    let length = list_size(env, &java_implements)?;
    let mut implements: Vec<TsExprWithTypeArgs> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_implements, i)?;
      let element = *TsExprWithTypeArgs::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      implements.push(element)
    }
    Ok(Box::new(Class {
      span,
      ctxt,
      decorators,
      body,
      super_class,
      is_abstract,
      type_params,
      super_type_params,
      implements,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ClassDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span());
    self.ident.register_with_map(map);
    self.class.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ClassDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span()).to_java(env)?;
    let java_ident = self.ident.to_java_with_map(env, map)?;
    let declare = self.declare;
    let java_class = self.class.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_CLASS_DECL.as_ref().unwrap() }
      .construct(env, &java_ident, declare, &java_class, &java_span_ex)?;
    delete_local_ref!(env, java_ident);
    delete_local_ref!(env, java_class);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ClassDecl {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_CLASS_DECL.as_ref().unwrap() };
    let java_ident = java_class.get_ident(env, jobj)?;
    let ident = *Ident::from_java(env, &java_ident)?;
    delete_local_ref!(env, java_ident);
    let declare = java_class.is_declare(env, jobj)?;
    let java_class = java_class.get_clazz(env, jobj)?;
    let class = *Class::from_java(env, &java_class)?;
    delete_local_ref!(env, java_class);
    let class = Box::new(class);
    Ok(Box::new(ClassDecl {
      ident,
      declare,
      class,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ClassExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span());
    self.ident.as_ref().map(|node| node.register_with_map(map));
    self.class.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ClassExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span()).to_java(env)?;
    let java_optional_ident = match self.ident.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_class = self.class.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_CLASS_EXPR.as_ref().unwrap() }
      .construct(env, &java_optional_ident, &java_class, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_ident);
    delete_local_ref!(env, java_class);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ClassExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_CLASS_EXPR.as_ref().unwrap() };
    let java_optional_ident = java_class.get_ident(env, jobj)?;
    let ident = if optional_is_present(env, &java_optional_ident)? {
      let java_ident = optional_get(env, &java_optional_ident)?;
      let ident = *Ident::from_java(env, &java_ident)?;
      delete_local_ref!(env, java_ident);
      Some(ident)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_ident);
    let java_class = java_class.get_clazz(env, jobj)?;
    let class = *Class::from_java(env, &java_class)?;
    delete_local_ref!(env, java_class);
    let class = Box::new(class);
    Ok(Box::new(ClassExpr {
      ident,
      class,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ClassMethod {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.key.register_with_map(map);
    self.function.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ClassMethod {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_key = self.key.to_java_with_map(env, map)?;
    let java_function = self.function.to_java_with_map(env, map)?;
    let java_kind = self.kind.to_java(env)?;
    let is_static = self.is_static;
    let java_optional_accessibility = match self.accessibility.as_ref() {
      Some(node) => Some(node.to_java(env)?),
      None => None,
    };
    let is_abstract = self.is_abstract;
    let is_optional = self.is_optional;
    let is_override = self.is_override;
    let return_value = unsafe { JAVA_CLASS_CLASS_METHOD.as_ref().unwrap() }
      .construct(env, &java_key, &java_function, &java_kind, is_static, &java_optional_accessibility, is_abstract, is_optional, is_override, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_accessibility);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_function);
    delete_local_ref!(env, java_kind);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ClassMethod {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_CLASS_METHOD.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_key = java_class.get_key(env, jobj)?;
    let key = *PropName::from_java(env, &java_key)?;
    delete_local_ref!(env, java_key);
    let java_function = java_class.get_function(env, jobj)?;
    let function = *Function::from_java(env, &java_function)?;
    delete_local_ref!(env, java_function);
    let function = Box::new(function);
    let java_kind = java_class.get_kind(env, jobj)?;
    let kind = *MethodKind::from_java(env, &java_kind)?;
    delete_local_ref!(env, java_kind);
    let is_static = java_class.is_static(env, jobj)?;
    let java_optional_accessibility = java_class.get_accessibility(env, jobj)?;
    let accessibility = if optional_is_present(env, &java_optional_accessibility)? {
      let java_accessibility = optional_get(env, &java_optional_accessibility)?;
      let accessibility = *Accessibility::from_java(env, &java_accessibility)?;
      delete_local_ref!(env, java_accessibility);
      Some(accessibility)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_accessibility);
    let is_abstract = java_class.is_abstract(env, jobj)?;
    let is_optional = java_class.is_optional(env, jobj)?;
    let is_override = java_class.is_override(env, jobj)?;
    Ok(Box::new(ClassMethod {
      span,
      key,
      function,
      kind,
      is_static,
      accessibility,
      is_abstract,
      is_optional,
      is_override,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ClassProp {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.key.register_with_map(map);
    self.value.as_ref().map(|node| node.register_with_map(map));
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
    for node in self.decorators.iter() {
      node.register_with_map(map);
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ClassProp {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_key = self.key.to_java_with_map(env, map)?;
    let java_optional_value = match self.value.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_optional_type_ann = match self.type_ann.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let is_static = self.is_static;
    let java_decorators = list_new(env, self.decorators.len())?;
    for node in self.decorators.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_decorators, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let java_optional_accessibility = match self.accessibility.as_ref() {
      Some(node) => Some(node.to_java(env)?),
      None => None,
    };
    let is_abstract = self.is_abstract;
    let is_optional = self.is_optional;
    let is_override = self.is_override;
    let readonly = self.readonly;
    let declare = self.declare;
    let definite = self.definite;
    let return_value = unsafe { JAVA_CLASS_CLASS_PROP.as_ref().unwrap() }
      .construct(env, &java_key, &java_optional_value, &java_optional_type_ann, is_static, &java_decorators, &java_optional_accessibility, is_abstract, is_optional, is_override, readonly, declare, definite, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_value);
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_optional_ref!(env, java_optional_accessibility);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_decorators);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ClassProp {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_CLASS_PROP.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_key = java_class.get_key(env, jobj)?;
    let key = *PropName::from_java(env, &java_key)?;
    delete_local_ref!(env, java_key);
    let java_optional_value = java_class.get_value(env, jobj)?;
    let value = if optional_is_present(env, &java_optional_value)? {
      let java_value = optional_get(env, &java_optional_value)?;
      let value = *Expr::from_java(env, &java_value)?;
      delete_local_ref!(env, java_value);
      Some(value)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_value);
    let value = value.map(|value| Box::new(value));
    let java_optional_type_ann = java_class.get_type_ann(env, jobj)?;
    let type_ann = if optional_is_present(env, &java_optional_type_ann)? {
      let java_type_ann = optional_get(env, &java_optional_type_ann)?;
      let type_ann = *TsTypeAnn::from_java(env, &java_type_ann)?;
      delete_local_ref!(env, java_type_ann);
      Some(type_ann)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_ann);
    let type_ann = type_ann.map(|type_ann| Box::new(type_ann));
    let is_static = java_class.is_static(env, jobj)?;
    let java_decorators = java_class.get_decorators(env, jobj)?;
    let length = list_size(env, &java_decorators)?;
    let mut decorators: Vec<Decorator> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_decorators, i)?;
      let element = *Decorator::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      decorators.push(element)
    }
    let java_optional_accessibility = java_class.get_accessibility(env, jobj)?;
    let accessibility = if optional_is_present(env, &java_optional_accessibility)? {
      let java_accessibility = optional_get(env, &java_optional_accessibility)?;
      let accessibility = *Accessibility::from_java(env, &java_accessibility)?;
      delete_local_ref!(env, java_accessibility);
      Some(accessibility)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_accessibility);
    let is_abstract = java_class.is_abstract(env, jobj)?;
    let is_optional = java_class.is_optional(env, jobj)?;
    let is_override = java_class.is_override(env, jobj)?;
    let readonly = java_class.is_readonly(env, jobj)?;
    let declare = java_class.is_declare(env, jobj)?;
    let definite = java_class.is_definite(env, jobj)?;
    Ok(Box::new(ClassProp {
      span,
      key,
      value,
      type_ann,
      is_static,
      decorators,
      accessibility,
      is_abstract,
      is_optional,
      is_override,
      readonly,
      declare,
      definite,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ComputedPropName {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ComputedPropName {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_expr = self.expr.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_COMPUTED_PROP_NAME.as_ref().unwrap() }
      .construct(env, &java_expr, &java_span_ex)?;
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ComputedPropName {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_COMPUTED_PROP_NAME.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_expr = java_class.get_expr(env, jobj)?;
    let expr = *Expr::from_java(env, &java_expr)?;
    delete_local_ref!(env, java_expr);
    let expr = Box::new(expr);
    Ok(Box::new(ComputedPropName {
      span,
      expr,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for CondExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.test.register_with_map(map);
    self.cons.register_with_map(map);
    self.alt.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for CondExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_test = self.test.to_java_with_map(env, map)?;
    let java_cons = self.cons.to_java_with_map(env, map)?;
    let java_alt = self.alt.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_COND_EXPR.as_ref().unwrap() }
      .construct(env, &java_test, &java_cons, &java_alt, &java_span_ex)?;
    delete_local_ref!(env, java_test);
    delete_local_ref!(env, java_cons);
    delete_local_ref!(env, java_alt);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for CondExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_COND_EXPR.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_test = java_class.get_test(env, jobj)?;
    let test = *Expr::from_java(env, &java_test)?;
    delete_local_ref!(env, java_test);
    let test = Box::new(test);
    let java_cons = java_class.get_cons(env, jobj)?;
    let cons = *Expr::from_java(env, &java_cons)?;
    delete_local_ref!(env, java_cons);
    let cons = Box::new(cons);
    let java_alt = java_class.get_alt(env, jobj)?;
    let alt = *Expr::from_java(env, &java_alt)?;
    delete_local_ref!(env, java_alt);
    let alt = Box::new(alt);
    Ok(Box::new(CondExpr {
      span,
      test,
      cons,
      alt,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for Constructor {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.key.register_with_map(map);
    for node in self.params.iter() {
      node.register_with_map(map);
    }
    self.body.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Constructor {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let ctxt = self.ctxt;
    let java_key = self.key.to_java_with_map(env, map)?;
    let java_params = list_new(env, self.params.len())?;
    for node in self.params.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_params, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let java_optional_body = match self.body.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_optional_accessibility = match self.accessibility.as_ref() {
      Some(node) => Some(node.to_java(env)?),
      None => None,
    };
    let is_optional = self.is_optional;
    let return_value = unsafe { JAVA_CLASS_CONSTRUCTOR.as_ref().unwrap() }
      .construct(env, ctxt, &java_key, &java_params, &java_optional_body, &java_optional_accessibility, is_optional, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_body);
    delete_local_optional_ref!(env, java_optional_accessibility);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_params);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for Constructor {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_CONSTRUCTOR.as_ref().unwrap() };
    let span = DUMMY_SP;
    let ctxt = java_class.get_ctxt(env, jobj)?;
    let ctxt = SyntaxContext::from_u32(ctxt as u32);
    let java_key = java_class.get_key(env, jobj)?;
    let key = *PropName::from_java(env, &java_key)?;
    delete_local_ref!(env, java_key);
    let java_params = java_class.get_params(env, jobj)?;
    let length = list_size(env, &java_params)?;
    let mut params: Vec<ParamOrTsParamProp> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_params, i)?;
      let element = *ParamOrTsParamProp::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      params.push(element)
    }
    let java_optional_body = java_class.get_body(env, jobj)?;
    let body = if optional_is_present(env, &java_optional_body)? {
      let java_body = optional_get(env, &java_optional_body)?;
      let body = *BlockStmt::from_java(env, &java_body)?;
      delete_local_ref!(env, java_body);
      Some(body)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_body);
    let java_optional_accessibility = java_class.get_accessibility(env, jobj)?;
    let accessibility = if optional_is_present(env, &java_optional_accessibility)? {
      let java_accessibility = optional_get(env, &java_optional_accessibility)?;
      let accessibility = *Accessibility::from_java(env, &java_accessibility)?;
      delete_local_ref!(env, java_accessibility);
      Some(accessibility)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_accessibility);
    let is_optional = java_class.is_optional(env, jobj)?;
    Ok(Box::new(Constructor {
      span,
      ctxt,
      key,
      params,
      body,
      accessibility,
      is_optional,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ContinueStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.label.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ContinueStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_optional_label = match self.label.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_CONTINUE_STMT.as_ref().unwrap() }
      .construct(env, &java_optional_label, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_label);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ContinueStmt {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_CONTINUE_STMT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_optional_label = java_class.get_label(env, jobj)?;
    let label = if optional_is_present(env, &java_optional_label)? {
      let java_label = optional_get(env, &java_optional_label)?;
      let label = *Ident::from_java(env, &java_label)?;
      delete_local_ref!(env, java_label);
      Some(label)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_label);
    Ok(Box::new(ContinueStmt {
      span,
      label,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for DebuggerStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for DebuggerStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let return_value = unsafe { JAVA_CLASS_DEBUGGER_STMT.as_ref().unwrap() }
      .construct(env, &java_span_ex)?;
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for DebuggerStmt {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let span = DUMMY_SP;
    Ok(Box::new(DebuggerStmt {
      span,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for Decorator {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Decorator {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_expr = self.expr.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_DECORATOR.as_ref().unwrap() }
      .construct(env, &java_expr, &java_span_ex)?;
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for Decorator {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_DECORATOR.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_expr = java_class.get_expr(env, jobj)?;
    let expr = *Expr::from_java(env, &java_expr)?;
    delete_local_ref!(env, java_expr);
    let expr = Box::new(expr);
    Ok(Box::new(Decorator {
      span,
      expr,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for DoWhileStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.test.register_with_map(map);
    self.body.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for DoWhileStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_test = self.test.to_java_with_map(env, map)?;
    let java_body = self.body.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_DO_WHILE_STMT.as_ref().unwrap() }
      .construct(env, &java_test, &java_body, &java_span_ex)?;
    delete_local_ref!(env, java_test);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for DoWhileStmt {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_DO_WHILE_STMT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_test = java_class.get_test(env, jobj)?;
    let test = *Expr::from_java(env, &java_test)?;
    delete_local_ref!(env, java_test);
    let test = Box::new(test);
    let java_body = java_class.get_body(env, jobj)?;
    let body = *Stmt::from_java(env, &java_body)?;
    delete_local_ref!(env, java_body);
    let body = Box::new(body);
    Ok(Box::new(DoWhileStmt {
      span,
      test,
      body,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for EmptyStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for EmptyStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let return_value = unsafe { JAVA_CLASS_EMPTY_STMT.as_ref().unwrap() }
      .construct(env, &java_span_ex)?;
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for EmptyStmt {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let span = DUMMY_SP;
    Ok(Box::new(EmptyStmt {
      span,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ExportAll {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.src.register_with_map(map);
    self.with.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ExportAll {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_src = self.src.to_java_with_map(env, map)?;
    let type_only = self.type_only;
    let java_optional_with = match self.with.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_EXPORT_ALL.as_ref().unwrap() }
      .construct(env, &java_src, type_only, &java_optional_with, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_with);
    delete_local_ref!(env, java_src);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ExportAll {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_EXPORT_ALL.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_src = java_class.get_src(env, jobj)?;
    let src = *Str::from_java(env, &java_src)?;
    delete_local_ref!(env, java_src);
    let src = Box::new(src);
    let type_only = java_class.is_type_only(env, jobj)?;
    let java_optional_with = java_class.get_with(env, jobj)?;
    let with = if optional_is_present(env, &java_optional_with)? {
      let java_with = optional_get(env, &java_optional_with)?;
      let with = *ObjectLit::from_java(env, &java_with)?;
      delete_local_ref!(env, java_with);
      Some(with)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_with);
    let with = with.map(|with| Box::new(with));
    Ok(Box::new(ExportAll {
      span,
      src,
      type_only,
      with,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ExportDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.decl.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ExportDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_decl = self.decl.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_EXPORT_DECL.as_ref().unwrap() }
      .construct(env, &java_decl, &java_span_ex)?;
    delete_local_ref!(env, java_decl);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ExportDecl {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_EXPORT_DECL.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_decl = java_class.get_decl(env, jobj)?;
    let decl = *Decl::from_java(env, &java_decl)?;
    delete_local_ref!(env, java_decl);
    Ok(Box::new(ExportDecl {
      span,
      decl,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ExportDefaultDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.decl.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ExportDefaultDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_decl = self.decl.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_EXPORT_DEFAULT_DECL.as_ref().unwrap() }
      .construct(env, &java_decl, &java_span_ex)?;
    delete_local_ref!(env, java_decl);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ExportDefaultDecl {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_EXPORT_DEFAULT_DECL.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_decl = java_class.get_decl(env, jobj)?;
    let decl = *DefaultDecl::from_java(env, &java_decl)?;
    delete_local_ref!(env, java_decl);
    Ok(Box::new(ExportDefaultDecl {
      span,
      decl,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ExportDefaultExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ExportDefaultExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_expr = self.expr.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_EXPORT_DEFAULT_EXPR.as_ref().unwrap() }
      .construct(env, &java_expr, &java_span_ex)?;
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ExportDefaultExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_EXPORT_DEFAULT_EXPR.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_expr = java_class.get_expr(env, jobj)?;
    let expr = *Expr::from_java(env, &java_expr)?;
    delete_local_ref!(env, java_expr);
    let expr = Box::new(expr);
    Ok(Box::new(ExportDefaultExpr {
      span,
      expr,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ExportDefaultSpecifier {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span());
    self.exported.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ExportDefaultSpecifier {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span()).to_java(env)?;
    let java_exported = self.exported.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_EXPORT_DEFAULT_SPECIFIER.as_ref().unwrap() }
      .construct(env, &java_exported, &java_span_ex)?;
    delete_local_ref!(env, java_exported);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ExportDefaultSpecifier {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_EXPORT_DEFAULT_SPECIFIER.as_ref().unwrap() };
    let java_exported = java_class.get_exported(env, jobj)?;
    let exported = *Ident::from_java(env, &java_exported)?;
    delete_local_ref!(env, java_exported);
    Ok(Box::new(ExportDefaultSpecifier {
      exported,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ExportNamedSpecifier {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.orig.register_with_map(map);
    self.exported.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ExportNamedSpecifier {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_orig = self.orig.to_java_with_map(env, map)?;
    let java_optional_exported = match self.exported.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let is_type_only = self.is_type_only;
    let return_value = unsafe { JAVA_CLASS_EXPORT_NAMED_SPECIFIER.as_ref().unwrap() }
      .construct(env, &java_orig, &java_optional_exported, is_type_only, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_exported);
    delete_local_ref!(env, java_orig);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ExportNamedSpecifier {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_EXPORT_NAMED_SPECIFIER.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_orig = java_class.get_orig(env, jobj)?;
    let orig = *ModuleExportName::from_java(env, &java_orig)?;
    delete_local_ref!(env, java_orig);
    let java_optional_exported = java_class.get_exported(env, jobj)?;
    let exported = if optional_is_present(env, &java_optional_exported)? {
      let java_exported = optional_get(env, &java_optional_exported)?;
      let exported = *ModuleExportName::from_java(env, &java_exported)?;
      delete_local_ref!(env, java_exported);
      Some(exported)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_exported);
    let is_type_only = java_class.is_type_only(env, jobj)?;
    Ok(Box::new(ExportNamedSpecifier {
      span,
      orig,
      exported,
      is_type_only,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ExportNamespaceSpecifier {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.name.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ExportNamespaceSpecifier {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_name = self.name.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_EXPORT_NAMESPACE_SPECIFIER.as_ref().unwrap() }
      .construct(env, &java_name, &java_span_ex)?;
    delete_local_ref!(env, java_name);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ExportNamespaceSpecifier {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_EXPORT_NAMESPACE_SPECIFIER.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_name = java_class.get_name(env, jobj)?;
    let name = *ModuleExportName::from_java(env, &java_name)?;
    delete_local_ref!(env, java_name);
    Ok(Box::new(ExportNamespaceSpecifier {
      span,
      name,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ExprOrSpread {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span());
    self.expr.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ExprOrSpread {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span()).to_java(env)?;
    let java_optional_spread = match self.spread.as_ref() {
      Some(node) => Some(map.get_span_ex_by_span(node).to_java(env)?),
      None => None,
    };
    let java_expr = self.expr.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_EXPR_OR_SPREAD.as_ref().unwrap() }
      .construct(env, &java_optional_spread, &java_expr, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_spread);
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ExprOrSpread {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_EXPR_OR_SPREAD.as_ref().unwrap() };
    let java_optional_spread = java_class.get_spread(env, jobj)?;
    let spread = if optional_is_present(env, &java_optional_spread)? {
      Some(DUMMY_SP)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_spread);
    let java_expr = java_class.get_expr(env, jobj)?;
    let expr = *Expr::from_java(env, &java_expr)?;
    delete_local_ref!(env, java_expr);
    let expr = Box::new(expr);
    Ok(Box::new(ExprOrSpread {
      spread,
      expr,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ExprStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ExprStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_expr = self.expr.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_EXPR_STMT.as_ref().unwrap() }
      .construct(env, &java_expr, &java_span_ex)?;
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ExprStmt {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_EXPR_STMT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_expr = java_class.get_expr(env, jobj)?;
    let expr = *Expr::from_java(env, &java_expr)?;
    delete_local_ref!(env, java_expr);
    let expr = Box::new(expr);
    Ok(Box::new(ExprStmt {
      span,
      expr,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for FnDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span());
    self.ident.register_with_map(map);
    self.function.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for FnDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span()).to_java(env)?;
    let java_ident = self.ident.to_java_with_map(env, map)?;
    let declare = self.declare;
    let java_function = self.function.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_FN_DECL.as_ref().unwrap() }
      .construct(env, &java_ident, declare, &java_function, &java_span_ex)?;
    delete_local_ref!(env, java_ident);
    delete_local_ref!(env, java_function);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for FnDecl {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_FN_DECL.as_ref().unwrap() };
    let java_ident = java_class.get_ident(env, jobj)?;
    let ident = *Ident::from_java(env, &java_ident)?;
    delete_local_ref!(env, java_ident);
    let declare = java_class.is_declare(env, jobj)?;
    let java_function = java_class.get_function(env, jobj)?;
    let function = *Function::from_java(env, &java_function)?;
    delete_local_ref!(env, java_function);
    let function = Box::new(function);
    Ok(Box::new(FnDecl {
      ident,
      declare,
      function,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for FnExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span());
    self.ident.as_ref().map(|node| node.register_with_map(map));
    self.function.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for FnExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span()).to_java(env)?;
    let java_optional_ident = match self.ident.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_function = self.function.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_FN_EXPR.as_ref().unwrap() }
      .construct(env, &java_optional_ident, &java_function, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_ident);
    delete_local_ref!(env, java_function);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for FnExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_FN_EXPR.as_ref().unwrap() };
    let java_optional_ident = java_class.get_ident(env, jobj)?;
    let ident = if optional_is_present(env, &java_optional_ident)? {
      let java_ident = optional_get(env, &java_optional_ident)?;
      let ident = *Ident::from_java(env, &java_ident)?;
      delete_local_ref!(env, java_ident);
      Some(ident)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_ident);
    let java_function = java_class.get_function(env, jobj)?;
    let function = *Function::from_java(env, &java_function)?;
    delete_local_ref!(env, java_function);
    let function = Box::new(function);
    Ok(Box::new(FnExpr {
      ident,
      function,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ForInStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.left.register_with_map(map);
    self.right.register_with_map(map);
    self.body.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ForInStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_left = self.left.to_java_with_map(env, map)?;
    let java_right = self.right.to_java_with_map(env, map)?;
    let java_body = self.body.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_FOR_IN_STMT.as_ref().unwrap() }
      .construct(env, &java_left, &java_right, &java_body, &java_span_ex)?;
    delete_local_ref!(env, java_left);
    delete_local_ref!(env, java_right);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ForInStmt {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_FOR_IN_STMT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_left = java_class.get_left(env, jobj)?;
    let left = *ForHead::from_java(env, &java_left)?;
    delete_local_ref!(env, java_left);
    let java_right = java_class.get_right(env, jobj)?;
    let right = *Expr::from_java(env, &java_right)?;
    delete_local_ref!(env, java_right);
    let right = Box::new(right);
    let java_body = java_class.get_body(env, jobj)?;
    let body = *Stmt::from_java(env, &java_body)?;
    delete_local_ref!(env, java_body);
    let body = Box::new(body);
    Ok(Box::new(ForInStmt {
      span,
      left,
      right,
      body,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ForOfStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.left.register_with_map(map);
    self.right.register_with_map(map);
    self.body.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ForOfStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let is_await = self.is_await;
    let java_left = self.left.to_java_with_map(env, map)?;
    let java_right = self.right.to_java_with_map(env, map)?;
    let java_body = self.body.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_FOR_OF_STMT.as_ref().unwrap() }
      .construct(env, is_await, &java_left, &java_right, &java_body, &java_span_ex)?;
    delete_local_ref!(env, java_left);
    delete_local_ref!(env, java_right);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ForOfStmt {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_FOR_OF_STMT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let is_await = java_class.is_await(env, jobj)?;
    let java_left = java_class.get_left(env, jobj)?;
    let left = *ForHead::from_java(env, &java_left)?;
    delete_local_ref!(env, java_left);
    let java_right = java_class.get_right(env, jobj)?;
    let right = *Expr::from_java(env, &java_right)?;
    delete_local_ref!(env, java_right);
    let right = Box::new(right);
    let java_body = java_class.get_body(env, jobj)?;
    let body = *Stmt::from_java(env, &java_body)?;
    delete_local_ref!(env, java_body);
    let body = Box::new(body);
    Ok(Box::new(ForOfStmt {
      span,
      is_await,
      left,
      right,
      body,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ForStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.init.as_ref().map(|node| node.register_with_map(map));
    self.test.as_ref().map(|node| node.register_with_map(map));
    self.update.as_ref().map(|node| node.register_with_map(map));
    self.body.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ForStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_optional_init = match self.init.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_optional_test = match self.test.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_optional_update = match self.update.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_body = self.body.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_FOR_STMT.as_ref().unwrap() }
      .construct(env, &java_optional_init, &java_optional_test, &java_optional_update, &java_body, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_init);
    delete_local_optional_ref!(env, java_optional_test);
    delete_local_optional_ref!(env, java_optional_update);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ForStmt {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_FOR_STMT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_optional_init = java_class.get_init(env, jobj)?;
    let init = if optional_is_present(env, &java_optional_init)? {
      let java_init = optional_get(env, &java_optional_init)?;
      let init = *VarDeclOrExpr::from_java(env, &java_init)?;
      delete_local_ref!(env, java_init);
      Some(init)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_init);
    let java_optional_test = java_class.get_test(env, jobj)?;
    let test = if optional_is_present(env, &java_optional_test)? {
      let java_test = optional_get(env, &java_optional_test)?;
      let test = *Expr::from_java(env, &java_test)?;
      delete_local_ref!(env, java_test);
      Some(test)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_test);
    let test = test.map(|test| Box::new(test));
    let java_optional_update = java_class.get_update(env, jobj)?;
    let update = if optional_is_present(env, &java_optional_update)? {
      let java_update = optional_get(env, &java_optional_update)?;
      let update = *Expr::from_java(env, &java_update)?;
      delete_local_ref!(env, java_update);
      Some(update)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_update);
    let update = update.map(|update| Box::new(update));
    let java_body = java_class.get_body(env, jobj)?;
    let body = *Stmt::from_java(env, &java_body)?;
    delete_local_ref!(env, java_body);
    let body = Box::new(body);
    Ok(Box::new(ForStmt {
      span,
      init,
      test,
      update,
      body,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for Function {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.params.iter() {
      node.register_with_map(map);
    }
    for node in self.decorators.iter() {
      node.register_with_map(map);
    }
    self.body.as_ref().map(|node| node.register_with_map(map));
    self.type_params.as_ref().map(|node| node.register_with_map(map));
    self.return_type.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Function {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let ctxt = self.ctxt;
    let java_params = list_new(env, self.params.len())?;
    for node in self.params.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_params, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let java_decorators = list_new(env, self.decorators.len())?;
    for node in self.decorators.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_decorators, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let java_optional_body = match self.body.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let is_generator = self.is_generator;
    let is_async = self.is_async;
    let java_optional_type_params = match self.type_params.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_optional_return_type = match self.return_type.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_FUNCTION.as_ref().unwrap() }
      .construct(env, ctxt, &java_params, &java_decorators, &java_optional_body, is_generator, is_async, &java_optional_type_params, &java_optional_return_type, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_body);
    delete_local_optional_ref!(env, java_optional_type_params);
    delete_local_optional_ref!(env, java_optional_return_type);
    delete_local_ref!(env, java_params);
    delete_local_ref!(env, java_decorators);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for Function {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_FUNCTION.as_ref().unwrap() };
    let span = DUMMY_SP;
    let ctxt = java_class.get_ctxt(env, jobj)?;
    let ctxt = SyntaxContext::from_u32(ctxt as u32);
    let java_params = java_class.get_params(env, jobj)?;
    let length = list_size(env, &java_params)?;
    let mut params: Vec<Param> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_params, i)?;
      let element = *Param::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      params.push(element)
    }
    let java_decorators = java_class.get_decorators(env, jobj)?;
    let length = list_size(env, &java_decorators)?;
    let mut decorators: Vec<Decorator> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_decorators, i)?;
      let element = *Decorator::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      decorators.push(element)
    }
    let java_optional_body = java_class.get_body(env, jobj)?;
    let body = if optional_is_present(env, &java_optional_body)? {
      let java_body = optional_get(env, &java_optional_body)?;
      let body = *BlockStmt::from_java(env, &java_body)?;
      delete_local_ref!(env, java_body);
      Some(body)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_body);
    let is_generator = java_class.is_generator(env, jobj)?;
    let is_async = java_class.is_async(env, jobj)?;
    let java_optional_type_params = java_class.get_type_params(env, jobj)?;
    let type_params = if optional_is_present(env, &java_optional_type_params)? {
      let java_type_params = optional_get(env, &java_optional_type_params)?;
      let type_params = *TsTypeParamDecl::from_java(env, &java_type_params)?;
      delete_local_ref!(env, java_type_params);
      Some(type_params)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_params);
    let type_params = type_params.map(|type_params| Box::new(type_params));
    let java_optional_return_type = java_class.get_return_type(env, jobj)?;
    let return_type = if optional_is_present(env, &java_optional_return_type)? {
      let java_return_type = optional_get(env, &java_optional_return_type)?;
      let return_type = *TsTypeAnn::from_java(env, &java_return_type)?;
      delete_local_ref!(env, java_return_type);
      Some(return_type)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_return_type);
    let return_type = return_type.map(|return_type| Box::new(return_type));
    Ok(Box::new(Function {
      span,
      ctxt,
      params,
      decorators,
      body,
      is_generator,
      is_async,
      type_params,
      return_type,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for GetterProp {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.key.register_with_map(map);
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
    self.body.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for GetterProp {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_key = self.key.to_java_with_map(env, map)?;
    let java_optional_type_ann = match self.type_ann.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_optional_body = match self.body.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_GETTER_PROP.as_ref().unwrap() }
      .construct(env, &java_key, &java_optional_type_ann, &java_optional_body, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_optional_ref!(env, java_optional_body);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for GetterProp {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_GETTER_PROP.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_key = java_class.get_key(env, jobj)?;
    let key = *PropName::from_java(env, &java_key)?;
    delete_local_ref!(env, java_key);
    let java_optional_type_ann = java_class.get_type_ann(env, jobj)?;
    let type_ann = if optional_is_present(env, &java_optional_type_ann)? {
      let java_type_ann = optional_get(env, &java_optional_type_ann)?;
      let type_ann = *TsTypeAnn::from_java(env, &java_type_ann)?;
      delete_local_ref!(env, java_type_ann);
      Some(type_ann)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_ann);
    let type_ann = type_ann.map(|type_ann| Box::new(type_ann));
    let java_optional_body = java_class.get_body(env, jobj)?;
    let body = if optional_is_present(env, &java_optional_body)? {
      let java_body = optional_get(env, &java_optional_body)?;
      let body = *BlockStmt::from_java(env, &java_body)?;
      delete_local_ref!(env, java_body);
      Some(body)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_body);
    Ok(Box::new(GetterProp {
      span,
      key,
      type_ann,
      body,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for Ident {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Ident {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let ctxt = self.ctxt;
    let sym = self.sym.as_str();
    let optional = self.optional;
    let return_value = unsafe { JAVA_CLASS_IDENT.as_ref().unwrap() }
      .construct(env, ctxt, sym, optional, &java_span_ex)?;
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for Ident {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_IDENT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let ctxt = java_class.get_ctxt(env, jobj)?;
    let ctxt = SyntaxContext::from_u32(ctxt as u32);
    let sym = java_class.get_sym(env, jobj)?;
    let sym = sym.into();
    let optional = java_class.is_optional(env, jobj)?;
    Ok(Box::new(Ident {
      span,
      ctxt,
      sym,
      optional,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for IdentName {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for IdentName {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let sym = self.sym.as_str();
    let return_value = unsafe { JAVA_CLASS_IDENT_NAME.as_ref().unwrap() }
      .construct(env, sym, &java_span_ex)?;
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for IdentName {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_IDENT_NAME.as_ref().unwrap() };
    let span = DUMMY_SP;
    let sym = java_class.get_sym(env, jobj)?;
    let sym = sym.into();
    Ok(Box::new(IdentName {
      span,
      sym,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for IfStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.test.register_with_map(map);
    self.cons.register_with_map(map);
    self.alt.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for IfStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_test = self.test.to_java_with_map(env, map)?;
    let java_cons = self.cons.to_java_with_map(env, map)?;
    let java_optional_alt = match self.alt.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_IF_STMT.as_ref().unwrap() }
      .construct(env, &java_test, &java_cons, &java_optional_alt, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_alt);
    delete_local_ref!(env, java_test);
    delete_local_ref!(env, java_cons);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for IfStmt {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_IF_STMT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_test = java_class.get_test(env, jobj)?;
    let test = *Expr::from_java(env, &java_test)?;
    delete_local_ref!(env, java_test);
    let test = Box::new(test);
    let java_cons = java_class.get_cons(env, jobj)?;
    let cons = *Stmt::from_java(env, &java_cons)?;
    delete_local_ref!(env, java_cons);
    let cons = Box::new(cons);
    let java_optional_alt = java_class.get_alt(env, jobj)?;
    let alt = if optional_is_present(env, &java_optional_alt)? {
      let java_alt = optional_get(env, &java_optional_alt)?;
      let alt = *Stmt::from_java(env, &java_alt)?;
      delete_local_ref!(env, java_alt);
      Some(alt)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_alt);
    let alt = alt.map(|alt| Box::new(alt));
    Ok(Box::new(IfStmt {
      span,
      test,
      cons,
      alt,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for Import {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Import {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_phase = self.phase.to_java(env)?;
    let return_value = unsafe { JAVA_CLASS_IMPORT.as_ref().unwrap() }
      .construct(env, &java_phase, &java_span_ex)?;
    delete_local_ref!(env, java_phase);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for Import {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_IMPORT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_phase = java_class.get_phase(env, jobj)?;
    let phase = *ImportPhase::from_java(env, &java_phase)?;
    delete_local_ref!(env, java_phase);
    Ok(Box::new(Import {
      span,
      phase,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ImportDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.specifiers.iter() {
      node.register_with_map(map);
    }
    self.src.register_with_map(map);
    self.with.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ImportDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_specifiers = list_new(env, self.specifiers.len())?;
    for node in self.specifiers.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_specifiers, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let java_src = self.src.to_java_with_map(env, map)?;
    let type_only = self.type_only;
    let java_optional_with = match self.with.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_phase = self.phase.to_java(env)?;
    let return_value = unsafe { JAVA_CLASS_IMPORT_DECL.as_ref().unwrap() }
      .construct(env, &java_specifiers, &java_src, type_only, &java_optional_with, &java_phase, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_with);
    delete_local_ref!(env, java_specifiers);
    delete_local_ref!(env, java_src);
    delete_local_ref!(env, java_phase);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ImportDecl {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_IMPORT_DECL.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_specifiers = java_class.get_specifiers(env, jobj)?;
    let length = list_size(env, &java_specifiers)?;
    let mut specifiers: Vec<ImportSpecifier> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_specifiers, i)?;
      let element = *ImportSpecifier::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      specifiers.push(element)
    }
    let java_src = java_class.get_src(env, jobj)?;
    let src = *Str::from_java(env, &java_src)?;
    delete_local_ref!(env, java_src);
    let src = Box::new(src);
    let type_only = java_class.is_type_only(env, jobj)?;
    let java_optional_with = java_class.get_with(env, jobj)?;
    let with = if optional_is_present(env, &java_optional_with)? {
      let java_with = optional_get(env, &java_optional_with)?;
      let with = *ObjectLit::from_java(env, &java_with)?;
      delete_local_ref!(env, java_with);
      Some(with)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_with);
    let with = with.map(|with| Box::new(with));
    let java_phase = java_class.get_phase(env, jobj)?;
    let phase = *ImportPhase::from_java(env, &java_phase)?;
    delete_local_ref!(env, java_phase);
    Ok(Box::new(ImportDecl {
      span,
      specifiers,
      src,
      type_only,
      with,
      phase,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ImportDefaultSpecifier {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.local.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ImportDefaultSpecifier {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_local = self.local.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_IMPORT_DEFAULT_SPECIFIER.as_ref().unwrap() }
      .construct(env, &java_local, &java_span_ex)?;
    delete_local_ref!(env, java_local);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ImportDefaultSpecifier {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_IMPORT_DEFAULT_SPECIFIER.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_local = java_class.get_local(env, jobj)?;
    let local = *Ident::from_java(env, &java_local)?;
    delete_local_ref!(env, java_local);
    Ok(Box::new(ImportDefaultSpecifier {
      span,
      local,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ImportNamedSpecifier {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.local.register_with_map(map);
    self.imported.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ImportNamedSpecifier {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_local = self.local.to_java_with_map(env, map)?;
    let java_optional_imported = match self.imported.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let is_type_only = self.is_type_only;
    let return_value = unsafe { JAVA_CLASS_IMPORT_NAMED_SPECIFIER.as_ref().unwrap() }
      .construct(env, &java_local, &java_optional_imported, is_type_only, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_imported);
    delete_local_ref!(env, java_local);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ImportNamedSpecifier {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_IMPORT_NAMED_SPECIFIER.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_local = java_class.get_local(env, jobj)?;
    let local = *Ident::from_java(env, &java_local)?;
    delete_local_ref!(env, java_local);
    let java_optional_imported = java_class.get_imported(env, jobj)?;
    let imported = if optional_is_present(env, &java_optional_imported)? {
      let java_imported = optional_get(env, &java_optional_imported)?;
      let imported = *ModuleExportName::from_java(env, &java_imported)?;
      delete_local_ref!(env, java_imported);
      Some(imported)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_imported);
    let is_type_only = java_class.is_type_only(env, jobj)?;
    Ok(Box::new(ImportNamedSpecifier {
      span,
      local,
      imported,
      is_type_only,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ImportStarAsSpecifier {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.local.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ImportStarAsSpecifier {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_local = self.local.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_IMPORT_STAR_AS_SPECIFIER.as_ref().unwrap() }
      .construct(env, &java_local, &java_span_ex)?;
    delete_local_ref!(env, java_local);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ImportStarAsSpecifier {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_IMPORT_STAR_AS_SPECIFIER.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_local = java_class.get_local(env, jobj)?;
    let local = *Ident::from_java(env, &java_local)?;
    delete_local_ref!(env, java_local);
    Ok(Box::new(ImportStarAsSpecifier {
      span,
      local,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for Invalid {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Invalid {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let return_value = unsafe { JAVA_CLASS_INVALID.as_ref().unwrap() }
      .construct(env, &java_span_ex)?;
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for Invalid {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let span = DUMMY_SP;
    Ok(Box::new(Invalid {
      span,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXAttr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.name.register_with_map(map);
    self.value.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXAttr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_name = self.name.to_java_with_map(env, map)?;
    let java_optional_value = match self.value.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_JSX_ATTR.as_ref().unwrap() }
      .construct(env, &java_name, &java_optional_value, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_value);
    delete_local_ref!(env, java_name);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for JSXAttr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_JSX_ATTR.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_name = java_class.get_name(env, jobj)?;
    let name = *JSXAttrName::from_java(env, &java_name)?;
    delete_local_ref!(env, java_name);
    let java_optional_value = java_class.get_value(env, jobj)?;
    let value = if optional_is_present(env, &java_optional_value)? {
      let java_value = optional_get(env, &java_optional_value)?;
      let value = *JSXAttrValue::from_java(env, &java_value)?;
      delete_local_ref!(env, java_value);
      Some(value)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_value);
    Ok(Box::new(JSXAttr {
      span,
      name,
      value,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXClosingElement {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.name.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXClosingElement {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_name = self.name.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_JSX_CLOSING_ELEMENT.as_ref().unwrap() }
      .construct(env, &java_name, &java_span_ex)?;
    delete_local_ref!(env, java_name);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for JSXClosingElement {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_JSX_CLOSING_ELEMENT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_name = java_class.get_name(env, jobj)?;
    let name = *JSXElementName::from_java(env, &java_name)?;
    delete_local_ref!(env, java_name);
    Ok(Box::new(JSXClosingElement {
      span,
      name,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXClosingFragment {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXClosingFragment {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let return_value = unsafe { JAVA_CLASS_JSX_CLOSING_FRAGMENT.as_ref().unwrap() }
      .construct(env, &java_span_ex)?;
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for JSXClosingFragment {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let span = DUMMY_SP;
    Ok(Box::new(JSXClosingFragment {
      span,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXElement {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.opening.register_with_map(map);
    for node in self.children.iter() {
      node.register_with_map(map);
    }
    self.closing.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXElement {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_opening = self.opening.to_java_with_map(env, map)?;
    let java_children = list_new(env, self.children.len())?;
    for node in self.children.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_children, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let java_optional_closing = match self.closing.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_JSX_ELEMENT.as_ref().unwrap() }
      .construct(env, &java_opening, &java_children, &java_optional_closing, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_closing);
    delete_local_ref!(env, java_opening);
    delete_local_ref!(env, java_children);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for JSXElement {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_JSX_ELEMENT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_opening = java_class.get_opening(env, jobj)?;
    let opening = *JSXOpeningElement::from_java(env, &java_opening)?;
    delete_local_ref!(env, java_opening);
    let java_children = java_class.get_children(env, jobj)?;
    let length = list_size(env, &java_children)?;
    let mut children: Vec<JSXElementChild> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_children, i)?;
      let element = *JSXElementChild::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      children.push(element)
    }
    let java_optional_closing = java_class.get_closing(env, jobj)?;
    let closing = if optional_is_present(env, &java_optional_closing)? {
      let java_closing = optional_get(env, &java_optional_closing)?;
      let closing = *JSXClosingElement::from_java(env, &java_closing)?;
      delete_local_ref!(env, java_closing);
      Some(closing)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_closing);
    Ok(Box::new(JSXElement {
      span,
      opening,
      children,
      closing,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXEmptyExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXEmptyExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let return_value = unsafe { JAVA_CLASS_JSX_EMPTY_EXPR.as_ref().unwrap() }
      .construct(env, &java_span_ex)?;
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for JSXEmptyExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let span = DUMMY_SP;
    Ok(Box::new(JSXEmptyExpr {
      span,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXExprContainer {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXExprContainer {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_expr = self.expr.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_JSX_EXPR_CONTAINER.as_ref().unwrap() }
      .construct(env, &java_expr, &java_span_ex)?;
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for JSXExprContainer {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_JSX_EXPR_CONTAINER.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_expr = java_class.get_expr(env, jobj)?;
    let expr = *JSXExpr::from_java(env, &java_expr)?;
    delete_local_ref!(env, java_expr);
    Ok(Box::new(JSXExprContainer {
      span,
      expr,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXFragment {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.opening.register_with_map(map);
    for node in self.children.iter() {
      node.register_with_map(map);
    }
    self.closing.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXFragment {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_opening = self.opening.to_java_with_map(env, map)?;
    let java_children = list_new(env, self.children.len())?;
    for node in self.children.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_children, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let java_closing = self.closing.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_JSX_FRAGMENT.as_ref().unwrap() }
      .construct(env, &java_opening, &java_children, &java_closing, &java_span_ex)?;
    delete_local_ref!(env, java_opening);
    delete_local_ref!(env, java_children);
    delete_local_ref!(env, java_closing);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for JSXFragment {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_JSX_FRAGMENT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_opening = java_class.get_opening(env, jobj)?;
    let opening = *JSXOpeningFragment::from_java(env, &java_opening)?;
    delete_local_ref!(env, java_opening);
    let java_children = java_class.get_children(env, jobj)?;
    let length = list_size(env, &java_children)?;
    let mut children: Vec<JSXElementChild> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_children, i)?;
      let element = *JSXElementChild::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      children.push(element)
    }
    let java_closing = java_class.get_closing(env, jobj)?;
    let closing = *JSXClosingFragment::from_java(env, &java_closing)?;
    delete_local_ref!(env, java_closing);
    Ok(Box::new(JSXFragment {
      span,
      opening,
      children,
      closing,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXMemberExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.obj.register_with_map(map);
    self.prop.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXMemberExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_obj = self.obj.to_java_with_map(env, map)?;
    let java_prop = self.prop.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_JSX_MEMBER_EXPR.as_ref().unwrap() }
      .construct(env, &java_obj, &java_prop, &java_span_ex)?;
    delete_local_ref!(env, java_obj);
    delete_local_ref!(env, java_prop);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for JSXMemberExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_JSX_MEMBER_EXPR.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_obj = java_class.get_obj(env, jobj)?;
    let obj = *JSXObject::from_java(env, &java_obj)?;
    delete_local_ref!(env, java_obj);
    let java_prop = java_class.get_prop(env, jobj)?;
    let prop = *IdentName::from_java(env, &java_prop)?;
    delete_local_ref!(env, java_prop);
    Ok(Box::new(JSXMemberExpr {
      span,
      obj,
      prop,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXNamespacedName {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.ns.register_with_map(map);
    self.name.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXNamespacedName {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_ns = self.ns.to_java_with_map(env, map)?;
    let java_name = self.name.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_JSX_NAMESPACED_NAME.as_ref().unwrap() }
      .construct(env, &java_ns, &java_name, &java_span_ex)?;
    delete_local_ref!(env, java_ns);
    delete_local_ref!(env, java_name);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for JSXNamespacedName {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_JSX_NAMESPACED_NAME.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_ns = java_class.get_ns(env, jobj)?;
    let ns = *IdentName::from_java(env, &java_ns)?;
    delete_local_ref!(env, java_ns);
    let java_name = java_class.get_name(env, jobj)?;
    let name = *IdentName::from_java(env, &java_name)?;
    delete_local_ref!(env, java_name);
    Ok(Box::new(JSXNamespacedName {
      span,
      ns,
      name,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXOpeningElement {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.name.register_with_map(map);
    for node in self.attrs.iter() {
      node.register_with_map(map);
    }
    self.type_args.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXOpeningElement {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_name = self.name.to_java_with_map(env, map)?;
    let java_attrs = list_new(env, self.attrs.len())?;
    for node in self.attrs.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_attrs, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let self_closing = self.self_closing;
    let java_optional_type_args = match self.type_args.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_JSX_OPENING_ELEMENT.as_ref().unwrap() }
      .construct(env, &java_name, &java_attrs, self_closing, &java_optional_type_args, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_type_args);
    delete_local_ref!(env, java_name);
    delete_local_ref!(env, java_attrs);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for JSXOpeningElement {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_JSX_OPENING_ELEMENT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_name = java_class.get_name(env, jobj)?;
    let name = *JSXElementName::from_java(env, &java_name)?;
    delete_local_ref!(env, java_name);
    let java_attrs = java_class.get_attrs(env, jobj)?;
    let length = list_size(env, &java_attrs)?;
    let mut attrs: Vec<JSXAttrOrSpread> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_attrs, i)?;
      let element = *JSXAttrOrSpread::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      attrs.push(element)
    }
    let self_closing = java_class.is_self_closing(env, jobj)?;
    let java_optional_type_args = java_class.get_type_args(env, jobj)?;
    let type_args = if optional_is_present(env, &java_optional_type_args)? {
      let java_type_args = optional_get(env, &java_optional_type_args)?;
      let type_args = *TsTypeParamInstantiation::from_java(env, &java_type_args)?;
      delete_local_ref!(env, java_type_args);
      Some(type_args)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_args);
    let type_args = type_args.map(|type_args| Box::new(type_args));
    Ok(Box::new(JSXOpeningElement {
      span,
      name,
      attrs,
      self_closing,
      type_args,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXOpeningFragment {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXOpeningFragment {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let return_value = unsafe { JAVA_CLASS_JSX_OPENING_FRAGMENT.as_ref().unwrap() }
      .construct(env, &java_span_ex)?;
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for JSXOpeningFragment {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let span = DUMMY_SP;
    Ok(Box::new(JSXOpeningFragment {
      span,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXSpreadChild {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXSpreadChild {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_expr = self.expr.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_JSX_SPREAD_CHILD.as_ref().unwrap() }
      .construct(env, &java_expr, &java_span_ex)?;
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for JSXSpreadChild {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_JSX_SPREAD_CHILD.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_expr = java_class.get_expr(env, jobj)?;
    let expr = *Expr::from_java(env, &java_expr)?;
    delete_local_ref!(env, java_expr);
    let expr = Box::new(expr);
    Ok(Box::new(JSXSpreadChild {
      span,
      expr,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for JSXText {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for JSXText {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let value = self.value.as_str();
    let raw = self.raw.as_str();
    let return_value = unsafe { JAVA_CLASS_JSX_TEXT.as_ref().unwrap() }
      .construct(env, value, raw, &java_span_ex)?;
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for JSXText {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_JSX_TEXT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let value = java_class.get_value(env, jobj)?;
    let value = value.into();
    let raw = java_class.get_raw(env, jobj)?;
    let raw = raw.into();
    Ok(Box::new(JSXText {
      span,
      value,
      raw,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for KeyValuePatProp {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span());
    self.key.register_with_map(map);
    self.value.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for KeyValuePatProp {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span()).to_java(env)?;
    let java_key = self.key.to_java_with_map(env, map)?;
    let java_value = self.value.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_KEY_VALUE_PAT_PROP.as_ref().unwrap() }
      .construct(env, &java_key, &java_value, &java_span_ex)?;
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_value);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for KeyValuePatProp {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_KEY_VALUE_PAT_PROP.as_ref().unwrap() };
    let java_key = java_class.get_key(env, jobj)?;
    let key = *PropName::from_java(env, &java_key)?;
    delete_local_ref!(env, java_key);
    let java_value = java_class.get_value(env, jobj)?;
    let value = *Pat::from_java(env, &java_value)?;
    delete_local_ref!(env, java_value);
    let value = Box::new(value);
    Ok(Box::new(KeyValuePatProp {
      key,
      value,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for KeyValueProp {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span());
    self.key.register_with_map(map);
    self.value.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for KeyValueProp {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span()).to_java(env)?;
    let java_key = self.key.to_java_with_map(env, map)?;
    let java_value = self.value.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_KEY_VALUE_PROP.as_ref().unwrap() }
      .construct(env, &java_key, &java_value, &java_span_ex)?;
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_value);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for KeyValueProp {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_KEY_VALUE_PROP.as_ref().unwrap() };
    let java_key = java_class.get_key(env, jobj)?;
    let key = *PropName::from_java(env, &java_key)?;
    delete_local_ref!(env, java_key);
    let java_value = java_class.get_value(env, jobj)?;
    let value = *Expr::from_java(env, &java_value)?;
    delete_local_ref!(env, java_value);
    let value = Box::new(value);
    Ok(Box::new(KeyValueProp {
      key,
      value,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for LabeledStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.label.register_with_map(map);
    self.body.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for LabeledStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_label = self.label.to_java_with_map(env, map)?;
    let java_body = self.body.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_LABELED_STMT.as_ref().unwrap() }
      .construct(env, &java_label, &java_body, &java_span_ex)?;
    delete_local_ref!(env, java_label);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for LabeledStmt {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_LABELED_STMT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_label = java_class.get_label(env, jobj)?;
    let label = *Ident::from_java(env, &java_label)?;
    delete_local_ref!(env, java_label);
    let java_body = java_class.get_body(env, jobj)?;
    let body = *Stmt::from_java(env, &java_body)?;
    delete_local_ref!(env, java_body);
    let body = Box::new(body);
    Ok(Box::new(LabeledStmt {
      span,
      label,
      body,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for MemberExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.obj.register_with_map(map);
    self.prop.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for MemberExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_obj = self.obj.to_java_with_map(env, map)?;
    let java_prop = self.prop.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_MEMBER_EXPR.as_ref().unwrap() }
      .construct(env, &java_obj, &java_prop, &java_span_ex)?;
    delete_local_ref!(env, java_obj);
    delete_local_ref!(env, java_prop);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for MemberExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_MEMBER_EXPR.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_obj = java_class.get_obj(env, jobj)?;
    let obj = *Expr::from_java(env, &java_obj)?;
    delete_local_ref!(env, java_obj);
    let obj = Box::new(obj);
    let java_prop = java_class.get_prop(env, jobj)?;
    let prop = *MemberProp::from_java(env, &java_prop)?;
    delete_local_ref!(env, java_prop);
    Ok(Box::new(MemberExpr {
      span,
      obj,
      prop,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for MetaPropExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for MetaPropExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_kind = self.kind.to_java(env)?;
    let return_value = unsafe { JAVA_CLASS_META_PROP_EXPR.as_ref().unwrap() }
      .construct(env, &java_kind, &java_span_ex)?;
    delete_local_ref!(env, java_kind);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for MetaPropExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_META_PROP_EXPR.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_kind = java_class.get_kind(env, jobj)?;
    let kind = *MetaPropKind::from_java(env, &java_kind)?;
    delete_local_ref!(env, java_kind);
    Ok(Box::new(MetaPropExpr {
      span,
      kind,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for MethodProp {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span());
    self.key.register_with_map(map);
    self.function.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for MethodProp {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span()).to_java(env)?;
    let java_key = self.key.to_java_with_map(env, map)?;
    let java_function = self.function.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_METHOD_PROP.as_ref().unwrap() }
      .construct(env, &java_key, &java_function, &java_span_ex)?;
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_function);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for MethodProp {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_METHOD_PROP.as_ref().unwrap() };
    let java_key = java_class.get_key(env, jobj)?;
    let key = *PropName::from_java(env, &java_key)?;
    delete_local_ref!(env, java_key);
    let java_function = java_class.get_function(env, jobj)?;
    let function = *Function::from_java(env, &java_function)?;
    delete_local_ref!(env, java_function);
    let function = Box::new(function);
    Ok(Box::new(MethodProp {
      key,
      function,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for Module {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.body.iter() {
      node.register_with_map(map);
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Module {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_body = list_new(env, self.body.len())?;
    for node in self.body.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_body, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let optional_shebang = self.shebang.as_ref().map(|node| node.to_string());
    let return_value = unsafe { JAVA_CLASS_MODULE.as_ref().unwrap() }
      .construct(env, &java_body, &optional_shebang, &java_span_ex)?;
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for Module {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_MODULE.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_body = java_class.get_body(env, jobj)?;
    let length = list_size(env, &java_body)?;
    let mut body: Vec<ModuleItem> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_body, i)?;
      let element = *ModuleItem::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      body.push(element)
    }
    let java_optional_shebang = java_class.get_shebang(env, jobj)?;
    let shebang = if optional_is_present(env, &java_optional_shebang)? {
      let java_shebang = optional_get(env, &java_optional_shebang)?;
      let shebang: Result<String> = jstring_to_string!(env, java_shebang.as_raw());
      let shebang = shebang?;
      delete_local_ref!(env, java_shebang);
      Some(shebang)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_shebang);
    let shebang = shebang.map(|shebang| shebang.into());
    Ok(Box::new(Module {
      span,
      body,
      shebang,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for NamedExport {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.specifiers.iter() {
      node.register_with_map(map);
    }
    self.src.as_ref().map(|node| node.register_with_map(map));
    self.with.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for NamedExport {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_specifiers = list_new(env, self.specifiers.len())?;
    for node in self.specifiers.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_specifiers, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let java_optional_src = match self.src.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let type_only = self.type_only;
    let java_optional_with = match self.with.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_NAMED_EXPORT.as_ref().unwrap() }
      .construct(env, &java_specifiers, &java_optional_src, type_only, &java_optional_with, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_src);
    delete_local_optional_ref!(env, java_optional_with);
    delete_local_ref!(env, java_specifiers);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for NamedExport {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_NAMED_EXPORT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_specifiers = java_class.get_specifiers(env, jobj)?;
    let length = list_size(env, &java_specifiers)?;
    let mut specifiers: Vec<ExportSpecifier> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_specifiers, i)?;
      let element = *ExportSpecifier::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      specifiers.push(element)
    }
    let java_optional_src = java_class.get_src(env, jobj)?;
    let src = if optional_is_present(env, &java_optional_src)? {
      let java_src = optional_get(env, &java_optional_src)?;
      let src = *Str::from_java(env, &java_src)?;
      delete_local_ref!(env, java_src);
      Some(src)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_src);
    let src = src.map(|src| Box::new(src));
    let type_only = java_class.is_type_only(env, jobj)?;
    let java_optional_with = java_class.get_with(env, jobj)?;
    let with = if optional_is_present(env, &java_optional_with)? {
      let java_with = optional_get(env, &java_optional_with)?;
      let with = *ObjectLit::from_java(env, &java_with)?;
      delete_local_ref!(env, java_with);
      Some(with)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_with);
    let with = with.map(|with| Box::new(with));
    Ok(Box::new(NamedExport {
      span,
      specifiers,
      src,
      type_only,
      with,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for NewExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.callee.register_with_map(map);
    self.args.as_ref().map(|nodes| nodes.iter().for_each(|node| node.register_with_map(map)));
    self.type_args.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for NewExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let ctxt = self.ctxt;
    let java_callee = self.callee.to_java_with_map(env, map)?;
    let java_optional_args = match self.args.as_ref() {
      Some(nodes) => {
        let java_args = list_new(env, nodes.len())?;
        for node in nodes.iter() {
          let java_node = node.to_java_with_map(env, map)?;
          list_add(env, &java_args, &java_node)?;
          delete_local_ref!(env, java_node);
        }
        Some(java_args)
      }
      None => None,
    };
    let java_optional_type_args = match self.type_args.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_NEW_EXPR.as_ref().unwrap() }
      .construct(env, ctxt, &java_callee, &java_optional_args, &java_optional_type_args, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_args);
    delete_local_optional_ref!(env, java_optional_type_args);
    delete_local_ref!(env, java_callee);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for NewExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_NEW_EXPR.as_ref().unwrap() };
    let span = DUMMY_SP;
    let ctxt = java_class.get_ctxt(env, jobj)?;
    let ctxt = SyntaxContext::from_u32(ctxt as u32);
    let java_callee = java_class.get_callee(env, jobj)?;
    let callee = *Expr::from_java(env, &java_callee)?;
    delete_local_ref!(env, java_callee);
    let callee = Box::new(callee);
    let java_optional_args = java_class.get_args(env, jobj)?;
    let args = if optional_is_present(env, &java_optional_args)? {
      let java_args = optional_get(env, &java_optional_args)?;
      let length = list_size(env, &java_args)?;
      let mut args: Vec<ExprOrSpread> = Vec::with_capacity(length);
      for i in 0..length {
        let java_item = list_get(env, &java_args, i)?;
        let element = *ExprOrSpread::from_java(env, &java_item)?;
        delete_local_ref!(env, java_item);
      args.push(element);
      }
      Some(args)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_args);
    let java_optional_type_args = java_class.get_type_args(env, jobj)?;
    let type_args = if optional_is_present(env, &java_optional_type_args)? {
      let java_type_args = optional_get(env, &java_optional_type_args)?;
      let type_args = *TsTypeParamInstantiation::from_java(env, &java_type_args)?;
      delete_local_ref!(env, java_type_args);
      Some(type_args)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_args);
    let type_args = type_args.map(|type_args| Box::new(type_args));
    Ok(Box::new(NewExpr {
      span,
      ctxt,
      callee,
      args,
      type_args,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for Null {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Null {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let return_value = unsafe { JAVA_CLASS_NULL.as_ref().unwrap() }
      .construct(env, &java_span_ex)?;
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for Null {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let span = DUMMY_SP;
    Ok(Box::new(Null {
      span,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for Number {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Number {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let value = self.value;
    let optional_raw = self.raw.as_ref().map(|node| node.to_string());
    let return_value = unsafe { JAVA_CLASS_NUMBER.as_ref().unwrap() }
      .construct(env, value, &optional_raw, &java_span_ex)?;
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for Number {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_NUMBER.as_ref().unwrap() };
    let span = DUMMY_SP;
    let value = java_class.get_value(env, jobj)?;
    let java_optional_raw = java_class.get_raw(env, jobj)?;
    let raw = if optional_is_present(env, &java_optional_raw)? {
      let java_raw = optional_get(env, &java_optional_raw)?;
      let raw: Result<String> = jstring_to_string!(env, java_raw.as_raw());
      let raw = raw?;
      delete_local_ref!(env, java_raw);
      Some(raw)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_raw);
    let raw = raw.map(|raw| raw.into());
    Ok(Box::new(Number {
      span,
      value,
      raw,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ObjectLit {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.props.iter() {
      node.register_with_map(map);
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ObjectLit {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_props = list_new(env, self.props.len())?;
    for node in self.props.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_props, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let return_value = unsafe { JAVA_CLASS_OBJECT_LIT.as_ref().unwrap() }
      .construct(env, &java_props, &java_span_ex)?;
    delete_local_ref!(env, java_props);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ObjectLit {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_OBJECT_LIT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_props = java_class.get_props(env, jobj)?;
    let length = list_size(env, &java_props)?;
    let mut props: Vec<PropOrSpread> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_props, i)?;
      let element = *PropOrSpread::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      props.push(element)
    }
    Ok(Box::new(ObjectLit {
      span,
      props,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ObjectPat {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.props.iter() {
      node.register_with_map(map);
    }
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ObjectPat {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_props = list_new(env, self.props.len())?;
    for node in self.props.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_props, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let optional = self.optional;
    let java_optional_type_ann = match self.type_ann.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_OBJECT_PAT.as_ref().unwrap() }
      .construct(env, &java_props, optional, &java_optional_type_ann, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_ref!(env, java_props);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ObjectPat {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_OBJECT_PAT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_props = java_class.get_props(env, jobj)?;
    let length = list_size(env, &java_props)?;
    let mut props: Vec<ObjectPatProp> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_props, i)?;
      let element = *ObjectPatProp::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      props.push(element)
    }
    let optional = java_class.is_optional(env, jobj)?;
    let java_optional_type_ann = java_class.get_type_ann(env, jobj)?;
    let type_ann = if optional_is_present(env, &java_optional_type_ann)? {
      let java_type_ann = optional_get(env, &java_optional_type_ann)?;
      let type_ann = *TsTypeAnn::from_java(env, &java_type_ann)?;
      delete_local_ref!(env, java_type_ann);
      Some(type_ann)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_ann);
    let type_ann = type_ann.map(|type_ann| Box::new(type_ann));
    Ok(Box::new(ObjectPat {
      span,
      props,
      optional,
      type_ann,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for OptCall {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.callee.register_with_map(map);
    for node in self.args.iter() {
      node.register_with_map(map);
    }
    self.type_args.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for OptCall {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let ctxt = self.ctxt;
    let java_callee = self.callee.to_java_with_map(env, map)?;
    let java_args = list_new(env, self.args.len())?;
    for node in self.args.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_args, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let java_optional_type_args = match self.type_args.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_OPT_CALL.as_ref().unwrap() }
      .construct(env, ctxt, &java_callee, &java_args, &java_optional_type_args, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_type_args);
    delete_local_ref!(env, java_callee);
    delete_local_ref!(env, java_args);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for OptCall {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_OPT_CALL.as_ref().unwrap() };
    let span = DUMMY_SP;
    let ctxt = java_class.get_ctxt(env, jobj)?;
    let ctxt = SyntaxContext::from_u32(ctxt as u32);
    let java_callee = java_class.get_callee(env, jobj)?;
    let callee = *Expr::from_java(env, &java_callee)?;
    delete_local_ref!(env, java_callee);
    let callee = Box::new(callee);
    let java_args = java_class.get_args(env, jobj)?;
    let length = list_size(env, &java_args)?;
    let mut args: Vec<ExprOrSpread> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_args, i)?;
      let element = *ExprOrSpread::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      args.push(element)
    }
    let java_optional_type_args = java_class.get_type_args(env, jobj)?;
    let type_args = if optional_is_present(env, &java_optional_type_args)? {
      let java_type_args = optional_get(env, &java_optional_type_args)?;
      let type_args = *TsTypeParamInstantiation::from_java(env, &java_type_args)?;
      delete_local_ref!(env, java_type_args);
      Some(type_args)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_args);
    let type_args = type_args.map(|type_args| Box::new(type_args));
    Ok(Box::new(OptCall {
      span,
      ctxt,
      callee,
      args,
      type_args,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for OptChainExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.base.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for OptChainExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let optional = self.optional;
    let java_base = self.base.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_OPT_CHAIN_EXPR.as_ref().unwrap() }
      .construct(env, optional, &java_base, &java_span_ex)?;
    delete_local_ref!(env, java_base);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for OptChainExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_OPT_CHAIN_EXPR.as_ref().unwrap() };
    let span = DUMMY_SP;
    let optional = java_class.is_optional(env, jobj)?;
    let java_base = java_class.get_base(env, jobj)?;
    let base = *OptChainBase::from_java(env, &java_base)?;
    delete_local_ref!(env, java_base);
    let base = Box::new(base);
    Ok(Box::new(OptChainExpr {
      span,
      optional,
      base,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for Param {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.decorators.iter() {
      node.register_with_map(map);
    }
    self.pat.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Param {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_decorators = list_new(env, self.decorators.len())?;
    for node in self.decorators.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_decorators, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let java_pat = self.pat.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_PARAM.as_ref().unwrap() }
      .construct(env, &java_decorators, &java_pat, &java_span_ex)?;
    delete_local_ref!(env, java_decorators);
    delete_local_ref!(env, java_pat);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for Param {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_PARAM.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_decorators = java_class.get_decorators(env, jobj)?;
    let length = list_size(env, &java_decorators)?;
    let mut decorators: Vec<Decorator> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_decorators, i)?;
      let element = *Decorator::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      decorators.push(element)
    }
    let java_pat = java_class.get_pat(env, jobj)?;
    let pat = *Pat::from_java(env, &java_pat)?;
    delete_local_ref!(env, java_pat);
    Ok(Box::new(Param {
      span,
      decorators,
      pat,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ParenExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ParenExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_expr = self.expr.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_PAREN_EXPR.as_ref().unwrap() }
      .construct(env, &java_expr, &java_span_ex)?;
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ParenExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_PAREN_EXPR.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_expr = java_class.get_expr(env, jobj)?;
    let expr = *Expr::from_java(env, &java_expr)?;
    delete_local_ref!(env, java_expr);
    let expr = Box::new(expr);
    Ok(Box::new(ParenExpr {
      span,
      expr,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for PrivateMethod {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.key.register_with_map(map);
    self.function.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for PrivateMethod {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_key = self.key.to_java_with_map(env, map)?;
    let java_function = self.function.to_java_with_map(env, map)?;
    let java_kind = self.kind.to_java(env)?;
    let is_static = self.is_static;
    let java_optional_accessibility = match self.accessibility.as_ref() {
      Some(node) => Some(node.to_java(env)?),
      None => None,
    };
    let is_abstract = self.is_abstract;
    let is_optional = self.is_optional;
    let is_override = self.is_override;
    let return_value = unsafe { JAVA_CLASS_PRIVATE_METHOD.as_ref().unwrap() }
      .construct(env, &java_key, &java_function, &java_kind, is_static, &java_optional_accessibility, is_abstract, is_optional, is_override, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_accessibility);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_function);
    delete_local_ref!(env, java_kind);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for PrivateMethod {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_PRIVATE_METHOD.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_key = java_class.get_key(env, jobj)?;
    let key = *PrivateName::from_java(env, &java_key)?;
    delete_local_ref!(env, java_key);
    let java_function = java_class.get_function(env, jobj)?;
    let function = *Function::from_java(env, &java_function)?;
    delete_local_ref!(env, java_function);
    let function = Box::new(function);
    let java_kind = java_class.get_kind(env, jobj)?;
    let kind = *MethodKind::from_java(env, &java_kind)?;
    delete_local_ref!(env, java_kind);
    let is_static = java_class.is_static(env, jobj)?;
    let java_optional_accessibility = java_class.get_accessibility(env, jobj)?;
    let accessibility = if optional_is_present(env, &java_optional_accessibility)? {
      let java_accessibility = optional_get(env, &java_optional_accessibility)?;
      let accessibility = *Accessibility::from_java(env, &java_accessibility)?;
      delete_local_ref!(env, java_accessibility);
      Some(accessibility)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_accessibility);
    let is_abstract = java_class.is_abstract(env, jobj)?;
    let is_optional = java_class.is_optional(env, jobj)?;
    let is_override = java_class.is_override(env, jobj)?;
    Ok(Box::new(PrivateMethod {
      span,
      key,
      function,
      kind,
      is_static,
      accessibility,
      is_abstract,
      is_optional,
      is_override,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for PrivateName {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for PrivateName {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let name = self.name.as_str();
    let return_value = unsafe { JAVA_CLASS_PRIVATE_NAME.as_ref().unwrap() }
      .construct(env, name, &java_span_ex)?;
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for PrivateName {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_PRIVATE_NAME.as_ref().unwrap() };
    let span = DUMMY_SP;
    let name = java_class.get_name(env, jobj)?;
    let name = name.into();
    Ok(Box::new(PrivateName {
      span,
      name,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for PrivateProp {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.key.register_with_map(map);
    self.value.as_ref().map(|node| node.register_with_map(map));
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
    for node in self.decorators.iter() {
      node.register_with_map(map);
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for PrivateProp {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let ctxt = self.ctxt;
    let java_key = self.key.to_java_with_map(env, map)?;
    let java_optional_value = match self.value.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_optional_type_ann = match self.type_ann.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let is_static = self.is_static;
    let java_decorators = list_new(env, self.decorators.len())?;
    for node in self.decorators.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_decorators, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let java_optional_accessibility = match self.accessibility.as_ref() {
      Some(node) => Some(node.to_java(env)?),
      None => None,
    };
    let is_optional = self.is_optional;
    let is_override = self.is_override;
    let readonly = self.readonly;
    let definite = self.definite;
    let return_value = unsafe { JAVA_CLASS_PRIVATE_PROP.as_ref().unwrap() }
      .construct(env, ctxt, &java_key, &java_optional_value, &java_optional_type_ann, is_static, &java_decorators, &java_optional_accessibility, is_optional, is_override, readonly, definite, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_value);
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_optional_ref!(env, java_optional_accessibility);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_decorators);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for PrivateProp {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_PRIVATE_PROP.as_ref().unwrap() };
    let span = DUMMY_SP;
    let ctxt = java_class.get_ctxt(env, jobj)?;
    let ctxt = SyntaxContext::from_u32(ctxt as u32);
    let java_key = java_class.get_key(env, jobj)?;
    let key = *PrivateName::from_java(env, &java_key)?;
    delete_local_ref!(env, java_key);
    let java_optional_value = java_class.get_value(env, jobj)?;
    let value = if optional_is_present(env, &java_optional_value)? {
      let java_value = optional_get(env, &java_optional_value)?;
      let value = *Expr::from_java(env, &java_value)?;
      delete_local_ref!(env, java_value);
      Some(value)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_value);
    let value = value.map(|value| Box::new(value));
    let java_optional_type_ann = java_class.get_type_ann(env, jobj)?;
    let type_ann = if optional_is_present(env, &java_optional_type_ann)? {
      let java_type_ann = optional_get(env, &java_optional_type_ann)?;
      let type_ann = *TsTypeAnn::from_java(env, &java_type_ann)?;
      delete_local_ref!(env, java_type_ann);
      Some(type_ann)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_ann);
    let type_ann = type_ann.map(|type_ann| Box::new(type_ann));
    let is_static = java_class.is_static(env, jobj)?;
    let java_decorators = java_class.get_decorators(env, jobj)?;
    let length = list_size(env, &java_decorators)?;
    let mut decorators: Vec<Decorator> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_decorators, i)?;
      let element = *Decorator::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      decorators.push(element)
    }
    let java_optional_accessibility = java_class.get_accessibility(env, jobj)?;
    let accessibility = if optional_is_present(env, &java_optional_accessibility)? {
      let java_accessibility = optional_get(env, &java_optional_accessibility)?;
      let accessibility = *Accessibility::from_java(env, &java_accessibility)?;
      delete_local_ref!(env, java_accessibility);
      Some(accessibility)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_accessibility);
    let is_optional = java_class.is_optional(env, jobj)?;
    let is_override = java_class.is_override(env, jobj)?;
    let readonly = java_class.is_readonly(env, jobj)?;
    let definite = java_class.is_definite(env, jobj)?;
    Ok(Box::new(PrivateProp {
      span,
      ctxt,
      key,
      value,
      type_ann,
      is_static,
      decorators,
      accessibility,
      is_optional,
      is_override,
      readonly,
      definite,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for Regex {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Regex {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let exp = self.exp.as_str();
    let flags = self.flags.as_str();
    let return_value = unsafe { JAVA_CLASS_REGEX.as_ref().unwrap() }
      .construct(env, exp, flags, &java_span_ex)?;
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for Regex {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_REGEX.as_ref().unwrap() };
    let span = DUMMY_SP;
    let exp = java_class.get_exp(env, jobj)?;
    let exp = exp.into();
    let flags = java_class.get_flags(env, jobj)?;
    let flags = flags.into();
    Ok(Box::new(Regex {
      span,
      exp,
      flags,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for RestPat {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    map.register_by_span(&self.dot3_token);
    self.arg.register_with_map(map);
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for RestPat {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_dot3_token = map.get_span_ex_by_span(&self.dot3_token).to_java(env)?;
    let java_arg = self.arg.to_java_with_map(env, map)?;
    let java_optional_type_ann = match self.type_ann.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_REST_PAT.as_ref().unwrap() }
      .construct(env, &java_dot3_token, &java_arg, &java_optional_type_ann, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_ref!(env, java_dot3_token);
    delete_local_ref!(env, java_arg);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for RestPat {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_REST_PAT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let dot3_token = DUMMY_SP;
    let java_arg = java_class.get_arg(env, jobj)?;
    let arg = *Pat::from_java(env, &java_arg)?;
    delete_local_ref!(env, java_arg);
    let arg = Box::new(arg);
    let java_optional_type_ann = java_class.get_type_ann(env, jobj)?;
    let type_ann = if optional_is_present(env, &java_optional_type_ann)? {
      let java_type_ann = optional_get(env, &java_optional_type_ann)?;
      let type_ann = *TsTypeAnn::from_java(env, &java_type_ann)?;
      delete_local_ref!(env, java_type_ann);
      Some(type_ann)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_ann);
    let type_ann = type_ann.map(|type_ann| Box::new(type_ann));
    Ok(Box::new(RestPat {
      span,
      dot3_token,
      arg,
      type_ann,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ReturnStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.arg.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ReturnStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_optional_arg = match self.arg.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_RETURN_STMT.as_ref().unwrap() }
      .construct(env, &java_optional_arg, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_arg);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ReturnStmt {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_RETURN_STMT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_optional_arg = java_class.get_arg(env, jobj)?;
    let arg = if optional_is_present(env, &java_optional_arg)? {
      let java_arg = optional_get(env, &java_optional_arg)?;
      let arg = *Expr::from_java(env, &java_arg)?;
      delete_local_ref!(env, java_arg);
      Some(arg)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_arg);
    let arg = arg.map(|arg| Box::new(arg));
    Ok(Box::new(ReturnStmt {
      span,
      arg,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for Script {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.body.iter() {
      node.register_with_map(map);
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Script {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_body = list_new(env, self.body.len())?;
    for node in self.body.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_body, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let optional_shebang = self.shebang.as_ref().map(|node| node.to_string());
    let return_value = unsafe { JAVA_CLASS_SCRIPT.as_ref().unwrap() }
      .construct(env, &java_body, &optional_shebang, &java_span_ex)?;
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for Script {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_SCRIPT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_body = java_class.get_body(env, jobj)?;
    let length = list_size(env, &java_body)?;
    let mut body: Vec<Stmt> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_body, i)?;
      let element = *Stmt::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      body.push(element)
    }
    let java_optional_shebang = java_class.get_shebang(env, jobj)?;
    let shebang = if optional_is_present(env, &java_optional_shebang)? {
      let java_shebang = optional_get(env, &java_optional_shebang)?;
      let shebang: Result<String> = jstring_to_string!(env, java_shebang.as_raw());
      let shebang = shebang?;
      delete_local_ref!(env, java_shebang);
      Some(shebang)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_shebang);
    let shebang = shebang.map(|shebang| shebang.into());
    Ok(Box::new(Script {
      span,
      body,
      shebang,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for SeqExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.exprs.iter() {
      node.register_with_map(map);
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for SeqExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_exprs = list_new(env, self.exprs.len())?;
    for node in self.exprs.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_exprs, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let return_value = unsafe { JAVA_CLASS_SEQ_EXPR.as_ref().unwrap() }
      .construct(env, &java_exprs, &java_span_ex)?;
    delete_local_ref!(env, java_exprs);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for SeqExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_SEQ_EXPR.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_exprs = java_class.get_exprs(env, jobj)?;
    let length = list_size(env, &java_exprs)?;
    let mut exprs: Vec<Expr> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_exprs, i)?;
      let element = *Expr::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      exprs.push(element)
    }
    let exprs = exprs.into_iter().map(|exprs| Box::new(exprs)).collect();
    Ok(Box::new(SeqExpr {
      span,
      exprs,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for SetterProp {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.key.register_with_map(map);
    self.this_param.as_ref().map(|node| node.register_with_map(map));
    self.param.register_with_map(map);
    self.body.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for SetterProp {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_key = self.key.to_java_with_map(env, map)?;
    let java_optional_this_param = match self.this_param.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_param = self.param.to_java_with_map(env, map)?;
    let java_optional_body = match self.body.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_SETTER_PROP.as_ref().unwrap() }
      .construct(env, &java_key, &java_optional_this_param, &java_param, &java_optional_body, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_this_param);
    delete_local_optional_ref!(env, java_optional_body);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_param);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for SetterProp {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_SETTER_PROP.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_key = java_class.get_key(env, jobj)?;
    let key = *PropName::from_java(env, &java_key)?;
    delete_local_ref!(env, java_key);
    let java_optional_this_param = java_class.get_this_param(env, jobj)?;
    let this_param = if optional_is_present(env, &java_optional_this_param)? {
      let java_this_param = optional_get(env, &java_optional_this_param)?;
      let this_param = *Pat::from_java(env, &java_this_param)?;
      delete_local_ref!(env, java_this_param);
      Some(this_param)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_this_param);
    let java_param = java_class.get_param(env, jobj)?;
    let param = *Pat::from_java(env, &java_param)?;
    delete_local_ref!(env, java_param);
    let param = Box::new(param);
    let java_optional_body = java_class.get_body(env, jobj)?;
    let body = if optional_is_present(env, &java_optional_body)? {
      let java_body = optional_get(env, &java_optional_body)?;
      let body = *BlockStmt::from_java(env, &java_body)?;
      delete_local_ref!(env, java_body);
      Some(body)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_body);
    Ok(Box::new(SetterProp {
      span,
      key,
      this_param,
      param,
      body,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for SpreadElement {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span());
    map.register_by_span(&self.dot3_token);
    self.expr.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for SpreadElement {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span()).to_java(env)?;
    let java_dot3_token = map.get_span_ex_by_span(&self.dot3_token).to_java(env)?;
    let java_expr = self.expr.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_SPREAD_ELEMENT.as_ref().unwrap() }
      .construct(env, &java_dot3_token, &java_expr, &java_span_ex)?;
    delete_local_ref!(env, java_dot3_token);
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for SpreadElement {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_SPREAD_ELEMENT.as_ref().unwrap() };
    let dot3_token = DUMMY_SP;
    let java_expr = java_class.get_expr(env, jobj)?;
    let expr = *Expr::from_java(env, &java_expr)?;
    delete_local_ref!(env, java_expr);
    let expr = Box::new(expr);
    Ok(Box::new(SpreadElement {
      dot3_token,
      expr,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for StaticBlock {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.body.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for StaticBlock {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_body = self.body.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_STATIC_BLOCK.as_ref().unwrap() }
      .construct(env, &java_body, &java_span_ex)?;
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for StaticBlock {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_STATIC_BLOCK.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_body = java_class.get_body(env, jobj)?;
    let body = *BlockStmt::from_java(env, &java_body)?;
    delete_local_ref!(env, java_body);
    Ok(Box::new(StaticBlock {
      span,
      body,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for Str {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Str {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let value = self.value.as_str();
    let optional_raw = self.raw.as_ref().map(|node| node.to_string());
    let return_value = unsafe { JAVA_CLASS_STR.as_ref().unwrap() }
      .construct(env, value, &optional_raw, &java_span_ex)?;
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for Str {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_STR.as_ref().unwrap() };
    let span = DUMMY_SP;
    let value = java_class.get_value(env, jobj)?;
    let value = value.into();
    let java_optional_raw = java_class.get_raw(env, jobj)?;
    let raw = if optional_is_present(env, &java_optional_raw)? {
      let java_raw = optional_get(env, &java_optional_raw)?;
      let raw: Result<String> = jstring_to_string!(env, java_raw.as_raw());
      let raw = raw?;
      delete_local_ref!(env, java_raw);
      Some(raw)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_raw);
    let raw = raw.map(|raw| raw.into());
    Ok(Box::new(Str {
      span,
      value,
      raw,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for Super {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Super {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let return_value = unsafe { JAVA_CLASS_SUPER.as_ref().unwrap() }
      .construct(env, &java_span_ex)?;
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for Super {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let span = DUMMY_SP;
    Ok(Box::new(Super {
      span,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for SuperPropExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.obj.register_with_map(map);
    self.prop.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for SuperPropExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_obj = self.obj.to_java_with_map(env, map)?;
    let java_prop = self.prop.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_SUPER_PROP_EXPR.as_ref().unwrap() }
      .construct(env, &java_obj, &java_prop, &java_span_ex)?;
    delete_local_ref!(env, java_obj);
    delete_local_ref!(env, java_prop);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for SuperPropExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_SUPER_PROP_EXPR.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_obj = java_class.get_obj(env, jobj)?;
    let obj = *Super::from_java(env, &java_obj)?;
    delete_local_ref!(env, java_obj);
    let java_prop = java_class.get_prop(env, jobj)?;
    let prop = *SuperProp::from_java(env, &java_prop)?;
    delete_local_ref!(env, java_prop);
    Ok(Box::new(SuperPropExpr {
      span,
      obj,
      prop,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for SwitchCase {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.test.as_ref().map(|node| node.register_with_map(map));
    for node in self.cons.iter() {
      node.register_with_map(map);
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for SwitchCase {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_optional_test = match self.test.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_cons = list_new(env, self.cons.len())?;
    for node in self.cons.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_cons, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let return_value = unsafe { JAVA_CLASS_SWITCH_CASE.as_ref().unwrap() }
      .construct(env, &java_optional_test, &java_cons, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_test);
    delete_local_ref!(env, java_cons);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for SwitchCase {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_SWITCH_CASE.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_optional_test = java_class.get_test(env, jobj)?;
    let test = if optional_is_present(env, &java_optional_test)? {
      let java_test = optional_get(env, &java_optional_test)?;
      let test = *Expr::from_java(env, &java_test)?;
      delete_local_ref!(env, java_test);
      Some(test)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_test);
    let test = test.map(|test| Box::new(test));
    let java_cons = java_class.get_cons(env, jobj)?;
    let length = list_size(env, &java_cons)?;
    let mut cons: Vec<Stmt> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_cons, i)?;
      let element = *Stmt::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      cons.push(element)
    }
    Ok(Box::new(SwitchCase {
      span,
      test,
      cons,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for SwitchStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.discriminant.register_with_map(map);
    for node in self.cases.iter() {
      node.register_with_map(map);
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for SwitchStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_discriminant = self.discriminant.to_java_with_map(env, map)?;
    let java_cases = list_new(env, self.cases.len())?;
    for node in self.cases.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_cases, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let return_value = unsafe { JAVA_CLASS_SWITCH_STMT.as_ref().unwrap() }
      .construct(env, &java_discriminant, &java_cases, &java_span_ex)?;
    delete_local_ref!(env, java_discriminant);
    delete_local_ref!(env, java_cases);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for SwitchStmt {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_SWITCH_STMT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_discriminant = java_class.get_discriminant(env, jobj)?;
    let discriminant = *Expr::from_java(env, &java_discriminant)?;
    delete_local_ref!(env, java_discriminant);
    let discriminant = Box::new(discriminant);
    let java_cases = java_class.get_cases(env, jobj)?;
    let length = list_size(env, &java_cases)?;
    let mut cases: Vec<SwitchCase> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_cases, i)?;
      let element = *SwitchCase::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      cases.push(element)
    }
    Ok(Box::new(SwitchStmt {
      span,
      discriminant,
      cases,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TaggedTpl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.tag.register_with_map(map);
    self.type_params.as_ref().map(|node| node.register_with_map(map));
    self.tpl.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TaggedTpl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let ctxt = self.ctxt;
    let java_tag = self.tag.to_java_with_map(env, map)?;
    let java_optional_type_params = match self.type_params.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_tpl = self.tpl.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TAGGED_TPL.as_ref().unwrap() }
      .construct(env, ctxt, &java_tag, &java_optional_type_params, &java_tpl, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_type_params);
    delete_local_ref!(env, java_tag);
    delete_local_ref!(env, java_tpl);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TaggedTpl {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TAGGED_TPL.as_ref().unwrap() };
    let span = DUMMY_SP;
    let ctxt = java_class.get_ctxt(env, jobj)?;
    let ctxt = SyntaxContext::from_u32(ctxt as u32);
    let java_tag = java_class.get_tag(env, jobj)?;
    let tag = *Expr::from_java(env, &java_tag)?;
    delete_local_ref!(env, java_tag);
    let tag = Box::new(tag);
    let java_optional_type_params = java_class.get_type_params(env, jobj)?;
    let type_params = if optional_is_present(env, &java_optional_type_params)? {
      let java_type_params = optional_get(env, &java_optional_type_params)?;
      let type_params = *TsTypeParamInstantiation::from_java(env, &java_type_params)?;
      delete_local_ref!(env, java_type_params);
      Some(type_params)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_params);
    let type_params = type_params.map(|type_params| Box::new(type_params));
    let java_tpl = java_class.get_tpl(env, jobj)?;
    let tpl = *Tpl::from_java(env, &java_tpl)?;
    delete_local_ref!(env, java_tpl);
    let tpl = Box::new(tpl);
    Ok(Box::new(TaggedTpl {
      span,
      ctxt,
      tag,
      type_params,
      tpl,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ThisExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ThisExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let return_value = unsafe { JAVA_CLASS_THIS_EXPR.as_ref().unwrap() }
      .construct(env, &java_span_ex)?;
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ThisExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let span = DUMMY_SP;
    Ok(Box::new(ThisExpr {
      span,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for ThrowStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.arg.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for ThrowStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_arg = self.arg.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_THROW_STMT.as_ref().unwrap() }
      .construct(env, &java_arg, &java_span_ex)?;
    delete_local_ref!(env, java_arg);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for ThrowStmt {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_THROW_STMT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_arg = java_class.get_arg(env, jobj)?;
    let arg = *Expr::from_java(env, &java_arg)?;
    delete_local_ref!(env, java_arg);
    let arg = Box::new(arg);
    Ok(Box::new(ThrowStmt {
      span,
      arg,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for Tpl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.exprs.iter() {
      node.register_with_map(map);
    }
    for node in self.quasis.iter() {
      node.register_with_map(map);
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for Tpl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_exprs = list_new(env, self.exprs.len())?;
    for node in self.exprs.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_exprs, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let java_quasis = list_new(env, self.quasis.len())?;
    for node in self.quasis.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_quasis, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let return_value = unsafe { JAVA_CLASS_TPL.as_ref().unwrap() }
      .construct(env, &java_exprs, &java_quasis, &java_span_ex)?;
    delete_local_ref!(env, java_exprs);
    delete_local_ref!(env, java_quasis);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for Tpl {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TPL.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_exprs = java_class.get_exprs(env, jobj)?;
    let length = list_size(env, &java_exprs)?;
    let mut exprs: Vec<Expr> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_exprs, i)?;
      let element = *Expr::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      exprs.push(element)
    }
    let exprs = exprs.into_iter().map(|exprs| Box::new(exprs)).collect();
    let java_quasis = java_class.get_quasis(env, jobj)?;
    let length = list_size(env, &java_quasis)?;
    let mut quasis: Vec<TplElement> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_quasis, i)?;
      let element = *TplElement::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      quasis.push(element)
    }
    Ok(Box::new(Tpl {
      span,
      exprs,
      quasis,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TplElement {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TplElement {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let tail = self.tail;
    let optional_cooked = self.cooked.as_ref().map(|node| node.to_string());
    let raw = self.raw.as_str();
    let return_value = unsafe { JAVA_CLASS_TPL_ELEMENT.as_ref().unwrap() }
      .construct(env, tail, &optional_cooked, raw, &java_span_ex)?;
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TplElement {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TPL_ELEMENT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let tail = java_class.is_tail(env, jobj)?;
    let java_optional_cooked = java_class.get_cooked(env, jobj)?;
    let cooked = if optional_is_present(env, &java_optional_cooked)? {
      let java_cooked = optional_get(env, &java_optional_cooked)?;
      let cooked: Result<String> = jstring_to_string!(env, java_cooked.as_raw());
      let cooked = cooked?;
      delete_local_ref!(env, java_cooked);
      Some(cooked)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_cooked);
    let cooked = cooked.map(|cooked| cooked.into());
    let raw = java_class.get_raw(env, jobj)?;
    let raw = raw.into();
    Ok(Box::new(TplElement {
      span,
      tail,
      cooked,
      raw,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TryStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.block.register_with_map(map);
    self.handler.as_ref().map(|node| node.register_with_map(map));
    self.finalizer.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TryStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_block = self.block.to_java_with_map(env, map)?;
    let java_optional_handler = match self.handler.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_optional_finalizer = match self.finalizer.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_TRY_STMT.as_ref().unwrap() }
      .construct(env, &java_block, &java_optional_handler, &java_optional_finalizer, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_handler);
    delete_local_optional_ref!(env, java_optional_finalizer);
    delete_local_ref!(env, java_block);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TryStmt {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TRY_STMT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_block = java_class.get_block(env, jobj)?;
    let block = *BlockStmt::from_java(env, &java_block)?;
    delete_local_ref!(env, java_block);
    let java_optional_handler = java_class.get_handler(env, jobj)?;
    let handler = if optional_is_present(env, &java_optional_handler)? {
      let java_handler = optional_get(env, &java_optional_handler)?;
      let handler = *CatchClause::from_java(env, &java_handler)?;
      delete_local_ref!(env, java_handler);
      Some(handler)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_handler);
    let java_optional_finalizer = java_class.get_finalizer(env, jobj)?;
    let finalizer = if optional_is_present(env, &java_optional_finalizer)? {
      let java_finalizer = optional_get(env, &java_optional_finalizer)?;
      let finalizer = *BlockStmt::from_java(env, &java_finalizer)?;
      delete_local_ref!(env, java_finalizer);
      Some(finalizer)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_finalizer);
    Ok(Box::new(TryStmt {
      span,
      block,
      handler,
      finalizer,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsArrayType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.elem_type.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsArrayType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_elem_type = self.elem_type.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TS_ARRAY_TYPE.as_ref().unwrap() }
      .construct(env, &java_elem_type, &java_span_ex)?;
    delete_local_ref!(env, java_elem_type);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsArrayType {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_ARRAY_TYPE.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_elem_type = java_class.get_elem_type(env, jobj)?;
    let elem_type = *TsType::from_java(env, &java_elem_type)?;
    delete_local_ref!(env, java_elem_type);
    let elem_type = Box::new(elem_type);
    Ok(Box::new(TsArrayType {
      span,
      elem_type,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsAsExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
    self.type_ann.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsAsExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_expr = self.expr.to_java_with_map(env, map)?;
    let java_type_ann = self.type_ann.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TS_AS_EXPR.as_ref().unwrap() }
      .construct(env, &java_expr, &java_type_ann, &java_span_ex)?;
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_type_ann);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsAsExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_AS_EXPR.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_expr = java_class.get_expr(env, jobj)?;
    let expr = *Expr::from_java(env, &java_expr)?;
    delete_local_ref!(env, java_expr);
    let expr = Box::new(expr);
    let java_type_ann = java_class.get_type_ann(env, jobj)?;
    let type_ann = *TsType::from_java(env, &java_type_ann)?;
    delete_local_ref!(env, java_type_ann);
    let type_ann = Box::new(type_ann);
    Ok(Box::new(TsAsExpr {
      span,
      expr,
      type_ann,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsCallSignatureDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.params.iter() {
      node.register_with_map(map);
    }
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
    self.type_params.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsCallSignatureDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_params = list_new(env, self.params.len())?;
    for node in self.params.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_params, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let java_optional_type_ann = match self.type_ann.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_optional_type_params = match self.type_params.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_TS_CALL_SIGNATURE_DECL.as_ref().unwrap() }
      .construct(env, &java_params, &java_optional_type_ann, &java_optional_type_params, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_optional_ref!(env, java_optional_type_params);
    delete_local_ref!(env, java_params);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsCallSignatureDecl {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_CALL_SIGNATURE_DECL.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_params = java_class.get_params(env, jobj)?;
    let length = list_size(env, &java_params)?;
    let mut params: Vec<TsFnParam> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_params, i)?;
      let element = *TsFnParam::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      params.push(element)
    }
    let java_optional_type_ann = java_class.get_type_ann(env, jobj)?;
    let type_ann = if optional_is_present(env, &java_optional_type_ann)? {
      let java_type_ann = optional_get(env, &java_optional_type_ann)?;
      let type_ann = *TsTypeAnn::from_java(env, &java_type_ann)?;
      delete_local_ref!(env, java_type_ann);
      Some(type_ann)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_ann);
    let type_ann = type_ann.map(|type_ann| Box::new(type_ann));
    let java_optional_type_params = java_class.get_type_params(env, jobj)?;
    let type_params = if optional_is_present(env, &java_optional_type_params)? {
      let java_type_params = optional_get(env, &java_optional_type_params)?;
      let type_params = *TsTypeParamDecl::from_java(env, &java_type_params)?;
      delete_local_ref!(env, java_type_params);
      Some(type_params)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_params);
    let type_params = type_params.map(|type_params| Box::new(type_params));
    Ok(Box::new(TsCallSignatureDecl {
      span,
      params,
      type_ann,
      type_params,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsConditionalType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.check_type.register_with_map(map);
    self.extends_type.register_with_map(map);
    self.true_type.register_with_map(map);
    self.false_type.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsConditionalType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_check_type = self.check_type.to_java_with_map(env, map)?;
    let java_extends_type = self.extends_type.to_java_with_map(env, map)?;
    let java_true_type = self.true_type.to_java_with_map(env, map)?;
    let java_false_type = self.false_type.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TS_CONDITIONAL_TYPE.as_ref().unwrap() }
      .construct(env, &java_check_type, &java_extends_type, &java_true_type, &java_false_type, &java_span_ex)?;
    delete_local_ref!(env, java_check_type);
    delete_local_ref!(env, java_extends_type);
    delete_local_ref!(env, java_true_type);
    delete_local_ref!(env, java_false_type);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsConditionalType {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_CONDITIONAL_TYPE.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_check_type = java_class.get_check_type(env, jobj)?;
    let check_type = *TsType::from_java(env, &java_check_type)?;
    delete_local_ref!(env, java_check_type);
    let check_type = Box::new(check_type);
    let java_extends_type = java_class.get_extends_type(env, jobj)?;
    let extends_type = *TsType::from_java(env, &java_extends_type)?;
    delete_local_ref!(env, java_extends_type);
    let extends_type = Box::new(extends_type);
    let java_true_type = java_class.get_true_type(env, jobj)?;
    let true_type = *TsType::from_java(env, &java_true_type)?;
    delete_local_ref!(env, java_true_type);
    let true_type = Box::new(true_type);
    let java_false_type = java_class.get_false_type(env, jobj)?;
    let false_type = *TsType::from_java(env, &java_false_type)?;
    delete_local_ref!(env, java_false_type);
    let false_type = Box::new(false_type);
    Ok(Box::new(TsConditionalType {
      span,
      check_type,
      extends_type,
      true_type,
      false_type,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsConstAssertion {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsConstAssertion {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_expr = self.expr.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TS_CONST_ASSERTION.as_ref().unwrap() }
      .construct(env, &java_expr, &java_span_ex)?;
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsConstAssertion {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_CONST_ASSERTION.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_expr = java_class.get_expr(env, jobj)?;
    let expr = *Expr::from_java(env, &java_expr)?;
    delete_local_ref!(env, java_expr);
    let expr = Box::new(expr);
    Ok(Box::new(TsConstAssertion {
      span,
      expr,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsConstructSignatureDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.params.iter() {
      node.register_with_map(map);
    }
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
    self.type_params.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsConstructSignatureDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_params = list_new(env, self.params.len())?;
    for node in self.params.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_params, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let java_optional_type_ann = match self.type_ann.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_optional_type_params = match self.type_params.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_TS_CONSTRUCT_SIGNATURE_DECL.as_ref().unwrap() }
      .construct(env, &java_params, &java_optional_type_ann, &java_optional_type_params, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_optional_ref!(env, java_optional_type_params);
    delete_local_ref!(env, java_params);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsConstructSignatureDecl {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_CONSTRUCT_SIGNATURE_DECL.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_params = java_class.get_params(env, jobj)?;
    let length = list_size(env, &java_params)?;
    let mut params: Vec<TsFnParam> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_params, i)?;
      let element = *TsFnParam::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      params.push(element)
    }
    let java_optional_type_ann = java_class.get_type_ann(env, jobj)?;
    let type_ann = if optional_is_present(env, &java_optional_type_ann)? {
      let java_type_ann = optional_get(env, &java_optional_type_ann)?;
      let type_ann = *TsTypeAnn::from_java(env, &java_type_ann)?;
      delete_local_ref!(env, java_type_ann);
      Some(type_ann)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_ann);
    let type_ann = type_ann.map(|type_ann| Box::new(type_ann));
    let java_optional_type_params = java_class.get_type_params(env, jobj)?;
    let type_params = if optional_is_present(env, &java_optional_type_params)? {
      let java_type_params = optional_get(env, &java_optional_type_params)?;
      let type_params = *TsTypeParamDecl::from_java(env, &java_type_params)?;
      delete_local_ref!(env, java_type_params);
      Some(type_params)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_params);
    let type_params = type_params.map(|type_params| Box::new(type_params));
    Ok(Box::new(TsConstructSignatureDecl {
      span,
      params,
      type_ann,
      type_params,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsConstructorType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.params.iter() {
      node.register_with_map(map);
    }
    self.type_params.as_ref().map(|node| node.register_with_map(map));
    self.type_ann.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsConstructorType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_params = list_new(env, self.params.len())?;
    for node in self.params.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_params, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let java_optional_type_params = match self.type_params.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_type_ann = self.type_ann.to_java_with_map(env, map)?;
    let is_abstract = self.is_abstract;
    let return_value = unsafe { JAVA_CLASS_TS_CONSTRUCTOR_TYPE.as_ref().unwrap() }
      .construct(env, &java_params, &java_optional_type_params, &java_type_ann, is_abstract, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_type_params);
    delete_local_ref!(env, java_params);
    delete_local_ref!(env, java_type_ann);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsConstructorType {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_CONSTRUCTOR_TYPE.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_params = java_class.get_params(env, jobj)?;
    let length = list_size(env, &java_params)?;
    let mut params: Vec<TsFnParam> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_params, i)?;
      let element = *TsFnParam::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      params.push(element)
    }
    let java_optional_type_params = java_class.get_type_params(env, jobj)?;
    let type_params = if optional_is_present(env, &java_optional_type_params)? {
      let java_type_params = optional_get(env, &java_optional_type_params)?;
      let type_params = *TsTypeParamDecl::from_java(env, &java_type_params)?;
      delete_local_ref!(env, java_type_params);
      Some(type_params)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_params);
    let type_params = type_params.map(|type_params| Box::new(type_params));
    let java_type_ann = java_class.get_type_ann(env, jobj)?;
    let type_ann = *TsTypeAnn::from_java(env, &java_type_ann)?;
    delete_local_ref!(env, java_type_ann);
    let type_ann = Box::new(type_ann);
    let is_abstract = java_class.is_abstract(env, jobj)?;
    Ok(Box::new(TsConstructorType {
      span,
      params,
      type_params,
      type_ann,
      is_abstract,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsEnumDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.id.register_with_map(map);
    for node in self.members.iter() {
      node.register_with_map(map);
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsEnumDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let declare = self.declare;
    let is_const = self.is_const;
    let java_id = self.id.to_java_with_map(env, map)?;
    let java_members = list_new(env, self.members.len())?;
    for node in self.members.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_members, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let return_value = unsafe { JAVA_CLASS_TS_ENUM_DECL.as_ref().unwrap() }
      .construct(env, declare, is_const, &java_id, &java_members, &java_span_ex)?;
    delete_local_ref!(env, java_id);
    delete_local_ref!(env, java_members);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsEnumDecl {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_ENUM_DECL.as_ref().unwrap() };
    let span = DUMMY_SP;
    let declare = java_class.is_declare(env, jobj)?;
    let is_const = java_class.is_const(env, jobj)?;
    let java_id = java_class.get_id(env, jobj)?;
    let id = *Ident::from_java(env, &java_id)?;
    delete_local_ref!(env, java_id);
    let java_members = java_class.get_members(env, jobj)?;
    let length = list_size(env, &java_members)?;
    let mut members: Vec<TsEnumMember> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_members, i)?;
      let element = *TsEnumMember::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      members.push(element)
    }
    Ok(Box::new(TsEnumDecl {
      span,
      declare,
      is_const,
      id,
      members,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsEnumMember {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.id.register_with_map(map);
    self.init.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsEnumMember {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_id = self.id.to_java_with_map(env, map)?;
    let java_optional_init = match self.init.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_TS_ENUM_MEMBER.as_ref().unwrap() }
      .construct(env, &java_id, &java_optional_init, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_init);
    delete_local_ref!(env, java_id);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsEnumMember {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_ENUM_MEMBER.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_id = java_class.get_id(env, jobj)?;
    let id = *TsEnumMemberId::from_java(env, &java_id)?;
    delete_local_ref!(env, java_id);
    let java_optional_init = java_class.get_init(env, jobj)?;
    let init = if optional_is_present(env, &java_optional_init)? {
      let java_init = optional_get(env, &java_optional_init)?;
      let init = *Expr::from_java(env, &java_init)?;
      delete_local_ref!(env, java_init);
      Some(init)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_init);
    let init = init.map(|init| Box::new(init));
    Ok(Box::new(TsEnumMember {
      span,
      id,
      init,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsExportAssignment {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsExportAssignment {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_expr = self.expr.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TS_EXPORT_ASSIGNMENT.as_ref().unwrap() }
      .construct(env, &java_expr, &java_span_ex)?;
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsExportAssignment {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_EXPORT_ASSIGNMENT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_expr = java_class.get_expr(env, jobj)?;
    let expr = *Expr::from_java(env, &java_expr)?;
    delete_local_ref!(env, java_expr);
    let expr = Box::new(expr);
    Ok(Box::new(TsExportAssignment {
      span,
      expr,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsExprWithTypeArgs {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
    self.type_args.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsExprWithTypeArgs {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_expr = self.expr.to_java_with_map(env, map)?;
    let java_optional_type_args = match self.type_args.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_TS_EXPR_WITH_TYPE_ARGS.as_ref().unwrap() }
      .construct(env, &java_expr, &java_optional_type_args, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_type_args);
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsExprWithTypeArgs {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_EXPR_WITH_TYPE_ARGS.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_expr = java_class.get_expr(env, jobj)?;
    let expr = *Expr::from_java(env, &java_expr)?;
    delete_local_ref!(env, java_expr);
    let expr = Box::new(expr);
    let java_optional_type_args = java_class.get_type_args(env, jobj)?;
    let type_args = if optional_is_present(env, &java_optional_type_args)? {
      let java_type_args = optional_get(env, &java_optional_type_args)?;
      let type_args = *TsTypeParamInstantiation::from_java(env, &java_type_args)?;
      delete_local_ref!(env, java_type_args);
      Some(type_args)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_args);
    let type_args = type_args.map(|type_args| Box::new(type_args));
    Ok(Box::new(TsExprWithTypeArgs {
      span,
      expr,
      type_args,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsExternalModuleRef {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsExternalModuleRef {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_expr = self.expr.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TS_EXTERNAL_MODULE_REF.as_ref().unwrap() }
      .construct(env, &java_expr, &java_span_ex)?;
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsExternalModuleRef {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_EXTERNAL_MODULE_REF.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_expr = java_class.get_expr(env, jobj)?;
    let expr = *Str::from_java(env, &java_expr)?;
    delete_local_ref!(env, java_expr);
    Ok(Box::new(TsExternalModuleRef {
      span,
      expr,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsFnType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.params.iter() {
      node.register_with_map(map);
    }
    self.type_params.as_ref().map(|node| node.register_with_map(map));
    self.type_ann.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsFnType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_params = list_new(env, self.params.len())?;
    for node in self.params.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_params, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let java_optional_type_params = match self.type_params.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_type_ann = self.type_ann.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TS_FN_TYPE.as_ref().unwrap() }
      .construct(env, &java_params, &java_optional_type_params, &java_type_ann, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_type_params);
    delete_local_ref!(env, java_params);
    delete_local_ref!(env, java_type_ann);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsFnType {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_FN_TYPE.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_params = java_class.get_params(env, jobj)?;
    let length = list_size(env, &java_params)?;
    let mut params: Vec<TsFnParam> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_params, i)?;
      let element = *TsFnParam::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      params.push(element)
    }
    let java_optional_type_params = java_class.get_type_params(env, jobj)?;
    let type_params = if optional_is_present(env, &java_optional_type_params)? {
      let java_type_params = optional_get(env, &java_optional_type_params)?;
      let type_params = *TsTypeParamDecl::from_java(env, &java_type_params)?;
      delete_local_ref!(env, java_type_params);
      Some(type_params)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_params);
    let type_params = type_params.map(|type_params| Box::new(type_params));
    let java_type_ann = java_class.get_type_ann(env, jobj)?;
    let type_ann = *TsTypeAnn::from_java(env, &java_type_ann)?;
    delete_local_ref!(env, java_type_ann);
    let type_ann = Box::new(type_ann);
    Ok(Box::new(TsFnType {
      span,
      params,
      type_params,
      type_ann,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsGetterSignature {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.key.register_with_map(map);
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsGetterSignature {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_key = self.key.to_java_with_map(env, map)?;
    let computed = self.computed;
    let java_optional_type_ann = match self.type_ann.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_TS_GETTER_SIGNATURE.as_ref().unwrap() }
      .construct(env, &java_key, computed, &java_optional_type_ann, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsGetterSignature {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_GETTER_SIGNATURE.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_key = java_class.get_key(env, jobj)?;
    let key = *Expr::from_java(env, &java_key)?;
    delete_local_ref!(env, java_key);
    let key = Box::new(key);
    let computed = java_class.is_computed(env, jobj)?;
    let java_optional_type_ann = java_class.get_type_ann(env, jobj)?;
    let type_ann = if optional_is_present(env, &java_optional_type_ann)? {
      let java_type_ann = optional_get(env, &java_optional_type_ann)?;
      let type_ann = *TsTypeAnn::from_java(env, &java_type_ann)?;
      delete_local_ref!(env, java_type_ann);
      Some(type_ann)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_ann);
    let type_ann = type_ann.map(|type_ann| Box::new(type_ann));
    Ok(Box::new(TsGetterSignature {
      span,
      key,
      computed,
      type_ann,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsImportEqualsDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.id.register_with_map(map);
    self.module_ref.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsImportEqualsDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let is_export = self.is_export;
    let is_type_only = self.is_type_only;
    let java_id = self.id.to_java_with_map(env, map)?;
    let java_module_ref = self.module_ref.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TS_IMPORT_EQUALS_DECL.as_ref().unwrap() }
      .construct(env, is_export, is_type_only, &java_id, &java_module_ref, &java_span_ex)?;
    delete_local_ref!(env, java_id);
    delete_local_ref!(env, java_module_ref);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsImportEqualsDecl {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_IMPORT_EQUALS_DECL.as_ref().unwrap() };
    let span = DUMMY_SP;
    let is_export = java_class.is_export(env, jobj)?;
    let is_type_only = java_class.is_type_only(env, jobj)?;
    let java_id = java_class.get_id(env, jobj)?;
    let id = *Ident::from_java(env, &java_id)?;
    delete_local_ref!(env, java_id);
    let java_module_ref = java_class.get_module_ref(env, jobj)?;
    let module_ref = *TsModuleRef::from_java(env, &java_module_ref)?;
    delete_local_ref!(env, java_module_ref);
    Ok(Box::new(TsImportEqualsDecl {
      span,
      is_export,
      is_type_only,
      id,
      module_ref,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsImportType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.arg.register_with_map(map);
    self.qualifier.as_ref().map(|node| node.register_with_map(map));
    self.type_args.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsImportType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_arg = self.arg.to_java_with_map(env, map)?;
    let java_optional_qualifier = match self.qualifier.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_optional_type_args = match self.type_args.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_TS_IMPORT_TYPE.as_ref().unwrap() }
      .construct(env, &java_arg, &java_optional_qualifier, &java_optional_type_args, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_qualifier);
    delete_local_optional_ref!(env, java_optional_type_args);
    delete_local_ref!(env, java_arg);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsImportType {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_IMPORT_TYPE.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_arg = java_class.get_arg(env, jobj)?;
    let arg = *Str::from_java(env, &java_arg)?;
    delete_local_ref!(env, java_arg);
    let java_optional_qualifier = java_class.get_qualifier(env, jobj)?;
    let qualifier = if optional_is_present(env, &java_optional_qualifier)? {
      let java_qualifier = optional_get(env, &java_optional_qualifier)?;
      let qualifier = *TsEntityName::from_java(env, &java_qualifier)?;
      delete_local_ref!(env, java_qualifier);
      Some(qualifier)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_qualifier);
    let java_optional_type_args = java_class.get_type_args(env, jobj)?;
    let type_args = if optional_is_present(env, &java_optional_type_args)? {
      let java_type_args = optional_get(env, &java_optional_type_args)?;
      let type_args = *TsTypeParamInstantiation::from_java(env, &java_type_args)?;
      delete_local_ref!(env, java_type_args);
      Some(type_args)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_args);
    let type_args = type_args.map(|type_args| Box::new(type_args));
    Ok(Box::new(TsImportType {
      span,
      arg,
      qualifier,
      type_args,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsIndexSignature {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.params.iter() {
      node.register_with_map(map);
    }
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsIndexSignature {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_params = list_new(env, self.params.len())?;
    for node in self.params.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_params, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let java_optional_type_ann = match self.type_ann.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let readonly = self.readonly;
    let is_static = self.is_static;
    let return_value = unsafe { JAVA_CLASS_TS_INDEX_SIGNATURE.as_ref().unwrap() }
      .construct(env, &java_params, &java_optional_type_ann, readonly, is_static, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_ref!(env, java_params);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsIndexSignature {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_INDEX_SIGNATURE.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_params = java_class.get_params(env, jobj)?;
    let length = list_size(env, &java_params)?;
    let mut params: Vec<TsFnParam> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_params, i)?;
      let element = *TsFnParam::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      params.push(element)
    }
    let java_optional_type_ann = java_class.get_type_ann(env, jobj)?;
    let type_ann = if optional_is_present(env, &java_optional_type_ann)? {
      let java_type_ann = optional_get(env, &java_optional_type_ann)?;
      let type_ann = *TsTypeAnn::from_java(env, &java_type_ann)?;
      delete_local_ref!(env, java_type_ann);
      Some(type_ann)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_ann);
    let type_ann = type_ann.map(|type_ann| Box::new(type_ann));
    let readonly = java_class.is_readonly(env, jobj)?;
    let is_static = java_class.is_static(env, jobj)?;
    Ok(Box::new(TsIndexSignature {
      span,
      params,
      type_ann,
      readonly,
      is_static,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsIndexedAccessType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.obj_type.register_with_map(map);
    self.index_type.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsIndexedAccessType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let readonly = self.readonly;
    let java_obj_type = self.obj_type.to_java_with_map(env, map)?;
    let java_index_type = self.index_type.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TS_INDEXED_ACCESS_TYPE.as_ref().unwrap() }
      .construct(env, readonly, &java_obj_type, &java_index_type, &java_span_ex)?;
    delete_local_ref!(env, java_obj_type);
    delete_local_ref!(env, java_index_type);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsIndexedAccessType {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_INDEXED_ACCESS_TYPE.as_ref().unwrap() };
    let span = DUMMY_SP;
    let readonly = java_class.is_readonly(env, jobj)?;
    let java_obj_type = java_class.get_obj_type(env, jobj)?;
    let obj_type = *TsType::from_java(env, &java_obj_type)?;
    delete_local_ref!(env, java_obj_type);
    let obj_type = Box::new(obj_type);
    let java_index_type = java_class.get_index_type(env, jobj)?;
    let index_type = *TsType::from_java(env, &java_index_type)?;
    delete_local_ref!(env, java_index_type);
    let index_type = Box::new(index_type);
    Ok(Box::new(TsIndexedAccessType {
      span,
      readonly,
      obj_type,
      index_type,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsInferType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.type_param.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsInferType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_type_param = self.type_param.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TS_INFER_TYPE.as_ref().unwrap() }
      .construct(env, &java_type_param, &java_span_ex)?;
    delete_local_ref!(env, java_type_param);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsInferType {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_INFER_TYPE.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_type_param = java_class.get_type_param(env, jobj)?;
    let type_param = *TsTypeParam::from_java(env, &java_type_param)?;
    delete_local_ref!(env, java_type_param);
    Ok(Box::new(TsInferType {
      span,
      type_param,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsInstantiation {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
    self.type_args.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsInstantiation {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_expr = self.expr.to_java_with_map(env, map)?;
    let java_type_args = self.type_args.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TS_INSTANTIATION.as_ref().unwrap() }
      .construct(env, &java_expr, &java_type_args, &java_span_ex)?;
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_type_args);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsInstantiation {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_INSTANTIATION.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_expr = java_class.get_expr(env, jobj)?;
    let expr = *Expr::from_java(env, &java_expr)?;
    delete_local_ref!(env, java_expr);
    let expr = Box::new(expr);
    let java_type_args = java_class.get_type_args(env, jobj)?;
    let type_args = *TsTypeParamInstantiation::from_java(env, &java_type_args)?;
    delete_local_ref!(env, java_type_args);
    let type_args = Box::new(type_args);
    Ok(Box::new(TsInstantiation {
      span,
      expr,
      type_args,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsInterfaceBody {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.body.iter() {
      node.register_with_map(map);
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsInterfaceBody {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_body = list_new(env, self.body.len())?;
    for node in self.body.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_body, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let return_value = unsafe { JAVA_CLASS_TS_INTERFACE_BODY.as_ref().unwrap() }
      .construct(env, &java_body, &java_span_ex)?;
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsInterfaceBody {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_INTERFACE_BODY.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_body = java_class.get_body(env, jobj)?;
    let length = list_size(env, &java_body)?;
    let mut body: Vec<TsTypeElement> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_body, i)?;
      let element = *TsTypeElement::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      body.push(element)
    }
    Ok(Box::new(TsInterfaceBody {
      span,
      body,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsInterfaceDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.id.register_with_map(map);
    self.type_params.as_ref().map(|node| node.register_with_map(map));
    for node in self.extends.iter() {
      node.register_with_map(map);
    }
    self.body.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsInterfaceDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_id = self.id.to_java_with_map(env, map)?;
    let declare = self.declare;
    let java_optional_type_params = match self.type_params.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_extends = list_new(env, self.extends.len())?;
    for node in self.extends.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_extends, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let java_body = self.body.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TS_INTERFACE_DECL.as_ref().unwrap() }
      .construct(env, &java_id, declare, &java_optional_type_params, &java_extends, &java_body, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_type_params);
    delete_local_ref!(env, java_id);
    delete_local_ref!(env, java_extends);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsInterfaceDecl {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_INTERFACE_DECL.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_id = java_class.get_id(env, jobj)?;
    let id = *Ident::from_java(env, &java_id)?;
    delete_local_ref!(env, java_id);
    let declare = java_class.is_declare(env, jobj)?;
    let java_optional_type_params = java_class.get_type_params(env, jobj)?;
    let type_params = if optional_is_present(env, &java_optional_type_params)? {
      let java_type_params = optional_get(env, &java_optional_type_params)?;
      let type_params = *TsTypeParamDecl::from_java(env, &java_type_params)?;
      delete_local_ref!(env, java_type_params);
      Some(type_params)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_params);
    let type_params = type_params.map(|type_params| Box::new(type_params));
    let java_extends = java_class.get_extends(env, jobj)?;
    let length = list_size(env, &java_extends)?;
    let mut extends: Vec<TsExprWithTypeArgs> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_extends, i)?;
      let element = *TsExprWithTypeArgs::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      extends.push(element)
    }
    let java_body = java_class.get_body(env, jobj)?;
    let body = *TsInterfaceBody::from_java(env, &java_body)?;
    delete_local_ref!(env, java_body);
    Ok(Box::new(TsInterfaceDecl {
      span,
      id,
      declare,
      type_params,
      extends,
      body,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsIntersectionType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.types.iter() {
      node.register_with_map(map);
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsIntersectionType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_types = list_new(env, self.types.len())?;
    for node in self.types.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_types, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let return_value = unsafe { JAVA_CLASS_TS_INTERSECTION_TYPE.as_ref().unwrap() }
      .construct(env, &java_types, &java_span_ex)?;
    delete_local_ref!(env, java_types);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsIntersectionType {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_INTERSECTION_TYPE.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_types = java_class.get_types(env, jobj)?;
    let length = list_size(env, &java_types)?;
    let mut types: Vec<TsType> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_types, i)?;
      let element = *TsType::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      types.push(element)
    }
    let types = types.into_iter().map(|types| Box::new(types)).collect();
    Ok(Box::new(TsIntersectionType {
      span,
      types,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsKeywordType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsKeywordType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_kind = self.kind.to_java(env)?;
    let return_value = unsafe { JAVA_CLASS_TS_KEYWORD_TYPE.as_ref().unwrap() }
      .construct(env, &java_kind, &java_span_ex)?;
    delete_local_ref!(env, java_kind);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsKeywordType {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_KEYWORD_TYPE.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_kind = java_class.get_kind(env, jobj)?;
    let kind = *TsKeywordTypeKind::from_java(env, &java_kind)?;
    delete_local_ref!(env, java_kind);
    Ok(Box::new(TsKeywordType {
      span,
      kind,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsLitType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.lit.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsLitType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_lit = self.lit.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TS_LIT_TYPE.as_ref().unwrap() }
      .construct(env, &java_lit, &java_span_ex)?;
    delete_local_ref!(env, java_lit);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsLitType {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_LIT_TYPE.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_lit = java_class.get_lit(env, jobj)?;
    let lit = *TsLit::from_java(env, &java_lit)?;
    delete_local_ref!(env, java_lit);
    Ok(Box::new(TsLitType {
      span,
      lit,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsMappedType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.type_param.register_with_map(map);
    self.name_type.as_ref().map(|node| node.register_with_map(map));
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsMappedType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_optional_readonly = match self.readonly.as_ref() {
      Some(node) => Some(node.to_java(env)?),
      None => None,
    };
    let java_type_param = self.type_param.to_java_with_map(env, map)?;
    let java_optional_name_type = match self.name_type.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_optional_optional = match self.optional.as_ref() {
      Some(node) => Some(node.to_java(env)?),
      None => None,
    };
    let java_optional_type_ann = match self.type_ann.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_TS_MAPPED_TYPE.as_ref().unwrap() }
      .construct(env, &java_optional_readonly, &java_type_param, &java_optional_name_type, &java_optional_optional, &java_optional_type_ann, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_readonly);
    delete_local_optional_ref!(env, java_optional_name_type);
    delete_local_optional_ref!(env, java_optional_optional);
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_ref!(env, java_type_param);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsMappedType {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_MAPPED_TYPE.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_optional_readonly = java_class.get_readonly(env, jobj)?;
    let readonly = if optional_is_present(env, &java_optional_readonly)? {
      let java_readonly = optional_get(env, &java_optional_readonly)?;
      let readonly = *TruePlusMinus::from_java(env, &java_readonly)?;
      delete_local_ref!(env, java_readonly);
      Some(readonly)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_readonly);
    let java_type_param = java_class.get_type_param(env, jobj)?;
    let type_param = *TsTypeParam::from_java(env, &java_type_param)?;
    delete_local_ref!(env, java_type_param);
    let java_optional_name_type = java_class.get_name_type(env, jobj)?;
    let name_type = if optional_is_present(env, &java_optional_name_type)? {
      let java_name_type = optional_get(env, &java_optional_name_type)?;
      let name_type = *TsType::from_java(env, &java_name_type)?;
      delete_local_ref!(env, java_name_type);
      Some(name_type)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_name_type);
    let name_type = name_type.map(|name_type| Box::new(name_type));
    let java_optional_optional = java_class.get_optional(env, jobj)?;
    let optional = if optional_is_present(env, &java_optional_optional)? {
      let java_optional = optional_get(env, &java_optional_optional)?;
      let optional = *TruePlusMinus::from_java(env, &java_optional)?;
      delete_local_ref!(env, java_optional);
      Some(optional)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_optional);
    let java_optional_type_ann = java_class.get_type_ann(env, jobj)?;
    let type_ann = if optional_is_present(env, &java_optional_type_ann)? {
      let java_type_ann = optional_get(env, &java_optional_type_ann)?;
      let type_ann = *TsType::from_java(env, &java_type_ann)?;
      delete_local_ref!(env, java_type_ann);
      Some(type_ann)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_ann);
    let type_ann = type_ann.map(|type_ann| Box::new(type_ann));
    Ok(Box::new(TsMappedType {
      span,
      readonly,
      type_param,
      name_type,
      optional,
      type_ann,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsMethodSignature {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.key.register_with_map(map);
    for node in self.params.iter() {
      node.register_with_map(map);
    }
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
    self.type_params.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsMethodSignature {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_key = self.key.to_java_with_map(env, map)?;
    let computed = self.computed;
    let optional = self.optional;
    let java_params = list_new(env, self.params.len())?;
    for node in self.params.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_params, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let java_optional_type_ann = match self.type_ann.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_optional_type_params = match self.type_params.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_TS_METHOD_SIGNATURE.as_ref().unwrap() }
      .construct(env, &java_key, computed, optional, &java_params, &java_optional_type_ann, &java_optional_type_params, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_optional_ref!(env, java_optional_type_params);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_params);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsMethodSignature {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_METHOD_SIGNATURE.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_key = java_class.get_key(env, jobj)?;
    let key = *Expr::from_java(env, &java_key)?;
    delete_local_ref!(env, java_key);
    let key = Box::new(key);
    let computed = java_class.is_computed(env, jobj)?;
    let optional = java_class.is_optional(env, jobj)?;
    let java_params = java_class.get_params(env, jobj)?;
    let length = list_size(env, &java_params)?;
    let mut params: Vec<TsFnParam> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_params, i)?;
      let element = *TsFnParam::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      params.push(element)
    }
    let java_optional_type_ann = java_class.get_type_ann(env, jobj)?;
    let type_ann = if optional_is_present(env, &java_optional_type_ann)? {
      let java_type_ann = optional_get(env, &java_optional_type_ann)?;
      let type_ann = *TsTypeAnn::from_java(env, &java_type_ann)?;
      delete_local_ref!(env, java_type_ann);
      Some(type_ann)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_ann);
    let type_ann = type_ann.map(|type_ann| Box::new(type_ann));
    let java_optional_type_params = java_class.get_type_params(env, jobj)?;
    let type_params = if optional_is_present(env, &java_optional_type_params)? {
      let java_type_params = optional_get(env, &java_optional_type_params)?;
      let type_params = *TsTypeParamDecl::from_java(env, &java_type_params)?;
      delete_local_ref!(env, java_type_params);
      Some(type_params)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_params);
    let type_params = type_params.map(|type_params| Box::new(type_params));
    Ok(Box::new(TsMethodSignature {
      span,
      key,
      computed,
      optional,
      params,
      type_ann,
      type_params,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsModuleBlock {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.body.iter() {
      node.register_with_map(map);
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsModuleBlock {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_body = list_new(env, self.body.len())?;
    for node in self.body.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_body, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let return_value = unsafe { JAVA_CLASS_TS_MODULE_BLOCK.as_ref().unwrap() }
      .construct(env, &java_body, &java_span_ex)?;
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsModuleBlock {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_MODULE_BLOCK.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_body = java_class.get_body(env, jobj)?;
    let length = list_size(env, &java_body)?;
    let mut body: Vec<ModuleItem> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_body, i)?;
      let element = *ModuleItem::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      body.push(element)
    }
    Ok(Box::new(TsModuleBlock {
      span,
      body,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsModuleDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.id.register_with_map(map);
    self.body.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsModuleDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let declare = self.declare;
    let global = self.global;
    let java_id = self.id.to_java_with_map(env, map)?;
    let java_optional_body = match self.body.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_TS_MODULE_DECL.as_ref().unwrap() }
      .construct(env, declare, global, &java_id, &java_optional_body, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_body);
    delete_local_ref!(env, java_id);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsModuleDecl {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_MODULE_DECL.as_ref().unwrap() };
    let span = DUMMY_SP;
    let declare = java_class.is_declare(env, jobj)?;
    let global = java_class.is_global(env, jobj)?;
    let java_id = java_class.get_id(env, jobj)?;
    let id = *TsModuleName::from_java(env, &java_id)?;
    delete_local_ref!(env, java_id);
    let java_optional_body = java_class.get_body(env, jobj)?;
    let body = if optional_is_present(env, &java_optional_body)? {
      let java_body = optional_get(env, &java_optional_body)?;
      let body = *TsNamespaceBody::from_java(env, &java_body)?;
      delete_local_ref!(env, java_body);
      Some(body)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_body);
    Ok(Box::new(TsModuleDecl {
      span,
      declare,
      global,
      id,
      body,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsNamespaceDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.id.register_with_map(map);
    self.body.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsNamespaceDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let declare = self.declare;
    let global = self.global;
    let java_id = self.id.to_java_with_map(env, map)?;
    let java_body = self.body.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TS_NAMESPACE_DECL.as_ref().unwrap() }
      .construct(env, declare, global, &java_id, &java_body, &java_span_ex)?;
    delete_local_ref!(env, java_id);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsNamespaceDecl {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_NAMESPACE_DECL.as_ref().unwrap() };
    let span = DUMMY_SP;
    let declare = java_class.is_declare(env, jobj)?;
    let global = java_class.is_global(env, jobj)?;
    let java_id = java_class.get_id(env, jobj)?;
    let id = *Ident::from_java(env, &java_id)?;
    delete_local_ref!(env, java_id);
    let java_body = java_class.get_body(env, jobj)?;
    let body = *TsNamespaceBody::from_java(env, &java_body)?;
    delete_local_ref!(env, java_body);
    let body = Box::new(body);
    Ok(Box::new(TsNamespaceDecl {
      span,
      declare,
      global,
      id,
      body,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsNamespaceExportDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.id.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsNamespaceExportDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_id = self.id.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TS_NAMESPACE_EXPORT_DECL.as_ref().unwrap() }
      .construct(env, &java_id, &java_span_ex)?;
    delete_local_ref!(env, java_id);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsNamespaceExportDecl {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_NAMESPACE_EXPORT_DECL.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_id = java_class.get_id(env, jobj)?;
    let id = *Ident::from_java(env, &java_id)?;
    delete_local_ref!(env, java_id);
    Ok(Box::new(TsNamespaceExportDecl {
      span,
      id,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsNonNullExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsNonNullExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_expr = self.expr.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TS_NON_NULL_EXPR.as_ref().unwrap() }
      .construct(env, &java_expr, &java_span_ex)?;
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsNonNullExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_NON_NULL_EXPR.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_expr = java_class.get_expr(env, jobj)?;
    let expr = *Expr::from_java(env, &java_expr)?;
    delete_local_ref!(env, java_expr);
    let expr = Box::new(expr);
    Ok(Box::new(TsNonNullExpr {
      span,
      expr,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsOptionalType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.type_ann.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsOptionalType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_type_ann = self.type_ann.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TS_OPTIONAL_TYPE.as_ref().unwrap() }
      .construct(env, &java_type_ann, &java_span_ex)?;
    delete_local_ref!(env, java_type_ann);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsOptionalType {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_OPTIONAL_TYPE.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_type_ann = java_class.get_type_ann(env, jobj)?;
    let type_ann = *TsType::from_java(env, &java_type_ann)?;
    delete_local_ref!(env, java_type_ann);
    let type_ann = Box::new(type_ann);
    Ok(Box::new(TsOptionalType {
      span,
      type_ann,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsParamProp {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.decorators.iter() {
      node.register_with_map(map);
    }
    self.param.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsParamProp {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_decorators = list_new(env, self.decorators.len())?;
    for node in self.decorators.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_decorators, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let java_optional_accessibility = match self.accessibility.as_ref() {
      Some(node) => Some(node.to_java(env)?),
      None => None,
    };
    let is_override = self.is_override;
    let readonly = self.readonly;
    let java_param = self.param.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TS_PARAM_PROP.as_ref().unwrap() }
      .construct(env, &java_decorators, &java_optional_accessibility, is_override, readonly, &java_param, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_accessibility);
    delete_local_ref!(env, java_decorators);
    delete_local_ref!(env, java_param);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsParamProp {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_PARAM_PROP.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_decorators = java_class.get_decorators(env, jobj)?;
    let length = list_size(env, &java_decorators)?;
    let mut decorators: Vec<Decorator> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_decorators, i)?;
      let element = *Decorator::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      decorators.push(element)
    }
    let java_optional_accessibility = java_class.get_accessibility(env, jobj)?;
    let accessibility = if optional_is_present(env, &java_optional_accessibility)? {
      let java_accessibility = optional_get(env, &java_optional_accessibility)?;
      let accessibility = *Accessibility::from_java(env, &java_accessibility)?;
      delete_local_ref!(env, java_accessibility);
      Some(accessibility)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_accessibility);
    let is_override = java_class.is_override(env, jobj)?;
    let readonly = java_class.is_readonly(env, jobj)?;
    let java_param = java_class.get_param(env, jobj)?;
    let param = *TsParamPropParam::from_java(env, &java_param)?;
    delete_local_ref!(env, java_param);
    Ok(Box::new(TsParamProp {
      span,
      decorators,
      accessibility,
      is_override,
      readonly,
      param,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsParenthesizedType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.type_ann.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsParenthesizedType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_type_ann = self.type_ann.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TS_PARENTHESIZED_TYPE.as_ref().unwrap() }
      .construct(env, &java_type_ann, &java_span_ex)?;
    delete_local_ref!(env, java_type_ann);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsParenthesizedType {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_PARENTHESIZED_TYPE.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_type_ann = java_class.get_type_ann(env, jobj)?;
    let type_ann = *TsType::from_java(env, &java_type_ann)?;
    delete_local_ref!(env, java_type_ann);
    let type_ann = Box::new(type_ann);
    Ok(Box::new(TsParenthesizedType {
      span,
      type_ann,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsPropertySignature {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.key.register_with_map(map);
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsPropertySignature {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let readonly = self.readonly;
    let java_key = self.key.to_java_with_map(env, map)?;
    let computed = self.computed;
    let optional = self.optional;
    let java_optional_type_ann = match self.type_ann.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_TS_PROPERTY_SIGNATURE.as_ref().unwrap() }
      .construct(env, readonly, &java_key, computed, optional, &java_optional_type_ann, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsPropertySignature {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_PROPERTY_SIGNATURE.as_ref().unwrap() };
    let span = DUMMY_SP;
    let readonly = java_class.is_readonly(env, jobj)?;
    let java_key = java_class.get_key(env, jobj)?;
    let key = *Expr::from_java(env, &java_key)?;
    delete_local_ref!(env, java_key);
    let key = Box::new(key);
    let computed = java_class.is_computed(env, jobj)?;
    let optional = java_class.is_optional(env, jobj)?;
    let java_optional_type_ann = java_class.get_type_ann(env, jobj)?;
    let type_ann = if optional_is_present(env, &java_optional_type_ann)? {
      let java_type_ann = optional_get(env, &java_optional_type_ann)?;
      let type_ann = *TsTypeAnn::from_java(env, &java_type_ann)?;
      delete_local_ref!(env, java_type_ann);
      Some(type_ann)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_ann);
    let type_ann = type_ann.map(|type_ann| Box::new(type_ann));
    Ok(Box::new(TsPropertySignature {
      span,
      readonly,
      key,
      computed,
      optional,
      type_ann,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsQualifiedName {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.left.register_with_map(map);
    self.right.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsQualifiedName {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_left = self.left.to_java_with_map(env, map)?;
    let java_right = self.right.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TS_QUALIFIED_NAME.as_ref().unwrap() }
      .construct(env, &java_left, &java_right, &java_span_ex)?;
    delete_local_ref!(env, java_left);
    delete_local_ref!(env, java_right);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsQualifiedName {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_QUALIFIED_NAME.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_left = java_class.get_left(env, jobj)?;
    let left = *TsEntityName::from_java(env, &java_left)?;
    delete_local_ref!(env, java_left);
    let java_right = java_class.get_right(env, jobj)?;
    let right = *IdentName::from_java(env, &java_right)?;
    delete_local_ref!(env, java_right);
    Ok(Box::new(TsQualifiedName {
      span,
      left,
      right,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsRestType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.type_ann.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsRestType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_type_ann = self.type_ann.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TS_REST_TYPE.as_ref().unwrap() }
      .construct(env, &java_type_ann, &java_span_ex)?;
    delete_local_ref!(env, java_type_ann);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsRestType {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_REST_TYPE.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_type_ann = java_class.get_type_ann(env, jobj)?;
    let type_ann = *TsType::from_java(env, &java_type_ann)?;
    delete_local_ref!(env, java_type_ann);
    let type_ann = Box::new(type_ann);
    Ok(Box::new(TsRestType {
      span,
      type_ann,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsSatisfiesExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
    self.type_ann.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsSatisfiesExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_expr = self.expr.to_java_with_map(env, map)?;
    let java_type_ann = self.type_ann.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TS_SATISFIES_EXPR.as_ref().unwrap() }
      .construct(env, &java_expr, &java_type_ann, &java_span_ex)?;
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_type_ann);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsSatisfiesExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_SATISFIES_EXPR.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_expr = java_class.get_expr(env, jobj)?;
    let expr = *Expr::from_java(env, &java_expr)?;
    delete_local_ref!(env, java_expr);
    let expr = Box::new(expr);
    let java_type_ann = java_class.get_type_ann(env, jobj)?;
    let type_ann = *TsType::from_java(env, &java_type_ann)?;
    delete_local_ref!(env, java_type_ann);
    let type_ann = Box::new(type_ann);
    Ok(Box::new(TsSatisfiesExpr {
      span,
      expr,
      type_ann,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsSetterSignature {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.key.register_with_map(map);
    self.param.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsSetterSignature {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_key = self.key.to_java_with_map(env, map)?;
    let computed = self.computed;
    let java_param = self.param.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TS_SETTER_SIGNATURE.as_ref().unwrap() }
      .construct(env, &java_key, computed, &java_param, &java_span_ex)?;
    delete_local_ref!(env, java_key);
    delete_local_ref!(env, java_param);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsSetterSignature {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_SETTER_SIGNATURE.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_key = java_class.get_key(env, jobj)?;
    let key = *Expr::from_java(env, &java_key)?;
    delete_local_ref!(env, java_key);
    let key = Box::new(key);
    let computed = java_class.is_computed(env, jobj)?;
    let java_param = java_class.get_param(env, jobj)?;
    let param = *TsFnParam::from_java(env, &java_param)?;
    delete_local_ref!(env, java_param);
    Ok(Box::new(TsSetterSignature {
      span,
      key,
      computed,
      param,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsThisType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsThisType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let return_value = unsafe { JAVA_CLASS_TS_THIS_TYPE.as_ref().unwrap() }
      .construct(env, &java_span_ex)?;
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsThisType {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let span = DUMMY_SP;
    Ok(Box::new(TsThisType {
      span,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTplLitType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.types.iter() {
      node.register_with_map(map);
    }
    for node in self.quasis.iter() {
      node.register_with_map(map);
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTplLitType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_types = list_new(env, self.types.len())?;
    for node in self.types.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_types, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let java_quasis = list_new(env, self.quasis.len())?;
    for node in self.quasis.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_quasis, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let return_value = unsafe { JAVA_CLASS_TS_TPL_LIT_TYPE.as_ref().unwrap() }
      .construct(env, &java_types, &java_quasis, &java_span_ex)?;
    delete_local_ref!(env, java_types);
    delete_local_ref!(env, java_quasis);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsTplLitType {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_TPL_LIT_TYPE.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_types = java_class.get_types(env, jobj)?;
    let length = list_size(env, &java_types)?;
    let mut types: Vec<TsType> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_types, i)?;
      let element = *TsType::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      types.push(element)
    }
    let types = types.into_iter().map(|types| Box::new(types)).collect();
    let java_quasis = java_class.get_quasis(env, jobj)?;
    let length = list_size(env, &java_quasis)?;
    let mut quasis: Vec<TplElement> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_quasis, i)?;
      let element = *TplElement::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      quasis.push(element)
    }
    Ok(Box::new(TsTplLitType {
      span,
      types,
      quasis,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTupleElement {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.label.as_ref().map(|node| node.register_with_map(map));
    self.ty.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTupleElement {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_optional_label = match self.label.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_ty = self.ty.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TS_TUPLE_ELEMENT.as_ref().unwrap() }
      .construct(env, &java_optional_label, &java_ty, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_label);
    delete_local_ref!(env, java_ty);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsTupleElement {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_TUPLE_ELEMENT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_optional_label = java_class.get_label(env, jobj)?;
    let label = if optional_is_present(env, &java_optional_label)? {
      let java_label = optional_get(env, &java_optional_label)?;
      let label = *Pat::from_java(env, &java_label)?;
      delete_local_ref!(env, java_label);
      Some(label)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_label);
    let java_ty = java_class.get_ty(env, jobj)?;
    let ty = *TsType::from_java(env, &java_ty)?;
    delete_local_ref!(env, java_ty);
    let ty = Box::new(ty);
    Ok(Box::new(TsTupleElement {
      span,
      label,
      ty,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTupleType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.elem_types.iter() {
      node.register_with_map(map);
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTupleType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_elem_types = list_new(env, self.elem_types.len())?;
    for node in self.elem_types.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_elem_types, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let return_value = unsafe { JAVA_CLASS_TS_TUPLE_TYPE.as_ref().unwrap() }
      .construct(env, &java_elem_types, &java_span_ex)?;
    delete_local_ref!(env, java_elem_types);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsTupleType {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_TUPLE_TYPE.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_elem_types = java_class.get_elem_types(env, jobj)?;
    let length = list_size(env, &java_elem_types)?;
    let mut elem_types: Vec<TsTupleElement> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_elem_types, i)?;
      let element = *TsTupleElement::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      elem_types.push(element)
    }
    Ok(Box::new(TsTupleType {
      span,
      elem_types,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTypeAliasDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.id.register_with_map(map);
    self.type_params.as_ref().map(|node| node.register_with_map(map));
    self.type_ann.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTypeAliasDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_id = self.id.to_java_with_map(env, map)?;
    let declare = self.declare;
    let java_optional_type_params = match self.type_params.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_type_ann = self.type_ann.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TS_TYPE_ALIAS_DECL.as_ref().unwrap() }
      .construct(env, &java_id, declare, &java_optional_type_params, &java_type_ann, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_type_params);
    delete_local_ref!(env, java_id);
    delete_local_ref!(env, java_type_ann);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsTypeAliasDecl {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_TYPE_ALIAS_DECL.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_id = java_class.get_id(env, jobj)?;
    let id = *Ident::from_java(env, &java_id)?;
    delete_local_ref!(env, java_id);
    let declare = java_class.is_declare(env, jobj)?;
    let java_optional_type_params = java_class.get_type_params(env, jobj)?;
    let type_params = if optional_is_present(env, &java_optional_type_params)? {
      let java_type_params = optional_get(env, &java_optional_type_params)?;
      let type_params = *TsTypeParamDecl::from_java(env, &java_type_params)?;
      delete_local_ref!(env, java_type_params);
      Some(type_params)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_params);
    let type_params = type_params.map(|type_params| Box::new(type_params));
    let java_type_ann = java_class.get_type_ann(env, jobj)?;
    let type_ann = *TsType::from_java(env, &java_type_ann)?;
    delete_local_ref!(env, java_type_ann);
    let type_ann = Box::new(type_ann);
    Ok(Box::new(TsTypeAliasDecl {
      span,
      id,
      declare,
      type_params,
      type_ann,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTypeAnn {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.type_ann.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTypeAnn {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_type_ann = self.type_ann.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TS_TYPE_ANN.as_ref().unwrap() }
      .construct(env, &java_type_ann, &java_span_ex)?;
    delete_local_ref!(env, java_type_ann);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsTypeAnn {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_TYPE_ANN.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_type_ann = java_class.get_type_ann(env, jobj)?;
    let type_ann = *TsType::from_java(env, &java_type_ann)?;
    delete_local_ref!(env, java_type_ann);
    let type_ann = Box::new(type_ann);
    Ok(Box::new(TsTypeAnn {
      span,
      type_ann,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTypeAssertion {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr.register_with_map(map);
    self.type_ann.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTypeAssertion {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_expr = self.expr.to_java_with_map(env, map)?;
    let java_type_ann = self.type_ann.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TS_TYPE_ASSERTION.as_ref().unwrap() }
      .construct(env, &java_expr, &java_type_ann, &java_span_ex)?;
    delete_local_ref!(env, java_expr);
    delete_local_ref!(env, java_type_ann);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsTypeAssertion {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_TYPE_ASSERTION.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_expr = java_class.get_expr(env, jobj)?;
    let expr = *Expr::from_java(env, &java_expr)?;
    delete_local_ref!(env, java_expr);
    let expr = Box::new(expr);
    let java_type_ann = java_class.get_type_ann(env, jobj)?;
    let type_ann = *TsType::from_java(env, &java_type_ann)?;
    delete_local_ref!(env, java_type_ann);
    let type_ann = Box::new(type_ann);
    Ok(Box::new(TsTypeAssertion {
      span,
      expr,
      type_ann,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTypeLit {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.members.iter() {
      node.register_with_map(map);
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTypeLit {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_members = list_new(env, self.members.len())?;
    for node in self.members.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_members, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let return_value = unsafe { JAVA_CLASS_TS_TYPE_LIT.as_ref().unwrap() }
      .construct(env, &java_members, &java_span_ex)?;
    delete_local_ref!(env, java_members);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsTypeLit {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_TYPE_LIT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_members = java_class.get_members(env, jobj)?;
    let length = list_size(env, &java_members)?;
    let mut members: Vec<TsTypeElement> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_members, i)?;
      let element = *TsTypeElement::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      members.push(element)
    }
    Ok(Box::new(TsTypeLit {
      span,
      members,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTypeOperator {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.type_ann.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTypeOperator {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_op = self.op.to_java(env)?;
    let java_type_ann = self.type_ann.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_TS_TYPE_OPERATOR.as_ref().unwrap() }
      .construct(env, &java_op, &java_type_ann, &java_span_ex)?;
    delete_local_ref!(env, java_op);
    delete_local_ref!(env, java_type_ann);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsTypeOperator {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_TYPE_OPERATOR.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_op = java_class.get_op(env, jobj)?;
    let op = *TsTypeOperatorOp::from_java(env, &java_op)?;
    delete_local_ref!(env, java_op);
    let java_type_ann = java_class.get_type_ann(env, jobj)?;
    let type_ann = *TsType::from_java(env, &java_type_ann)?;
    delete_local_ref!(env, java_type_ann);
    let type_ann = Box::new(type_ann);
    Ok(Box::new(TsTypeOperator {
      span,
      op,
      type_ann,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTypeParam {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.name.register_with_map(map);
    self.constraint.as_ref().map(|node| node.register_with_map(map));
    self.default.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTypeParam {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_name = self.name.to_java_with_map(env, map)?;
    let is_in = self.is_in;
    let is_out = self.is_out;
    let is_const = self.is_const;
    let java_optional_constraint = match self.constraint.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let java_optional_default = match self.default.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_TS_TYPE_PARAM.as_ref().unwrap() }
      .construct(env, &java_name, is_in, is_out, is_const, &java_optional_constraint, &java_optional_default, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_constraint);
    delete_local_optional_ref!(env, java_optional_default);
    delete_local_ref!(env, java_name);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsTypeParam {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_TYPE_PARAM.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_name = java_class.get_name(env, jobj)?;
    let name = *Ident::from_java(env, &java_name)?;
    delete_local_ref!(env, java_name);
    let is_in = java_class.is_in(env, jobj)?;
    let is_out = java_class.is_out(env, jobj)?;
    let is_const = java_class.is_const(env, jobj)?;
    let java_optional_constraint = java_class.get_constraint(env, jobj)?;
    let constraint = if optional_is_present(env, &java_optional_constraint)? {
      let java_constraint = optional_get(env, &java_optional_constraint)?;
      let constraint = *TsType::from_java(env, &java_constraint)?;
      delete_local_ref!(env, java_constraint);
      Some(constraint)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_constraint);
    let constraint = constraint.map(|constraint| Box::new(constraint));
    let java_optional_default = java_class.get_default(env, jobj)?;
    let default = if optional_is_present(env, &java_optional_default)? {
      let java_default = optional_get(env, &java_optional_default)?;
      let default = *TsType::from_java(env, &java_default)?;
      delete_local_ref!(env, java_default);
      Some(default)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_default);
    let default = default.map(|default| Box::new(default));
    Ok(Box::new(TsTypeParam {
      span,
      name,
      is_in,
      is_out,
      is_const,
      constraint,
      default,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTypeParamDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.params.iter() {
      node.register_with_map(map);
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTypeParamDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_params = list_new(env, self.params.len())?;
    for node in self.params.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_params, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let return_value = unsafe { JAVA_CLASS_TS_TYPE_PARAM_DECL.as_ref().unwrap() }
      .construct(env, &java_params, &java_span_ex)?;
    delete_local_ref!(env, java_params);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsTypeParamDecl {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_TYPE_PARAM_DECL.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_params = java_class.get_params(env, jobj)?;
    let length = list_size(env, &java_params)?;
    let mut params: Vec<TsTypeParam> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_params, i)?;
      let element = *TsTypeParam::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      params.push(element)
    }
    Ok(Box::new(TsTypeParamDecl {
      span,
      params,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTypeParamInstantiation {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.params.iter() {
      node.register_with_map(map);
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTypeParamInstantiation {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_params = list_new(env, self.params.len())?;
    for node in self.params.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_params, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let return_value = unsafe { JAVA_CLASS_TS_TYPE_PARAM_INSTANTIATION.as_ref().unwrap() }
      .construct(env, &java_params, &java_span_ex)?;
    delete_local_ref!(env, java_params);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsTypeParamInstantiation {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_TYPE_PARAM_INSTANTIATION.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_params = java_class.get_params(env, jobj)?;
    let length = list_size(env, &java_params)?;
    let mut params: Vec<TsType> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_params, i)?;
      let element = *TsType::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      params.push(element)
    }
    let params = params.into_iter().map(|params| Box::new(params)).collect();
    Ok(Box::new(TsTypeParamInstantiation {
      span,
      params,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTypePredicate {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.param_name.register_with_map(map);
    self.type_ann.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTypePredicate {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let asserts = self.asserts;
    let java_param_name = self.param_name.to_java_with_map(env, map)?;
    let java_optional_type_ann = match self.type_ann.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_TS_TYPE_PREDICATE.as_ref().unwrap() }
      .construct(env, asserts, &java_param_name, &java_optional_type_ann, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_type_ann);
    delete_local_ref!(env, java_param_name);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsTypePredicate {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_TYPE_PREDICATE.as_ref().unwrap() };
    let span = DUMMY_SP;
    let asserts = java_class.is_asserts(env, jobj)?;
    let java_param_name = java_class.get_param_name(env, jobj)?;
    let param_name = *TsThisTypeOrIdent::from_java(env, &java_param_name)?;
    delete_local_ref!(env, java_param_name);
    let java_optional_type_ann = java_class.get_type_ann(env, jobj)?;
    let type_ann = if optional_is_present(env, &java_optional_type_ann)? {
      let java_type_ann = optional_get(env, &java_optional_type_ann)?;
      let type_ann = *TsTypeAnn::from_java(env, &java_type_ann)?;
      delete_local_ref!(env, java_type_ann);
      Some(type_ann)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_ann);
    let type_ann = type_ann.map(|type_ann| Box::new(type_ann));
    Ok(Box::new(TsTypePredicate {
      span,
      asserts,
      param_name,
      type_ann,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTypeQuery {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.expr_name.register_with_map(map);
    self.type_args.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTypeQuery {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_expr_name = self.expr_name.to_java_with_map(env, map)?;
    let java_optional_type_args = match self.type_args.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_TS_TYPE_QUERY.as_ref().unwrap() }
      .construct(env, &java_expr_name, &java_optional_type_args, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_type_args);
    delete_local_ref!(env, java_expr_name);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsTypeQuery {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_TYPE_QUERY.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_expr_name = java_class.get_expr_name(env, jobj)?;
    let expr_name = *TsTypeQueryExpr::from_java(env, &java_expr_name)?;
    delete_local_ref!(env, java_expr_name);
    let java_optional_type_args = java_class.get_type_args(env, jobj)?;
    let type_args = if optional_is_present(env, &java_optional_type_args)? {
      let java_type_args = optional_get(env, &java_optional_type_args)?;
      let type_args = *TsTypeParamInstantiation::from_java(env, &java_type_args)?;
      delete_local_ref!(env, java_type_args);
      Some(type_args)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_args);
    let type_args = type_args.map(|type_args| Box::new(type_args));
    Ok(Box::new(TsTypeQuery {
      span,
      expr_name,
      type_args,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsTypeRef {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.type_name.register_with_map(map);
    self.type_params.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsTypeRef {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_type_name = self.type_name.to_java_with_map(env, map)?;
    let java_optional_type_params = match self.type_params.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let return_value = unsafe { JAVA_CLASS_TS_TYPE_REF.as_ref().unwrap() }
      .construct(env, &java_type_name, &java_optional_type_params, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_type_params);
    delete_local_ref!(env, java_type_name);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsTypeRef {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_TYPE_REF.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_type_name = java_class.get_type_name(env, jobj)?;
    let type_name = *TsEntityName::from_java(env, &java_type_name)?;
    delete_local_ref!(env, java_type_name);
    let java_optional_type_params = java_class.get_type_params(env, jobj)?;
    let type_params = if optional_is_present(env, &java_optional_type_params)? {
      let java_type_params = optional_get(env, &java_optional_type_params)?;
      let type_params = *TsTypeParamInstantiation::from_java(env, &java_type_params)?;
      delete_local_ref!(env, java_type_params);
      Some(type_params)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_type_params);
    let type_params = type_params.map(|type_params| Box::new(type_params));
    Ok(Box::new(TsTypeRef {
      span,
      type_name,
      type_params,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for TsUnionType {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.types.iter() {
      node.register_with_map(map);
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for TsUnionType {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_types = list_new(env, self.types.len())?;
    for node in self.types.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_types, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let return_value = unsafe { JAVA_CLASS_TS_UNION_TYPE.as_ref().unwrap() }
      .construct(env, &java_types, &java_span_ex)?;
    delete_local_ref!(env, java_types);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for TsUnionType {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_TS_UNION_TYPE.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_types = java_class.get_types(env, jobj)?;
    let length = list_size(env, &java_types)?;
    let mut types: Vec<TsType> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_types, i)?;
      let element = *TsType::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      types.push(element)
    }
    let types = types.into_iter().map(|types| Box::new(types)).collect();
    Ok(Box::new(TsUnionType {
      span,
      types,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for UnaryExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.arg.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for UnaryExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_op = self.op.to_java(env)?;
    let java_arg = self.arg.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_UNARY_EXPR.as_ref().unwrap() }
      .construct(env, &java_op, &java_arg, &java_span_ex)?;
    delete_local_ref!(env, java_op);
    delete_local_ref!(env, java_arg);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for UnaryExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_UNARY_EXPR.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_op = java_class.get_op(env, jobj)?;
    let op = *UnaryOp::from_java(env, &java_op)?;
    delete_local_ref!(env, java_op);
    let java_arg = java_class.get_arg(env, jobj)?;
    let arg = *Expr::from_java(env, &java_arg)?;
    delete_local_ref!(env, java_arg);
    let arg = Box::new(arg);
    Ok(Box::new(UnaryExpr {
      span,
      op,
      arg,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for UpdateExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.arg.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for UpdateExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_op = self.op.to_java(env)?;
    let prefix = self.prefix;
    let java_arg = self.arg.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_UPDATE_EXPR.as_ref().unwrap() }
      .construct(env, &java_op, prefix, &java_arg, &java_span_ex)?;
    delete_local_ref!(env, java_op);
    delete_local_ref!(env, java_arg);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for UpdateExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_UPDATE_EXPR.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_op = java_class.get_op(env, jobj)?;
    let op = *UpdateOp::from_java(env, &java_op)?;
    delete_local_ref!(env, java_op);
    let prefix = java_class.is_prefix(env, jobj)?;
    let java_arg = java_class.get_arg(env, jobj)?;
    let arg = *Expr::from_java(env, &java_arg)?;
    delete_local_ref!(env, java_arg);
    let arg = Box::new(arg);
    Ok(Box::new(UpdateExpr {
      span,
      op,
      prefix,
      arg,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for UsingDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.decls.iter() {
      node.register_with_map(map);
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for UsingDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let is_await = self.is_await;
    let java_decls = list_new(env, self.decls.len())?;
    for node in self.decls.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_decls, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let return_value = unsafe { JAVA_CLASS_USING_DECL.as_ref().unwrap() }
      .construct(env, is_await, &java_decls, &java_span_ex)?;
    delete_local_ref!(env, java_decls);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for UsingDecl {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_USING_DECL.as_ref().unwrap() };
    let span = DUMMY_SP;
    let is_await = java_class.is_await(env, jobj)?;
    let java_decls = java_class.get_decls(env, jobj)?;
    let length = list_size(env, &java_decls)?;
    let mut decls: Vec<VarDeclarator> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_decls, i)?;
      let element = *VarDeclarator::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      decls.push(element)
    }
    Ok(Box::new(UsingDecl {
      span,
      is_await,
      decls,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for VarDecl {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    for node in self.decls.iter() {
      node.register_with_map(map);
    }
  }
}

impl ToJavaWithMap<ByteToIndexMap> for VarDecl {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let ctxt = self.ctxt;
    let java_kind = self.kind.to_java(env)?;
    let declare = self.declare;
    let java_decls = list_new(env, self.decls.len())?;
    for node in self.decls.iter() {
      let java_node = node.to_java_with_map(env, map)?;
      list_add(env, &java_decls, &java_node)?;
      delete_local_ref!(env, java_node);
    }
    let return_value = unsafe { JAVA_CLASS_VAR_DECL.as_ref().unwrap() }
      .construct(env, ctxt, &java_kind, declare, &java_decls, &java_span_ex)?;
    delete_local_ref!(env, java_kind);
    delete_local_ref!(env, java_decls);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for VarDecl {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_VAR_DECL.as_ref().unwrap() };
    let span = DUMMY_SP;
    let ctxt = java_class.get_ctxt(env, jobj)?;
    let ctxt = SyntaxContext::from_u32(ctxt as u32);
    let java_kind = java_class.get_kind(env, jobj)?;
    let kind = *VarDeclKind::from_java(env, &java_kind)?;
    delete_local_ref!(env, java_kind);
    let declare = java_class.is_declare(env, jobj)?;
    let java_decls = java_class.get_decls(env, jobj)?;
    let length = list_size(env, &java_decls)?;
    let mut decls: Vec<VarDeclarator> = Vec::with_capacity(length);
    for i in 0..length {
      let java_item = list_get(env, &java_decls, i)?;
      let element = *VarDeclarator::from_java(env, &java_item)?;
      delete_local_ref!(env, java_item);
      decls.push(element)
    }
    Ok(Box::new(VarDecl {
      span,
      ctxt,
      kind,
      declare,
      decls,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for VarDeclarator {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.name.register_with_map(map);
    self.init.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for VarDeclarator {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_name = self.name.to_java_with_map(env, map)?;
    let java_optional_init = match self.init.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let definite = self.definite;
    let return_value = unsafe { JAVA_CLASS_VAR_DECLARATOR.as_ref().unwrap() }
      .construct(env, &java_name, &java_optional_init, definite, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_init);
    delete_local_ref!(env, java_name);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for VarDeclarator {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_VAR_DECLARATOR.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_name = java_class.get_name(env, jobj)?;
    let name = *Pat::from_java(env, &java_name)?;
    delete_local_ref!(env, java_name);
    let java_optional_init = java_class.get_init(env, jobj)?;
    let init = if optional_is_present(env, &java_optional_init)? {
      let java_init = optional_get(env, &java_optional_init)?;
      let init = *Expr::from_java(env, &java_init)?;
      delete_local_ref!(env, java_init);
      Some(init)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_init);
    let init = init.map(|init| Box::new(init));
    let definite = java_class.is_definite(env, jobj)?;
    Ok(Box::new(VarDeclarator {
      span,
      name,
      init,
      definite,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for WhileStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.test.register_with_map(map);
    self.body.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for WhileStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_test = self.test.to_java_with_map(env, map)?;
    let java_body = self.body.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_WHILE_STMT.as_ref().unwrap() }
      .construct(env, &java_test, &java_body, &java_span_ex)?;
    delete_local_ref!(env, java_test);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for WhileStmt {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_WHILE_STMT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_test = java_class.get_test(env, jobj)?;
    let test = *Expr::from_java(env, &java_test)?;
    delete_local_ref!(env, java_test);
    let test = Box::new(test);
    let java_body = java_class.get_body(env, jobj)?;
    let body = *Stmt::from_java(env, &java_body)?;
    delete_local_ref!(env, java_body);
    let body = Box::new(body);
    Ok(Box::new(WhileStmt {
      span,
      test,
      body,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for WithStmt {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.obj.register_with_map(map);
    self.body.register_with_map(map);
  }
}

impl ToJavaWithMap<ByteToIndexMap> for WithStmt {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_obj = self.obj.to_java_with_map(env, map)?;
    let java_body = self.body.to_java_with_map(env, map)?;
    let return_value = unsafe { JAVA_CLASS_WITH_STMT.as_ref().unwrap() }
      .construct(env, &java_obj, &java_body, &java_span_ex)?;
    delete_local_ref!(env, java_obj);
    delete_local_ref!(env, java_body);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for WithStmt {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_WITH_STMT.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_obj = java_class.get_obj(env, jobj)?;
    let obj = *Expr::from_java(env, &java_obj)?;
    delete_local_ref!(env, java_obj);
    let obj = Box::new(obj);
    let java_body = java_class.get_body(env, jobj)?;
    let body = *Stmt::from_java(env, &java_body)?;
    delete_local_ref!(env, java_body);
    let body = Box::new(body);
    Ok(Box::new(WithStmt {
      span,
      obj,
      body,
    }))
  }
}

impl RegisterWithMap<ByteToIndexMap> for YieldExpr {
  fn register_with_map<'local>(&self, map: &'_ mut ByteToIndexMap) {
    map.register_by_span(&self.span);
    self.arg.as_ref().map(|node| node.register_with_map(map));
  }
}

impl ToJavaWithMap<ByteToIndexMap> for YieldExpr {
  fn to_java_with_map<'local, 'a>(&self, env: &mut JNIEnv<'local>, map: &'_ ByteToIndexMap) -> Result<JObject<'a>>
  where
    'local: 'a,
  {
    let java_span_ex = map.get_span_ex_by_span(&self.span).to_java(env)?;
    let java_optional_arg = match self.arg.as_ref() {
      Some(node) => Some(node.to_java_with_map(env, map)?),
      None => None,
    };
    let delegate = self.delegate;
    let return_value = unsafe { JAVA_CLASS_YIELD_EXPR.as_ref().unwrap() }
      .construct(env, &java_optional_arg, delegate, &java_span_ex)?;
    delete_local_optional_ref!(env, java_optional_arg);
    delete_local_ref!(env, java_span_ex);
    Ok(return_value)
  }
}

impl<'local> FromJava<'local> for YieldExpr {
  #[allow(unused_variables)]
  fn from_java(env: &mut JNIEnv<'local>, jobj: &JObject<'_>) -> Result<Box<Self>> {
    let java_class = unsafe { JAVA_CLASS_YIELD_EXPR.as_ref().unwrap() };
    let span = DUMMY_SP;
    let java_optional_arg = java_class.get_arg(env, jobj)?;
    let arg = if optional_is_present(env, &java_optional_arg)? {
      let java_arg = optional_get(env, &java_optional_arg)?;
      let arg = *Expr::from_java(env, &java_arg)?;
      delete_local_ref!(env, java_arg);
      Some(arg)
    } else {
      None
    };
    delete_local_ref!(env, java_optional_arg);
    let arg = arg.map(|arg| Box::new(arg));
    let delegate = java_class.is_delegate(env, jobj)?;
    Ok(Box::new(YieldExpr {
      span,
      arg,
      delegate,
    }))
  }
}
/* AST End */
