/*
 * Copyright (c) 2026. caoccao.com Sam Cao
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.caoccao.javet.swc4j.compiler.jdk17.ast.stmt;

import com.caoccao.javet.swc4j.ast.expr.Swc4jAstIdent;
import com.caoccao.javet.swc4j.ast.interfaces.ISwc4jAstExpr;
import com.caoccao.javet.swc4j.compiler.jdk17.ast.utils.AstUtils;
import com.caoccao.javet.swc4j.ast.interfaces.ISwc4jAstTsFnParam;
import com.caoccao.javet.swc4j.ast.interfaces.ISwc4jAstTsTypeElement;
import com.caoccao.javet.swc4j.ast.pat.Swc4jAstBindingIdent;
import com.caoccao.javet.swc4j.ast.stmt.Swc4jAstTsInterfaceDecl;
import com.caoccao.javet.swc4j.ast.ts.Swc4jAstTsExprWithTypeArgs;
import com.caoccao.javet.swc4j.ast.ts.Swc4jAstTsMethodSignature;
import com.caoccao.javet.swc4j.ast.ts.Swc4jAstTsPropertySignature;
import com.caoccao.javet.swc4j.compiler.ByteCodeCompiler;
import com.caoccao.javet.swc4j.compiler.asm.ClassWriter;
import com.caoccao.javet.swc4j.exceptions.Swc4jByteCodeCompilerException;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * Generates JVM bytecode for TypeScript interface declarations.
 * Converts TypeScript interfaces to Java interfaces with abstract getter/setter methods.
 */
public final class TsInterfaceGenerator {
    /**
     * ACC_PUBLIC | ACC_INTERFACE | ACC_ABSTRACT
     */
    private static final int INTERFACE_ACCESS_FLAGS = 0x0001 | 0x0200 | 0x0400;

    /**
     * ACC_PUBLIC | ACC_ABSTRACT
     */
    private static final int METHOD_ACCESS_FLAGS = 0x0001 | 0x0400;

    private final ByteCodeCompiler compiler;

    public TsInterfaceGenerator(ByteCodeCompiler compiler) {
        this.compiler = compiler;
    }

    private String capitalize(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        return Character.toUpperCase(str.charAt(0)) + str.substring(1);
    }

    /**
     * Generates bytecode for a TypeScript interface declaration.
     *
     * @param internalClassName the internal class name (e.g., "com/example/MyInterface")
     * @param interfaceDecl     the interface declaration
     * @return the generated bytecode, or null if this is an ambient declaration
     * @throws Swc4jByteCodeCompilerException if bytecode generation fails
     */
    public byte[] generateBytecode(String internalClassName, Swc4jAstTsInterfaceDecl interfaceDecl)
            throws Swc4jByteCodeCompilerException {
        // Skip ambient declarations
        if (interfaceDecl.isDeclare()) {
            return null;
        }

        // Collect extended interfaces
        String[] extendedInterfaces = processExtends(interfaceDecl.getExtends());

        // Create ClassWriter with java/lang/Object as superclass (interfaces always extend Object)
        ClassWriter classWriter = new ClassWriter(internalClassName, "java/lang/Object", extendedInterfaces);

        // Set interface flags: ACC_PUBLIC | ACC_INTERFACE | ACC_ABSTRACT
        classWriter.setAccessFlags(INTERFACE_ACCESS_FLAGS);

        // Process body members
        for (ISwc4jAstTsTypeElement element : interfaceDecl.getBody().getBody()) {
            if (element instanceof Swc4jAstTsPropertySignature prop) {
                generatePropertyMethods(classWriter, prop);
            } else if (element instanceof Swc4jAstTsMethodSignature method) {
                generateMethod(classWriter, method);
            }
        }

        try {
            return classWriter.toByteArray();
        } catch (IOException e) {
            throw new Swc4jByteCodeCompilerException(interfaceDecl, "Failed to generate bytecode for interface", e);
        }
    }

    /**
     * Generates an abstract method for a method signature.
     *
     * @param classWriter the class writer
     * @param method      the method signature
     */
    private void generateMethod(ClassWriter classWriter, Swc4jAstTsMethodSignature method) {
        String methodName = getPropertyName(method.getKey());

        // Build method descriptor
        StringBuilder paramDescriptors = new StringBuilder("(");
        for (ISwc4jAstTsFnParam param : method.getParams()) {
            String paramType = "Ljava/lang/Object;"; // Default
            if (param instanceof Swc4jAstBindingIdent bindingIdent) {
                if (bindingIdent.getTypeAnn().isPresent()) {
                    paramType = compiler.getTypeResolver().mapTsTypeToDescriptor(
                            bindingIdent.getTypeAnn().get().getTypeAnn());
                }
            }
            paramDescriptors.append(paramType);
        }
        paramDescriptors.append(")");

        // Get return type
        String returnType = "V"; // Default to void
        if (method.getTypeAnn().isPresent()) {
            returnType = compiler.getTypeResolver().mapTsTypeToDescriptor(
                    method.getTypeAnn().get().getTypeAnn());
        }

        String descriptor = paramDescriptors + returnType;

        // Add abstract method (no code)
        classWriter.addMethod(
                METHOD_ACCESS_FLAGS,
                methodName,
                descriptor,
                null, // No code for abstract methods
                0,    // max stack
                0     // max locals
        );
    }

    /**
     * Generates getter and optional setter methods for a property signature.
     *
     * @param classWriter the class writer
     * @param prop        the property signature
     */
    private void generatePropertyMethods(ClassWriter classWriter, Swc4jAstTsPropertySignature prop) {
        String propName = getPropertyName(prop.getKey());

        // Get type descriptor
        String descriptor = "Ljava/lang/Object;"; // Default
        if (prop.getTypeAnn().isPresent()) {
            descriptor = compiler.getTypeResolver().mapTsTypeToDescriptor(prop.getTypeAnn().get().getTypeAnn());
        }

        // Generate getter
        String getterName = getGetterName(propName, descriptor);
        String getterDescriptor = "()" + descriptor;
        classWriter.addMethod(
                METHOD_ACCESS_FLAGS,
                getterName,
                getterDescriptor,
                null, // No code for abstract methods
                0,    // max stack
                0     // max locals
        );

        // Generate setter (if not readonly)
        if (!prop.isReadonly()) {
            String setterName = "set" + capitalize(propName);
            String setterDescriptor = "(" + descriptor + ")V";
            classWriter.addMethod(
                    METHOD_ACCESS_FLAGS,
                    setterName,
                    setterDescriptor,
                    null, // No code for abstract methods
                    0,    // max stack
                    0     // max locals
            );
        }
    }

    /**
     * Gets the getter method name following Java naming conventions.
     *
     * @param propName   the property name
     * @param descriptor the type descriptor
     * @return the getter method name
     */
    private String getGetterName(String propName, String descriptor) {
        if ("Z".equals(descriptor)) {
            // Boolean: use 'is' prefix unless already prefixed
            if (propName.startsWith("is") || propName.startsWith("has") || propName.startsWith("can")) {
                return propName;
            }
            return "is" + capitalize(propName);
        }
        return "get" + capitalize(propName);
    }

    /**
     * Extracts property name from a key expression.
     *
     * @param key the key expression
     * @return the property name
     */
    private String getPropertyName(ISwc4jAstExpr key) {
        if (key instanceof Swc4jAstIdent ident) {
            return ident.getSym();
        }
        return key.toString();
    }

    /**
     * Processes the extends clause and returns the internal names of extended interfaces.
     *
     * @param extendsList the list of extended interfaces
     * @return array of internal interface names
     */
    private String[] processExtends(List<Swc4jAstTsExprWithTypeArgs> extendsList) {
        if (extendsList == null || extendsList.isEmpty()) {
            return new String[0];
        }

        List<String> interfaceNames = new ArrayList<>();
        for (Swc4jAstTsExprWithTypeArgs extendsExpr : extendsList) {
            String qualifiedName = AstUtils.extractQualifiedName(extendsExpr.getExpr());
            if (qualifiedName != null) {
                // Try to resolve from type alias registry
                String resolvedName = compiler.getMemory().getScopedTypeAliasRegistry().resolve(qualifiedName);
                if (resolvedName != null) {
                    qualifiedName = resolvedName;
                }
                interfaceNames.add(qualifiedName.replace('.', '/'));
            }
        }
        return interfaceNames.toArray(new String[0]);
    }
}
