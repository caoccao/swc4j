# JSON.stringify and JSON.parse Plan

## Status

**COMPLETED** — All files created/modified, all 78 tests pass, javadoc passes.

### Files Created
- `src/main/java/com/caoccao/javet/swc4j/compiler/utils/json/JsonProvider.java`
- `src/main/java/com/caoccao/javet/swc4j/compiler/utils/json/DefaultJsonProvider.java`
- `src/main/java/com/caoccao/javet/swc4j/compiler/utils/json/JsonUtils.java`
- `src/main/java/com/caoccao/javet/swc4j/compiler/jdk17/ast/expr/callexpr/CallExpressionForJsonStaticProcessor.java`
- `src/test/java/com/caoccao/javet/swc4j/compiler/utils/json/TestJsonUtilsStringify.java` (edge cases #1-20)
- `src/test/java/com/caoccao/javet/swc4j/compiler/utils/json/TestJsonUtilsParse.java` (edge cases #21-46)
- `src/test/java/com/caoccao/javet/swc4j/compiler/utils/json/TestJsonUtilsBytecode.java` (edge cases #47-52)
- `src/test/java/com/caoccao/javet/swc4j/compiler/utils/json/TestJsonUtilsProvider.java` (edge cases #53-57)

### Files Modified
- `ConstantJavaType.java` — added `TYPE_ALIAS_JSON`, `COM_CAOCCAO_JAVET_SWC4J_COMPILER_UTILS_JSON_JSON_UTILS`
- `ConstantJavaMethod.java` — added `METHOD_STRINGIFY`, `METHOD_PARSE`
- `ConstantJavaDescriptor.java` — added 3-arg stringify descriptor, `String→Object` descriptor
- `CallExpressionProcessor.java` — added `jsonStaticGenerator` field + dispatch block
- `TypeResolver.java` — added return type inference for `JSON.stringify` / `JSON.parse`
- `ByteCodeCompilerOptions.java` — added `optionalJsonProvider` field + builder method
- `ByteCodeCompiler.java` — added `JsonUtils.setProvider()` call in constructor

## Goal

Support `JSON.stringify()` and `JSON.parse()` in the bytecode compiler. These two methods convert between JSON strings and Java `LinkedHashMap` (for JSON objects) or `ArrayList` (for JSON arrays). The serialization/parsing logic is behind a `JsonProvider` interface so that alternative implementations (e.g., Jackson) can be injected. The default implementation uses no external libraries.

```typescript
const obj = { name: "Alice", age: 30 };
const json: string = JSON.stringify(obj);       // '{"name":"Alice","age":30}'
const parsed: any = JSON.parse(json);           // LinkedHashMap { "name" -> "Alice", "age" -> 30 }
```

## Architecture

### Dispatch Path

```
CallExpressionProcessor.generate()
  └─ callee is MemberExpr with obj == "JSON"
       └─ CallExpressionForJsonStaticProcessor.generate()
            ├─ "stringify" → generateStringify()
            └─ "parse"     → generateParse()
```

This mirrors the existing `Array.from()` / `Array.of()` dispatch in `CallExpressionForArrayStaticProcessor`.

### Provider Interface

```
src/main/java/com/caoccao/javet/swc4j/compiler/utils/json/JsonProvider.java        (interface)
src/main/java/com/caoccao/javet/swc4j/compiler/utils/json/DefaultJsonProvider.java  (default implementation)
src/main/java/com/caoccao/javet/swc4j/compiler/utils/json/JsonUtils.java            (static facade)
```

```
                  ┌─────────────────┐
                  │  JsonProvider    │  (interface)
                  │  ├─ stringify()  │
                  │  └─ parse()     │
                  └────────┬────────┘
                           │ implements
              ┌────────────┴────────────┐
              │                         │
  ┌───────────▼──────────┐   ┌─────────▼──────────┐
  │ DefaultJsonProvider  │   │ (future: Jackson,   │
  │ (hand-rolled)        │   │  Gson, etc.)        │
  └───────────▲──────────┘   └────────────────────-┘
              │
              │ delegates to
  ┌───────────┴──────────┐
  │ JsonUtils            │  (static facade — bytecode calls this)
  │ ├─ stringify(Object) │
  │ └─ parse(String)     │
  └──────────────────────┘
```

Generated bytecode calls `invokestatic JsonUtils.stringify/parse`. At runtime, `JsonUtils` delegates to the configured `JsonProvider` instance. The provider is set once during compiler initialization from `ByteCodeCompilerOptions` and stored as a `volatile` field on `JsonUtils` for thread safety.

### Injection Flow

```
ByteCodeCompilerOptions.Builder
  └─ .jsonProvider(new JacksonJsonProvider())   // optional, defaults to DefaultJsonProvider.INSTANCE
  └─ .build()

ByteCodeCompiler(options)
  └─ JsonUtils.setProvider(options.jsonProvider())   // one-time setup
```

## Detailed Design

### 1. `JsonProvider.java` — interface

New file at `src/main/java/com/caoccao/javet/swc4j/compiler/utils/json/JsonProvider.java`.

```java
public interface JsonProvider {
    String stringify(Object value);
    String stringify(Object value, Object replacer, Object space);
    Object parse(String json);
}
```

Three methods covering all supported call signatures. The 1-arg `stringify` exists so implementations can optimize the common case without allocating replacer/space parameters.

### 2. `DefaultJsonProvider.java` — default implementation

New file at `src/main/java/com/caoccao/javet/swc4j/compiler/utils/json/DefaultJsonProvider.java`.

Singleton via `public static final DefaultJsonProvider INSTANCE = new DefaultJsonProvider()`.

Contains all the hand-rolled serialization and parsing logic (see sections 5a and 5b below). No external library dependencies.

### 3. `JsonUtils.java` — static facade

New file at `src/main/java/com/caoccao/javet/swc4j/compiler/utils/json/JsonUtils.java`.

```java
public final class JsonUtils {
    private static volatile JsonProvider provider = DefaultJsonProvider.INSTANCE;

    public static void setProvider(JsonProvider provider) {
        JsonUtils.provider = (provider != null) ? provider : DefaultJsonProvider.INSTANCE;
    }

    public static JsonProvider getProvider() {
        return provider;
    }

    public static String stringify(Object value) {
        return provider.stringify(value);
    }

    public static String stringify(Object value, Object replacer, Object space) {
        return provider.stringify(value, replacer, space);
    }

    public static Object parse(String json) {
        return provider.parse(json);
    }
}
```

The generated bytecode calls these static methods. The indirection through `provider` is a single volatile read — negligible overhead.

### 4. Constants

**`ConstantJavaType.java`** — add:
```java
public static final String TYPE_ALIAS_JSON = "JSON";
public static final String COM_CAOCCAO_JAVET_SWC4J_COMPILER_UTILS_JSON_JSON_UTILS =
        "com/caoccao/javet/swc4j/compiler/utils/json/JsonUtils";
```

**`ConstantJavaMethod.java`** — add:
```java
public static final String METHOD_STRINGIFY = "stringify";
public static final String METHOD_PARSE = "parse";
```

**`ConstantJavaDescriptor.java`** — add:
```java
// stringify(Object, Object, Object) -> String
public static final String LJAVA_LANG_OBJECT_LJAVA_LANG_OBJECT_LJAVA_LANG_OBJECT__LJAVA_LANG_STRING =
        "(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/String;";

// parse(String) -> Object
public static final String LJAVA_LANG_STRING__LJAVA_LANG_OBJECT =
        "(Ljava/lang/String;)Ljava/lang/Object;";
```

Note: `LJAVA_LANG_OBJECT__LJAVA_LANG_STRING` already exists in `ConstantJavaDescriptor`.

### 5. `CallExpressionForJsonStaticProcessor.java`

New file under `compiler/jdk17/ast/expr/callexpr/`. Extends `BaseAstProcessor<Swc4jAstCallExpr>`.

**`generate()`:**
1. Extract method name from `MemberExpr.prop`
2. Switch on method name:
   - `METHOD_STRINGIFY` → `generateStringify(code, classWriter, callExpr)`
   - `METHOD_PARSE` → `generateParse(code, classWriter, callExpr)`
   - default → throw unsupported

**`generateStringify()`:**
- 0 args: push `"undefined"` string constant
- 1 arg: evaluate arg, box if primitive, `invokestatic JsonUtils.stringify(Object)`
- 2 args: evaluate arg1 (value), evaluate arg2 (replacer), push `aconst_null` (space), `invokestatic JsonUtils.stringify(Object, Object, Object)`
- 3 args: evaluate all three (value, replacer, space), box if primitive, `invokestatic JsonUtils.stringify(Object, Object, Object)`
- Stack result: `Ljava/lang/String;`

**`generateParse()`:**
- 0 args: throw compile error (required argument)
- 1 arg: evaluate arg, ensure `String` type, `invokestatic JsonUtils.parse(String)`
- 2+ args: evaluate first arg only (reviver is deferred)
- Stack result: `Ljava/lang/Object;`

### 6. `CallExpressionProcessor.java` — dispatch

Add field:
```java
private final CallExpressionForJsonStaticProcessor jsonStaticGenerator;
```

Add dispatch block after the Array static check (~line 123):
```java
if (callee instanceof Swc4jAstMemberExpr jsonStaticMember
        && jsonStaticMember.getObj() instanceof Swc4jAstIdent jsonStaticId
        && ConstantJavaType.TYPE_ALIAS_JSON.equals(jsonStaticId.getSym())) {
    jsonStaticGenerator.generate(code, classWriter, callExpr, returnTypeInfo);
    return;
}
```

### 7. `TypeResolver.java` — return type inference

Add a block parallel to the `TYPE_ALIAS_ARRAY` block (~line 1454):
```java
if (ConstantJavaType.TYPE_ALIAS_JSON.equals(objIdent.getSym())
        && memberExpr.getProp() instanceof Swc4jAstIdentName propIdent) {
    String methodName = propIdent.getSym();
    switch (methodName) {
        case ConstantJavaMethod.METHOD_STRINGIFY -> { return ConstantJavaType.LJAVA_LANG_STRING; }
        case ConstantJavaMethod.METHOD_PARSE -> { return ConstantJavaType.LJAVA_LANG_OBJECT; }
    }
}
```

### 8. `ByteCodeCompilerOptions.java` — add jsonProvider field

Add field to the record:
```java
Optional<JsonProvider> optionalJsonProvider
```

Add to Builder:
```java
private JsonProvider jsonProvider;

public Builder jsonProvider(JsonProvider jsonProvider) {
    this.jsonProvider = jsonProvider;
    return this;
}
```

Default: `null` in Builder → `Optional.empty()` in record → `DefaultJsonProvider.INSTANCE` at runtime.

### 9. `ByteCodeCompiler.java` — initialize provider

In constructor, after `memory` initialization:
```java
options.optionalJsonProvider().ifPresent(JsonUtils::setProvider);
```

### 5a. `DefaultJsonProvider.stringify` — serialization logic

#### `stringify(Object value)`

Shorthand: delegates to `stringify(value, null, null)`.

#### `stringify(Object value, Object replacer, Object space)`

Serializes a Java object tree to a JSON string.

**Algorithm:**
1. Resolve `space` to an indent string:
   - `null` or absent → no indentation (compact output)
   - `Number` / `Integer` → repeat `' '` that many times (clamped to 0–10)
   - `String` → use first 10 characters as indent prefix
2. If `replacer` is an `ArrayList`, build a `Set<String>` of allowed property names
3. If `replacer` is a functional interface (deferred — ignore for now)
4. Call recursive `writeValue(StringBuilder, value, indent, currentIndent, replacer, visited)`

**`writeValue()` dispatch:**

| Java type | JSON output |
|---|---|
| `null` | `null` |
| `String` | `"..."` with escapes |
| `Boolean` | `true` / `false` |
| `Integer`, `Long`, `Short`, `Byte` | integer literal |
| `Float`, `Double` | decimal literal; `NaN`/`Infinity` → `null` |
| `Character` | `"c"` (single-char string) |
| `LinkedHashMap` | `{ "key": value, ... }` |
| `ArrayList` | `[ value, ... ]` |
| `BigInteger` | integer literal |
| Any other object | `{}` (empty object fallback) |

**String escaping:**
- `\"` `\\` `\n` `\r` `\t` `\b` `\f`
- Control chars U+0000–U+001F → `\u00XX`

### 5b. `DefaultJsonProvider.parse` — parsing logic

Parses a JSON string into Java objects.

**Return type mapping:**

| JSON value | Java type |
|---|---|
| `{ ... }` | `LinkedHashMap<String, Object>` |
| `[ ... ]` | `ArrayList<Object>` |
| `"..."` | `String` |
| integer number | `Integer` (if fits) or `Long` |
| decimal number | `Double` |
| `true` / `false` | `Boolean` |
| `null` | `null` |

**Algorithm — recursive descent parser:**
1. Maintain a `pos` index (use `int[]` of size 1 for pass-by-reference)
2. Skip whitespace (space, tab, CR, LF)
3. Peek at current char to decide type:
   - `{` → `parseObject()`
   - `[` → `parseArray()`
   - `"` → `parseString()`
   - `-` or digit → `parseNumber()`
   - `t` → expect `true`
   - `f` → expect `false`
   - `n` → expect `null`
4. `parseObject()`: consume `{`, loop parsing `key: value` pairs separated by `,`, consume `}`
5. `parseArray()`: consume `[`, loop parsing values separated by `,`, consume `]`
6. `parseString()`: consume `"`, handle escape sequences (`\"`, `\\`, `\/`, `\b`, `\f`, `\n`, `\r`, `\t`, `\uXXXX`), consume closing `"`
7. `parseNumber()`: collect digits, optional `-`, `.`, `e`/`E`, `+`/`-`; return `Integer` if no decimal/exponent and fits in int range, `Long` if fits in long range, otherwise `Double`

## Edge Cases

### JSON.stringify

1. **Circular references**: `LinkedHashMap` or `ArrayList` containing itself → throw `RuntimeException` (match JS `TypeError: Converting circular structure to JSON`). Track visited objects with `IdentityHashSet`.
2. **`undefined` / void type**: No direct Java equivalent. If a map value is `null`, it serializes as `null`. If the entire argument is void/undefined, return `"undefined"` at the bytecode level (0-arg case).
3. **`NaN` and `Infinity`**: `Double.isNaN()` or `Double.isInfinite()` → serialize as `null` (matches JS spec).
4. **Negative zero**: `-0.0` → serialize as `"0"` (matches JS behavior: `JSON.stringify(-0)` produces `"0"`).
5. **`BigInteger`**: Serialize as a numeric literal (no quotes). Very large values produce very long digit strings.
6. **Character type**: Serialize as a single-character JSON string `"c"`.
7. **Map key types**: `LinkedHashMap` keys may not always be `String` at runtime (e.g., integer keys from array-like usage). Convert keys to strings via `String.valueOf()`.
8. **Non-string, non-number map keys**: `toString()` them. Duplicate keys after stringification keep last value (matches JS behavior).
9. **Null map values**: Include in output as `"key": null` (matches JS). Do NOT omit.
10. **Replacer as ArrayList (property whitelist)**: Only include properties whose string name is in the list. Order of output follows the replacer list order, not the map insertion order.
11. **Replacer as function**: Deferred — not supported initially. If a non-list, non-null replacer is passed, ignore it.
12. **Space parameter clamping**: Numeric space is clamped to `[0, 10]`. String space is truncated to 10 characters. Negative numbers → 0 (no indent).
13. **Space with `0` or empty string**: Equivalent to no space — compact output.
14. **Nested indentation**: Each nesting level adds one `space` prefix. Closing `}` / `]` at the outer indentation level.
15. **Empty object `{}`**: Produces `"{}"` regardless of indentation.
16. **Empty array `[]`**: Produces `"[]"` regardless of indentation.
17. **Deeply nested structures**: Stack overflow risk with recursive `writeValue`. Reasonable depth limit (e.g., 512) with `RuntimeException` on overflow.
18. **`toJSON()` method**: JS objects can define `toJSON()`. Not applicable since our objects are plain `LinkedHashMap`/`ArrayList`. Skip.
19. **Non-serializable values in arrays**: In JS, `undefined`, functions, and symbols in arrays become `null`. Since our arrays hold boxed Java objects, `null` entries naturally serialize as `null`.
20. **Non-serializable values in objects**: In JS, properties with `undefined`/function/symbol values are omitted. Since we don't have these types, all non-null values serialize normally. Null values serialize as `null`.

### JSON.parse

21. **Empty string input**: Throw `RuntimeException` (matches JS `SyntaxError`).
22. **Whitespace-only input**: Throw `RuntimeException`.
23. **Trailing content**: After parsing one complete value, remaining non-whitespace characters → throw `RuntimeException`.
24. **Trailing commas**: `{"a": 1,}` or `[1,]` → throw `RuntimeException` (JSON spec forbids trailing commas).
25. **Single quotes**: `{'key': 'value'}` → throw `RuntimeException` (JSON requires double quotes).
26. **Unquoted keys**: `{key: "value"}` → throw `RuntimeException`.
27. **String escape sequences**: Must handle `\"`, `\\`, `\/`, `\b`, `\f`, `\n`, `\r`, `\t`, `\uXXXX`.
28. **Invalid escape sequences**: `\x`, `\a`, etc. → throw `RuntimeException`.
29. **Incomplete `\uXXXX`**: Fewer than 4 hex digits → throw `RuntimeException`.
30. **Surrogate pairs**: `\uD800\uDC00` — two consecutive `\uXXXX` escapes forming a supplementary code point. Handle by passing through as Java chars (Java strings natively use UTF-16).
31. **Lone surrogates**: `\uD800` without a following low surrogate — technically invalid JSON, but many parsers accept it. Accept and store as-is in Java string.
32. **Numeric overflow**: Very large integers (beyond `Long.MAX_VALUE`) → parse as `Double`. Very large decimals → `Double.POSITIVE_INFINITY`.
33. **Leading zeros**: `0123` → throw `RuntimeException` (JSON forbids leading zeros except for `0` itself and `0.x`).
34. **Negative zero**: `-0` → parse as `Double` with value `-0.0`.
35. **Exponent notation**: `1e10`, `1E10`, `1e+10`, `1e-10`, `1.5e3` → parse as `Double`.
36. **Numbers with no integer part**: `.5` → throw `RuntimeException` (JSON requires `0.5`).
37. **Numbers with no fractional part**: `1.` → throw `RuntimeException` (JSON requires `1.0` or `1`).
38. **Nested depth limit**: Deeply nested `[[[[...]]]]` or `{"a":{"a":...}}` → stack overflow. Limit recursion depth (e.g., 512).
39. **Duplicate keys in objects**: `{"a": 1, "a": 2}` → last value wins, producing `LinkedHashMap` with `"a" -> 2`. This matches JS behavior.
40. **Unicode in strings**: Raw Unicode characters (including non-ASCII) are valid in JSON strings. Store as-is in Java `String`.
41. **Control characters in strings**: Unescaped control chars U+0000–U+001F → throw `RuntimeException` (JSON spec requires them to be escaped).
42. **Very long strings**: No artificial limit — bounded by available memory.
43. **`null` literal**: Parses to Java `null`.
44. **Boolean literals**: `true` → `Boolean.TRUE`, `false` → `Boolean.FALSE`.
45. **Integer vs Long vs Double**: Parse numbers without `.` or `e`/`E` as `Integer` if in `[Integer.MIN_VALUE, Integer.MAX_VALUE]`, then `Long` if in long range, otherwise `Double`.
46. **Reviver function (2nd argument)**: Deferred. Not supported in initial implementation.

### Bytecode-Level Edge Cases

47. **0-argument `JSON.stringify()`**: Return the string `"undefined"` (matches JS behavior).
48. **0-argument `JSON.parse()`**: Compile-time error — `JSON.parse()` requires at least one argument.
49. **Primitive argument to `stringify`**: Must be boxed before calling `JsonUtils.stringify(Object)`. E.g., `JSON.stringify(42)` needs `Integer.valueOf(42)` on the stack.
50. **Return type of `JSON.parse`**: `Ljava/lang/Object;`. Callers using the result will need casts depending on context (e.g., assigning to a typed variable).
51. **Extra arguments**: `JSON.stringify(v, r, s, extra)` — ignore arguments beyond the 3rd. `JSON.parse(s, reviver, extra)` — ignore arguments beyond the 1st (until reviver is supported).
52. **Spread arguments**: `JSON.stringify(...args)` — throw compile error (not supported for JSON methods).

### Provider Edge Cases

53. **Null provider injection**: `JsonUtils.setProvider(null)` → fall back to `DefaultJsonProvider.INSTANCE`.
54. **Provider swapped mid-execution**: The `volatile` field ensures visibility across threads. Each `stringify`/`parse` call reads the provider once, so a swap is atomic per call.
55. **Custom provider returning null from stringify**: Valid — caller receives `null` on the stack (`aconst_null`).
56. **Custom provider throwing exceptions**: Exceptions propagate normally through the `invokestatic` call. No special bytecode handling needed.
57. **Custom provider returning non-standard types from parse**: The bytecode expects `Ljava/lang/Object;` — any return type is accepted. Type mismatches surface later when the caller casts or uses the result.

## Files to Create

| File | Purpose |
|---|---|
| `src/main/java/com/caoccao/javet/swc4j/compiler/utils/json/JsonProvider.java` | Interface for JSON serialization/parsing |
| `src/main/java/com/caoccao/javet/swc4j/compiler/utils/json/DefaultJsonProvider.java` | Default hand-rolled implementation |
| `src/main/java/com/caoccao/javet/swc4j/compiler/utils/json/JsonUtils.java` | Static facade — bytecode invocation target |
| `src/main/java/com/caoccao/javet/swc4j/compiler/jdk17/ast/expr/callexpr/CallExpressionForJsonStaticProcessor.java` | Bytecode generation for `JSON.stringify` / `JSON.parse` |

## Files to Modify

| File | Change |
|---|---|
| `ConstantJavaType.java` | Add `TYPE_ALIAS_JSON`, `COM_CAOCCAO_..._JSON_JSON_UTILS` |
| `ConstantJavaMethod.java` | Add `METHOD_STRINGIFY`, `METHOD_PARSE` |
| `ConstantJavaDescriptor.java` | Add 3-arg stringify descriptor, `String→Object` descriptor |
| `CallExpressionProcessor.java` | Add `jsonStaticGenerator` field + dispatch block |
| `ByteCodeCompiler.java` | Instantiate processor, call `JsonUtils.setProvider()` |
| `ByteCodeCompilerOptions.java` | Add `optionalJsonProvider` field + builder method |
| `TypeResolver.java` | Add return type inference for `JSON.stringify` / `JSON.parse` |

## Verification

```bash
# Unit tests for DefaultJsonProvider
./gradlew test --tests "*.TestDefaultJsonProvider"

# Unit tests for JsonUtils facade
./gradlew test --tests "*.TestJsonUtils"

# Integration tests for bytecode compilation
./gradlew test --tests "*.TestCompileAstJsonStringify"
./gradlew test --tests "*.TestCompileAstJsonParse"

# Full suite
./gradlew test
```
