# TypeScript Enum Declaration Implementation Plan

## Overview

This document outlines the implementation plan for supporting TypeScript enums in the TypeScript to JVM bytecode compilation pipeline. TypeScript enums will be compiled directly to Java enum classes, which are special classes that extend `java.lang.Enum<E>`.

**Current Status:** ✅ **COMPLETED** (2026-01-19)

**Supported Features:**
- Numeric enums (with auto-increment and explicit values)
- String enums
- Const enums (treated as regular enums)
- Mixed explicit/implicit values

**Unsupported Features:**
- ❌ **Computed Enums** - Members with expressions referencing other members (e.g., `B = A * 2`)
- ❌ **Heterogeneous Enums** - Mixed numeric and string values in the same enum

**Syntax:**
```typescript
// Numeric enum (default) - SUPPORTED
enum Direction {
  Up,        // 0
  Down,      // 1
  Left,      // 2
  Right      // 3
}

// String enum - SUPPORTED
enum Color {
  Red = "RED",
  Green = "GREEN",
  Blue = "BLUE"
}

// Const enum (compile-time only) - SUPPORTED
const enum Const {
  A = 1,
  B = 2
}

// Heterogeneous enum (mixed) - NOT SUPPORTED
enum Mixed {
  No = 0,
  Yes = "YES"  // ERROR: Cannot mix numeric and string values
}

// Computed enum - NOT SUPPORTED
enum Computed {
  A = 1,
  B = A * 2,   // ERROR: Computed values not supported
  C = B + A
}
```

**Implementation File:** `src/main/java/com/caoccao/javet/swc4j/compiler/jdk17/ast/decl/TsEnumDeclGenerator.java` (to be created)

**Test Files:** `src/test/java/com/caoccao/javet/swc4j/compiler/ast/decl/tsenumtest/TestCompileTsEnumDecl*.java` (to be created)

**AST Definition:** [Swc4jAstTsEnumDecl.java](../../../../../src/main/java/com/caoccao/javet/swc4j/ast/stmt/Swc4jAstTsEnumDecl.java)

---

## TypeScript Enum Fundamentals

### Enum Types

TypeScript supports several types of enums:

#### 1. Numeric Enums (Default)
```typescript
enum Direction {
  Up,        // 0 (default start)
  Down,      // 1 (auto-increment)
  Left,      // 2
  Right      // 3
}

enum Status {
  Pending = 1,    // Explicit start value
  Active,         // 2 (auto-increment)
  Completed       // 3
}
```

**Behavior:**
- Default starting value is 0
- Auto-increments by 1 for each subsequent member
- Can specify explicit values
- Can mix explicit and implicit values

#### 2. String Enums
```typescript
enum Color {
  Red = "RED",
  Green = "GREEN",
  Blue = "BLUE"
}
```

**Behavior:**
- All members must have explicit string values
- No auto-increment (strings don't increment)
- Commonly used for serialization/deserialization

#### 3. Heterogeneous Enums (Mixed Numeric and String) - NOT SUPPORTED
```typescript
enum Mixed {
  No = 0,
  Yes = "YES"
}
```

**Behavior:**
- Mixes numeric and string values
- Not recommended in TypeScript (but allowed)
- **NOT SUPPORTED** in swc4j - Will produce compilation error

#### 4. Const Enums
```typescript
const enum Directions {
  Up,
  Down,
  Left,
  Right
}
```

**Behavior:**
- Compile-time only (inlined at usage sites)
- No runtime representation
- Cannot be used in runtime type checks
- More efficient but less flexible

#### 5. Computed Enums - NOT SUPPORTED
```typescript
enum Computed {
  A = 1,
  B = A * 2,        // ERROR: Computed from A - not supported
  C = B + A,        // ERROR: Computed from A and B - not supported
  D = Math.random() // ERROR: Runtime computation - not supported
}
```

**Behavior:**
- Members that reference other members in expressions
- **NOT SUPPORTED** in swc4j - Will produce compilation error
- Use explicit constant values instead

### TypeScript Enum Features

#### Reverse Mapping (Numeric Enums Only)
```typescript
enum Direction {
  Up = 0,
  Down = 1
}

Direction.Up         // 0
Direction[0]         // "Up" (reverse mapping)
Direction["Up"]      // 0
```

**Behavior:**
- Only numeric enums support reverse mapping
- String enums do NOT have reverse mapping
- Adds additional properties: `0: "Up"`, `1: "Down"`

#### Ambient Enums
```typescript
declare enum Ambient {
  A,
  B
}
```

**Behavior:**
- Declaration only (no implementation)
- Used for type definitions (.d.ts files)
- Should not generate bytecode

---

## Java Enum Fundamentals

### Java Enum Structure

Java enums are special classes that:
1. Extend `java.lang.Enum<E>` (implicit, cannot extend explicitly)
2. Have a fixed set of instances (enum constants)
3. Are implicitly `final` (cannot be subclassed)
4. Have private constructors (cannot be instantiated externally)

**Java Enum Example:**
```java
public enum Direction {
    UP,      // Instance 0, ordinal() = 0
    DOWN,    // Instance 1, ordinal() = 1
    LEFT,    // Instance 2, ordinal() = 2
    RIGHT;   // Instance 3, ordinal() = 3
}
```

**Generated Bytecode Structure:**
```java
public final class Direction extends Enum<Direction> {
    // Enum constant instances (public static final)
    public static final Direction UP;
    public static final Direction DOWN;
    public static final Direction LEFT;
    public static final Direction RIGHT;

    // Array of all values (private static final)
    private static final Direction[] $VALUES;

    // Private constructor
    private Direction(String name, int ordinal) {
        super(name, ordinal);
    }

    // Static initializer (creates instances)
    static {
        UP = new Direction("UP", 0);
        DOWN = new Direction("DOWN", 1);
        LEFT = new Direction("LEFT", 2);
        RIGHT = new Direction("RIGHT", 3);
        $VALUES = new Direction[]{UP, DOWN, LEFT, RIGHT};
    }

    // values() method (returns all constants)
    public static Direction[] values() {
        return $VALUES.clone();
    }

    // valueOf(String) method (looks up by name)
    public static Direction valueOf(String name) {
        return Enum.valueOf(Direction.class, name);
    }
}
```

### Java Enum with Fields and Methods

```java
public enum Color {
    RED("red", 0xFF0000),
    GREEN("green", 0x00FF00),
    BLUE("blue", 0x0000FF);

    private final String displayName;
    private final int rgbValue;

    private Color(String displayName, int rgbValue) {
        this.displayName = displayName;
        this.rgbValue = rgbValue;
    }

    public String getDisplayName() {
        return displayName;
    }

    public int getRgbValue() {
        return rgbValue;
    }
}
```

**Constructor invocation in static initializer:**
```java
static {
    RED = new Color("RED", 0, "red", 0xFF0000);
    GREEN = new Color("GREEN", 1, "green", 0x00FF00);
    BLUE = new Color("BLUE", 2, "blue", 0x0000FF);
    // ...
}
```

### Java Enum Inherited Methods

From `java.lang.Enum<E>`:
- `String name()` - Returns the enum constant name (e.g., "UP")
- `int ordinal()` - Returns the ordinal (position in declaration, 0-indexed)
- `String toString()` - Default returns name() (can be overridden)
- `boolean equals(Object)` - Compares by reference (enum constants are singletons)
- `int hashCode()` - Uses identity hash code
- `int compareTo(E)` - Compares by ordinal
- `Class<E> getDeclaringClass()` - Returns the enum class

---

## Mapping Strategy: TypeScript Enum → Java Enum

### 1. Numeric Enum Mapping

**TypeScript:**
```typescript
enum Direction {
  Up,        // 0
  Down,      // 1
  Left = 5,  // 5 (explicit)
  Right      // 6 (auto-increment)
}
```

**Java (Target):**
```java
public enum Direction {
    UP(0),
    DOWN(1),
    LEFT(5),
    RIGHT(6);

    private final int value;

    private Direction(int value) {
        this.value = value;
    }

    public int getValue() {
        return this.value;
    }

    public static Direction fromValue(int value) {
        for (Direction d : values()) {
            if (d.value == value) return d;
        }
        throw new IllegalArgumentException("Invalid value: " + value);
    }
}
```

**Key mappings:**
- TS member name → Java constant name (uppercase by convention)
- TS numeric value → Java field `value`
- Add `getValue()` method for numeric access
- Add `fromValue(int)` for reverse lookup (replaces TS reverse mapping)
- Java `ordinal()` matches declaration order, not the custom value

### 2. String Enum Mapping

**TypeScript:**
```typescript
enum Color {
  Red = "RED",
  Green = "GREEN",
  Blue = "BLUE"
}
```

**Java (Target):**
```java
public enum Color {
    RED("RED"),
    GREEN("GREEN"),
    BLUE("BLUE");

    private final String value;

    private Color(String value) {
        this.value = value;
    }

    public String getValue() {
        return this.value;
    }

    public static Color fromValue(String value) {
        for (Color c : values()) {
            if (c.value.equals(value)) return c;
        }
        throw new IllegalArgumentException("Invalid value: " + value);
    }
}
```

**Key mappings:**
- TS member name → Java constant name (uppercase)
- TS string value → Java field `value`
- Add `getValue()` method for string access
- Add `fromValue(String)` for reverse lookup
- No reverse mapping needed (strings don't auto-increment)

### 3. Heterogeneous Enum Mapping - NOT SUPPORTED

**TypeScript:**
```typescript
enum Mixed {
  No = 0,
  Yes = "YES"
}
```

**Strategy:**
- **NOT SUPPORTED** in swc4j
- Compilation error: "Heterogeneous enums (mixed numeric and string values) are not supported"
- Rationale: Difficult to map cleanly to Java enums, requires Object type with runtime casting
- Recommendation: Use separate enums for different value types

### 4. Const Enum Handling

**TypeScript:**
```typescript
const enum Direction {
  Up,
  Down
}

let x = Direction.Up;  // Should inline to: let x = 0;
```

**Java Strategy:**
Two options:

**Option A: Treat as regular enum**
- Generate full Java enum (same as non-const)
- Lose inlining optimization
- Simpler implementation

**Option B: Inline at usage sites**
- Detect const enum usage
- Replace with literal values at compile time
- No enum class generated
- More complex implementation
- Matches TypeScript behavior

**Recommended:** Option A initially (simpler), Option B later (optimization)

### 5. Computed Enum Handling - NOT SUPPORTED

**TypeScript:**
```typescript
enum Computed {
  A = 1,
  B = A * 2,      // ERROR: References another member
  C = B + A       // ERROR: Computed expression
}
```

**Strategy:**
- **NOT SUPPORTED** in swc4j
- Compilation error: "Computed enum values (expressions referencing other members) are not supported"
- Rationale: Requires complex constant expression evaluation and dependency resolution
- Recommendation: Use explicit constant values instead of computed expressions

---

## Bytecode Generation Strategy

### Overall Approach

1. **Class Generation:**
   - Generate public final class extending `Enum<EnumName>`
   - Add enum constant fields (public static final)
   - Add value field (private final int/String/Object)
   - Add $VALUES array (private static final)

2. **Constructor Generation:**
   - Private constructor: `(String name, int ordinal, <type> value)`
   - Call `super(name, ordinal)`
   - Initialize value field

3. **Static Initializer:**
   - Create enum constant instances
   - Initialize $VALUES array
   - Ensure correct ordinal assignment

4. **Method Generation:**
   - `values()` - return $VALUES.clone()
   - `valueOf(String name)` - delegate to Enum.valueOf()
   - `getValue()` - return value field
   - `fromValue(<type>)` - reverse lookup method

5. **Member Access Translation:**
   - `Direction.Up` → `Direction.UP` (field access)
   - `Direction[0]` → `Direction.fromValue(0)` (method call)

### Bytecode Structure

#### Class Structure
```
public final class <EnumName> extends java/lang/Enum {
    // Constant fields
    public static final L<EnumName>; <CONSTANT1>
    public static final L<EnumName>; <CONSTANT2>
    // ...

    // Value field (for numeric/string enums)
    private final <I|Ljava/lang/String;|Ljava/lang/Object;> value

    // Values array
    private static final [L<EnumName>; $VALUES

    // Constructor
    private <init>(Ljava/lang/String;I<I|Ljava/lang/String;|Ljava/lang/Object;>)V

    // Static initializer
    static <clinit>()V

    // Methods
    public static [L<EnumName>; values()
    public static L<EnumName>; valueOf(Ljava/lang/String;)L<EnumName>;
    public <getValue method>()...
    public static <fromValue method>...
}
```

#### Static Initializer Bytecode
```java
static {
    // Create enum constants
    new Direction
    dup
    ldc "UP"                   // name
    iconst_0                   // ordinal
    iconst_0                   // value (for numeric enum)
    invokespecial Direction.<init>
    putstatic Direction.UP

    new Direction
    dup
    ldc "DOWN"
    iconst_1
    iconst_1
    invokespecial Direction.<init>
    putstatic Direction.DOWN

    // ... repeat for all constants

    // Initialize $VALUES array
    iconst_4                   // Array size
    anewarray Direction
    dup
    iconst_0
    getstatic Direction.UP
    aastore
    dup
    iconst_1
    getstatic Direction.DOWN
    aastore
    // ... repeat for all constants
    putstatic Direction.$VALUES

    return
}
```

#### values() Method Bytecode
```java
public static Direction[] values() {
    getstatic Direction.$VALUES
    invokevirtual [LDirection;.clone()Ljava/lang/Object;
    checkcast [LDirection;
    areturn
}
```

#### valueOf(String) Method Bytecode
```java
public static Direction valueOf(String name) {
    ldc Direction.class
    aload_0                    // name parameter
    invokestatic java/lang/Enum.valueOf(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;
    checkcast Direction
    areturn
}
```

#### getValue() Method Bytecode (numeric)
```java
public int getValue() {
    aload_0                    // this
    getfield Direction.value I
    ireturn
}
```

#### fromValue(int) Method Bytecode (numeric)
```java
public static Direction fromValue(int value) {
    invokestatic Direction.values()[LDirection;
    astore_1                   // Store array in local 1
    aload_1                    // Load array
    arraylength
    istore_2                   // Store length in local 2
    iconst_0
    istore_3                   // Loop counter i = 0

  loop_start:
    iload_3                    // Load i
    iload_2                    // Load length
    if_icmpge loop_end         // if i >= length, exit loop

    aload_1                    // Load array
    iload_3                    // Load i
    aaload                     // arr[i]
    astore 4                   // Store in local 4 (d)

    aload 4                    // Load d
    invokevirtual Direction.getValue()I
    iload_0                    // Load value parameter
    if_icmpne loop_continue    // if d.value != value, continue

    aload 4                    // Found match, return d
    areturn

  loop_continue:
    iinc 3, 1                  // i++
    goto loop_start

  loop_end:
    new IllegalArgumentException
    dup
    // ... construct error message ...
    invokespecial IllegalArgumentException.<init>
    athrow
}
```

---

## Implementation Phases

### Phase 1: Basic Numeric Enums (10 test cases)

**Goal:** Implement simple numeric enums with auto-increment.

**Features:**
- Numeric enums with no explicit values (auto-increment from 0)
- Numeric enums with explicit start value
- Generate Java enum class with int value field
- Generate getValue() method
- Generate fromValue(int) method

**Test Cases:**

1. **testNumericEnumBasic** - Simple auto-increment from 0
   ```typescript
   enum Direction {
     Up,    // 0
     Down,  // 1
     Left,  // 2
     Right  // 3
   }
   let x: Direction = Direction.Up;
   let val: int = x.getValue();
   ```
   Expected: val = 0

2. **testNumericEnumExplicitStart** - Explicit starting value
   ```typescript
   enum Status {
     Pending = 1,
     Active,    // 2
     Done       // 3
   }
   ```
   Expected: Pending.getValue() = 1, Active.getValue() = 2

3. **testNumericEnumAllExplicit** - All values explicit
   ```typescript
   enum Priority {
     Low = 10,
     Medium = 20,
     High = 30
   }
   ```
   Expected: Each has correct getValue()

4. **testNumericEnumFromValue** - Reverse lookup
   ```typescript
   enum Direction {
     Up, Down, Left, Right
   }
   let d: Direction = Direction.fromValue(2);
   ```
   Expected: d = Direction.Left

5. **testNumericEnumOrdinal** - Ordinal vs value
   ```typescript
   enum Status {
     A = 10,
     B = 20
   }
   ```
   Expected: A.ordinal() = 0, A.getValue() = 10

6. **testNumericEnumSingleMember** - Enum with one member
   ```typescript
   enum Single {
     Only
   }
   ```
   Expected: Only.getValue() = 0, Only.ordinal() = 0

7. **testNumericEnumNegativeValues** - Negative values
   ```typescript
   enum Temperature {
     Cold = -10,
     Warm = 0,
     Hot = 10
   }
   ```
   Expected: Cold.getValue() = -10

8. **testNumericEnumNonContiguous** - Non-sequential values
   ```typescript
   enum Priority {
     Low = 1,
     Medium = 5,
     High = 100
   }
   ```
   Expected: Correct getValue() for each

9. **testNumericEnumValues** - values() method
   ```typescript
   enum Direction {
     Up, Down
   }
   let all: Direction[] = Direction.values();
   ```
   Expected: array length = 2, contains both values

10. **testNumericEnumValueOf** - valueOf(String) method
    ```typescript
    enum Direction {
      Up, Down
    }
    let d: Direction = Direction.valueOf("UP");
    ```
    Expected: d = Direction.Up

### Phase 2: String Enums (8 test cases)

**Goal:** Implement string enums with String value field.

**Features:**
- String enums with explicit string values
- Generate Java enum with String value field
- Generate getValue() method returning String
- Generate fromValue(String) method

**Test Cases:**

11. **testStringEnumBasic** - Simple string enum
    ```typescript
    enum Color {
      Red = "RED",
      Green = "GREEN",
      Blue = "BLUE"
    }
    ```
    Expected: Red.getValue() = "RED"

12. **testStringEnumFromValue** - Reverse lookup
    ```typescript
    enum Color {
      Red = "RED",
      Green = "GREEN"
    }
    let c: Color = Color.fromValue("GREEN");
    ```
    Expected: c = Color.Green

13. **testStringEnumDifferentCase** - Case sensitivity
    ```typescript
    enum Status {
      Active = "active",
      Inactive = "INACTIVE"
    }
    ```
    Expected: Different case values work

14. **testStringEnumEmptyString** - Empty string value
    ```typescript
    enum Special {
      Empty = "",
      NotEmpty = "value"
    }
    ```
    Expected: Empty.getValue() = ""

15. **testStringEnumSpecialChars** - Special characters
    ```typescript
    enum Message {
      Hello = "Hello, World!",
      NewLine = "Line1\nLine2"
    }
    ```
    Expected: Special chars preserved

16. **testStringEnumUnicode** - Unicode strings
    ```typescript
    enum Language {
      English = "English",
      Chinese = "中文",
      Arabic = "العربية"
    }
    ```
    Expected: Unicode preserved

17. **testStringEnumLongValue** - Long string values
    ```typescript
    enum Description {
      Short = "S",
      Long = "This is a very long description..."
    }
    ```
    Expected: Long strings work

18. **testStringEnumValueOf** - valueOf() method
    ```typescript
    enum Color {
      Red = "RED",
      Blue = "BLUE"
    }
    let c: Color = Color.valueOf("BLUE");
    ```
    Expected: c = Color.Blue

### Phase 3: Mixed Explicit/Implicit Values (10 test cases)

**Goal:** Handle enums with both explicit and implicit (auto-increment) values.

**Features:**
- Auto-increment after explicit value
- Multiple explicit values with auto-increment between
- Correct ordinal assignment

**Test Cases:**

19. **testMixedExplicitImplicit** - Explicit then implicit
    ```typescript
    enum Mixed {
      A = 10,
      B,       // 11
      C        // 12
    }
    ```
    Expected: B.getValue() = 11, C.getValue() = 12

20. **testMixedMultipleExplicit** - Multiple explicit values
    ```typescript
    enum Mixed {
      A,       // 0
      B = 5,   // 5
      C,       // 6
      D = 10,  // 10
      E        // 11
    }
    ```
    Expected: Correct values for all

21. **testMixedExplicitZero** - Explicit zero in middle
    ```typescript
    enum Mixed {
      A,       // 0
      B,       // 1
      C = 0,   // 0 (explicit)
      D        // 1 (auto-increment from 0)
    }
    ```
    Expected: C.getValue() = 0, D.getValue() = 1

22. **testMixedNegativeExplicit** - Negative explicit value
    ```typescript
    enum Mixed {
      A,       // 0
      B = -5,  // -5
      C        // -4 (auto-increment)
    }
    ```
    Expected: C.getValue() = -4

23. **testMixedLargeGap** - Large gap between values
    ```typescript
    enum Mixed {
      A = 0,
      B = 1000000,
      C        // 1000001
    }
    ```
    Expected: C.getValue() = 1000001

24. **testMixedAllSameValue** - Multiple members, same value
    ```typescript
    enum Same {
      A = 5,
      B = 5,
      C = 5
    }
    ```
    Expected: All getValue() = 5 (allowed, but unusual)

25. **testMixedOrdinalVsValue** - Ordinal differs from value
    ```typescript
    enum Mixed {
      A = 100,  // ordinal 0, value 100
      B = 50,   // ordinal 1, value 50
      C = 200   // ordinal 2, value 200
    }
    ```
    Expected: Ordinals sequential, values as specified

26. **testMixedDuplicateFromValue** - fromValue with duplicates
    ```typescript
    enum Dup {
      A = 1,
      B = 1,
      C = 2
    }
    let x: Dup = Dup.fromValue(1);
    ```
    Expected: Returns first match (A) or throw error (implementation choice)

27. **testMixedBackwardsIncrement** - Decrementing pattern
    ```typescript
    enum Countdown {
      Three = 3,
      Two,    // 4 (auto-increment, not 2)
      One,    // 5
      Zero    // 6
    }
    ```
    Expected: Auto-increment increases, not decreases

28. **testMixedExplicitLast** - Explicit on last member
    ```typescript
    enum Mixed {
      A,       // 0
      B,       // 1
      C = 100  // 100 (explicit, no auto-increment after)
    }
    ```
    Expected: C.getValue() = 100

### Phase 4: Const Enums (8 test cases)

**Goal:** Handle const enums, either by generating enum or inlining.

**Features:**
- Detect const enum declaration
- Option A: Generate enum (same as non-const)
- Option B: Inline at usage sites (optimization)

**Test Cases:**

29. **testConstEnumBasic** - Simple const enum
    ```typescript
    const enum Direction {
      Up,
      Down
    }
    let x: Direction = Direction.Up;
    ```
    Expected: Either generates enum or inlines to: let x: int = 0

30. **testConstEnumExplicitValue** - Const enum with explicit values
    ```typescript
    const enum Status {
      Active = 1,
      Inactive = 2
    }
    ```
    Expected: Generates enum or inlines

31. **testConstEnumInExpression** - Const enum in expression
    ```typescript
    const enum Value {
      One = 1,
      Two = 2
    }
    let sum: int = Value.One + Value.Two;
    ```
    Expected: sum = 3 (inlined or computed)

32. **testConstEnumString** - Const string enum
    ```typescript
    const enum Color {
      Red = "RED",
      Blue = "BLUE"
    }
    ```
    Expected: Generates enum or inlines strings

33. **testConstEnumFromValue** - Const enum reverse lookup
    ```typescript
    const enum Direction {
      Up, Down
    }
    let d: Direction = Direction.fromValue(1);
    ```
    Expected: If generating enum, should work; if inlining, error (no runtime representation)

34. **testConstEnumValueOf** - Const enum valueOf
    ```typescript
    const enum Direction {
      Up, Down
    }
    let d: Direction = Direction.valueOf("DOWN");
    ```
    Expected: If generating enum, should work; if inlining, error

35. **testConstEnumAmbientDeclaration** - Ambient const enum
    ```typescript
    declare const enum Ambient {
      A, B
    }
    ```
    Expected: No code generation (ambient declaration)

### Phase 5: Enum Usage Patterns (10 test cases)

**Goal:** Test various enum usage patterns in code.

**Features:**
- Enum as variable type
- Enum in switch statements
- Enum comparison
- Enum array/collection
- Enum as method parameter/return

**Test Cases:**

36. **testEnumAsVariableType** - Variable typed as enum
    ```typescript
    enum Color {
      Red, Green, Blue
    }
    let c: Color = Color.Red;
    c = Color.Blue;
    ```
    Expected: Assignment and reassignment work

37. **testEnumInSwitch** - Enum in switch statement
    ```typescript
    enum Direction {
      Up, Down, Left, Right
    }
    let dir: Direction = Direction.Up;
    switch (dir) {
      case Direction.Up: result = 1; break;
      case Direction.Down: result = 2; break;
    }
    ```
    Expected: Switch on enum ordinal or use equals()

38. **testEnumComparison** - Enum comparison
    ```typescript
    enum Status {
      Active, Inactive
    }
    let s1: Status = Status.Active;
    let s2: Status = Status.Active;
    let same: boolean = s1 == s2;    // true (reference equality)
    ```
    Expected: same = true

39. **testEnumInArray** - Array of enums
    ```typescript
    enum Color {
      Red, Green, Blue
    }
    let colors: Color[] = [Color.Red, Color.Blue];
    let first: Color = colors[0];
    ```
    Expected: Array operations work

40. **testEnumInMethod** - Enum as parameter/return
    ```typescript
    enum Status {
      Active, Inactive
    }
    function getStatus(): Status {
      return Status.Active;
    }
    function setStatus(s: Status): void {
      // ...
    }
    ```
    Expected: Method signatures work

41. **testEnumToString** - Enum toString() / name()
    ```typescript
    enum Direction {
      Up, Down
    }
    let name: String = Direction.Up.name();
    ```
    Expected: name = "UP"

42. **testEnumCompareTo** - Enum comparison by ordinal
    ```typescript
    enum Priority {
      Low, Medium, High
    }
    let cmp: int = Priority.Medium.compareTo(Priority.High);
    ```
    Expected: cmp < 0 (Medium comes before High)

43. **testEnumIteration** - Iterate over all enum values
    ```typescript
    enum Color {
      Red, Green, Blue
    }
    for (let c of Color.values()) {
      // process c
    }
    ```
    Expected: Loop executes 3 times

44. **testEnumNull** - Null enum variable
    ```typescript
    enum Status {
      Active, Inactive
    }
    let s: Status = null;
    ```
    Expected: s = null (allowed in Java)

45. **testEnumInstanceOf** - Check enum type
    ```typescript
    enum Direction {
      Up, Down
    }
    let d: Direction = Direction.Up;
    let isEnum: boolean = d instanceof Direction;
    ```
    Expected: isEnum = true

### Phase 6: Edge Cases (20 test cases)

**Goal:** Handle unusual and boundary cases.

**Features:**
- Empty enums
- Single-member enums
- Very large enums
- Name conflicts
- Reserved keywords
- Special characters
- Ambient declarations
- Edge values

**Test Cases:**

46. **testEnumEmpty** - Empty enum (no members)
    ```typescript
    enum Empty {
    }
    ```
    Expected: Compilation error or empty enum class

47. **testEnumSingleMember** - One member only
    ```typescript
    enum Single {
      Only
    }
    ```
    Expected: Works normally

48. **testEnumVeryLarge** - Enum with 1000+ members
    ```typescript
    enum Large {
      M0, M1, M2, ..., M999
    }
    ```
    Expected: Handles large enum gracefully

49. **testEnumMaxIntValue** - MAX_INT value
    ```typescript
    enum Edge {
      Max = 2147483647,
      AfterMax    // Overflow
    }
    ```
    Expected: AfterMax = -2147483648 (overflow)

50. **testEnumMinIntValue** - MIN_INT value
    ```typescript
    enum Edge {
      Min = -2147483648,
      AfterMin    // -2147483647
    }
    ```
    Expected: AfterMin = -2147483647

51. **testEnumLongValue** - Long integer value
    ```typescript
    enum Large {
      Big = 9223372036854775807    // Long MAX
    }
    ```
    Expected: Either support long or error

52. **testEnumFloatValue** - Float value (should error)
    ```typescript
    enum Invalid {
      Float = 3.14    // ERROR: enum values must be integers or strings
    }
    ```
    Expected: Compilation error

53. **testEnumBooleanValue** - Boolean value (should error)
    ```typescript
    enum Invalid {
      Bool = true    // ERROR
    }
    ```
    Expected: Compilation error

54. **testEnumNullValue** - Null value (should error)
    ```typescript
    enum Invalid {
      Null = null    // ERROR
    }
    ```
    Expected: Compilation error

55. **testEnumReservedKeyword** - Member name is Java keyword
    ```typescript
    enum Keywords {
      class,      // Reserved in Java
      public,
      static
    }
    ```
    Expected: Either escape names or error

56. **testEnumNameConflict** - Enum name conflicts with class
    ```typescript
    class Direction { }
    enum Direction {    // Same name
      Up, Down
    }
    ```
    Expected: Compilation error (name conflict)

57. **testEnumMemberNameConflict** - Member name conflicts with method
    ```typescript
    enum Conflict {
      values,    // Conflicts with values() method
      valueOf    // Conflicts with valueOf() method
    }
    ```
    Expected: Handle gracefully (Java allows, uses mangling)

58. **testEnumSpecialCharacters** - Member names with special chars
    ```typescript
    enum Special {
      "member-with-dash",    // Non-identifier characters
      "member with space"
    }
    ```
    Expected: Either escape or error

59. **testEnumUnicodeNames** - Unicode member names
    ```typescript
    enum Unicode {
      变量,      // Chinese characters
      переменная // Cyrillic characters
    }
    ```
    Expected: Support Unicode identifiers

60. **testEnumAmbientDeclaration** - Ambient enum (declare)
    ```typescript
    declare enum Ambient {
      A, B, C
    }
    ```
    Expected: No bytecode generation (declaration only)

61. **testEnumAmbientConstDeclaration** - Ambient const enum
    ```typescript
    declare const enum AmbientConst {
      A, B
    }
    ```
    Expected: No bytecode generation

62. **testEnumExportedDeclaration** - Exported enum
    ```typescript
    export enum Exported {
      A, B
    }
    ```
    Expected: Generate enum with public visibility

63. **testEnumNestedInClass** - Enum nested in class
    ```typescript
    class Outer {
      enum Inner {
        A, B
      }
    }
    ```
    Expected: Generate nested enum class (static member class)

64. **testEnumMultipleInFile** - Multiple enums in one file
    ```typescript
    enum Direction {
      Up, Down
    }
    enum Color {
      Red, Blue
    }
    ```
    Expected: Generate separate enum classes

65. **testEnumHeterogeneousError** - Heterogeneous enum should error
    ```typescript
    enum Heterogeneous {
      No = 0,
      Yes = "YES"    // ERROR: Cannot mix numeric and string
    }
    ```
    Expected: Compilation error

66. **testEnumComputedError** - Computed enum should error
    ```typescript
    enum Computed {
      A = 1,
      B = A * 2    // ERROR: Computed values not supported
    }
    ```
    Expected: Compilation error

---

## Edge Cases Summary

### Type System Edge Cases

1. **Heterogeneous Enums (Mixed Types) - NOT SUPPORTED**
   ```typescript
   enum Mixed { No = 0, Yes = "YES" }
   ```
   **Strategy:** Reject with compilation error (not supported)

2. **Floating-Point Values**
   ```typescript
   enum Invalid { Pi = 3.14 }
   ```
   **Strategy:** Reject with error (enums are integers or strings only)

3. **Boolean Values**
   ```typescript
   enum Invalid { True = true }
   ```
   **Strategy:** Reject with error

4. **Null/Undefined Values**
   ```typescript
   enum Invalid { Null = null }
   ```
   **Strategy:** Reject with error

5. **Complex Object Values**
   ```typescript
   enum Invalid { Obj = { x: 1 } }
   ```
   **Strategy:** Reject with error (only primitives)

### Naming Edge Cases

6. **Java Reserved Keywords**
   ```typescript
   enum Keywords { class, public, static }
   ```
   **Strategy:** Escape names (e.g., _class, _public) or reject

7. **Method Name Conflicts**
   ```typescript
   enum Conflict { values, valueOf }
   ```
   **Strategy:** Java allows (uses name mangling internally)

8. **Special Characters in Names**
   ```typescript
   enum Special { "my-value", "my value" }
   ```
   **Strategy:** Reject (Java identifiers can't have dashes/spaces)

9. **Unicode Identifiers**
   ```typescript
   enum Unicode { 变量, переменная }
   ```
   **Strategy:** Support (Java allows Unicode identifiers)

10. **Case Sensitivity**
    ```typescript
    enum CaseTest { Up, up, UP }
    ```
    **Strategy:** All valid (TS is case-sensitive, convert to UP, UP_1, UP_2)

### Value Edge Cases

11. **Integer Overflow**
    ```typescript
    enum Overflow { Max = 2147483647, Next }
    ```
    **Strategy:** Next = -2147483648 (Java integer overflow)

12. **Large Values (Long)**
    ```typescript
    enum Large { Big = 9223372036854775807 }
    ```
    **Strategy:** Use long type if needed, or restrict to int

13. **Negative Values**
    ```typescript
    enum Negative { Cold = -10, Hot = 10 }
    ```
    **Strategy:** Support (valid Java int)

14. **Duplicate Values**
    ```typescript
    enum Dup { A = 1, B = 1, C = 1 }
    ```
    **Strategy:** Allow (valid, but fromValue() returns first match)

15. **Non-Sequential Values**
    ```typescript
    enum Sparse { A = 1, B = 100, C = 1000 }
    ```
    **Strategy:** Support (value != ordinal)

### Computed Value Edge Cases - NOT SUPPORTED

16. **Forward References - NOT SUPPORTED**
    ```typescript
    enum Forward { A = B, B = 1 }
    ```
    **Strategy:** Error (computed values not supported)

17. **Circular References - NOT SUPPORTED**
    ```typescript
    enum Circular { A = B + 1, B = A + 1 }
    ```
    **Strategy:** Error (computed values not supported)

18. **Member Reference Expressions - NOT SUPPORTED**
    ```typescript
    enum Computed { A = 1, B = A * 2 }
    ```
    **Strategy:** Error (computed values not supported)

19. **Complex Expressions - NOT SUPPORTED**
    ```typescript
    enum Complex { A = 1 << 10, B = 0xFF & ~0x0F }
    ```
    **Strategy:** Error (computed values not supported unless literal constants)

### Declaration Edge Cases

21. **Ambient Declarations**
    ```typescript
    declare enum Ambient { A, B }
    ```
    **Strategy:** No bytecode generation (declaration only)

22. **Const Enums**
    ```typescript
    const enum Const { A, B }
    ```
    **Strategy:** Option A: Generate enum; Option B: Inline values

23. **Ambient Const Enums**
    ```typescript
    declare const enum Both { A, B }
    ```
    **Strategy:** No bytecode generation

24. **Empty Enums**
    ```typescript
    enum Empty { }
    ```
    **Strategy:** Error or generate empty enum class

25. **Single-Member Enums**
    ```typescript
    enum Single { Only }
    ```
    **Strategy:** Support (valid edge case)

### Usage Edge Cases

26. **Enum in Switch**
    ```typescript
    switch (myEnum) { case MyEnum.A: ...; }
    ```
    **Strategy:** Use ordinal() or generate switch on reference

27. **Enum Comparison**
    ```typescript
    let same = enum1 == enum2;
    ```
    **Strategy:** Use == (reference equality, enums are singletons)

28. **Enum Arrays**
    ```typescript
    let arr: Color[] = [Color.Red, Color.Blue];
    ```
    **Strategy:** Support (normal array operations)

29. **Null Enum Variables**
    ```typescript
    let e: Direction = null;
    ```
    **Strategy:** Support (Java allows null enum references)

30. **Enum as Generic Type Parameter**
    ```typescript
    class Box<T> { }
    let box: Box<Direction>;
    ```
    **Strategy:** Support (enums can be type parameters)

### Reverse Mapping Edge Cases

31. **Numeric Enum Reverse Mapping**
    ```typescript
    Direction[0]    // "Up" in TypeScript
    ```
    **Strategy:** Use fromValue(0) in Java (no bracket notation)

32. **String Enum No Reverse Mapping**
    ```typescript
    Color["RED"]    // Compile error or undefined in TypeScript
    ```
    **Strategy:** No reverse mapping for strings (not applicable)

33. **Duplicate Values in fromValue()**
    ```typescript
    enum Dup { A = 1, B = 1 }
    Dup.fromValue(1)    // A or B?
    ```
    **Strategy:** Return first match or throw error

### Bytecode Edge Cases

34. **Very Large Enum (1000+ members)**
    ```typescript
    enum Huge { M0, M1, ..., M999 }
    ```
    **Strategy:** Handle gracefully (large static initializer, may hit method size limit)

35. **Method Size Limit (65535 bytes)**
    - Static initializer may exceed 64KB for very large enums
    **Strategy:** Split into multiple methods if needed

36. **Constant Pool Limit (65535 entries)**
    - Each string/class reference uses constant pool entry
    **Strategy:** Monitor constant pool usage, error if exceeded

### Optimization Edge Cases

37. **Const Enum Inlining**
    ```typescript
    const enum C { A = 1 }
    let x = C.A;    // Inline to: let x = 1;
    ```
    **Strategy:** Phase 1: No inlining (generate enum); Phase 2: Inline optimization

38. **Dead Code Elimination**
    ```typescript
    if (false) { let x = MyEnum.A; }
    ```
    **Strategy:** Enum still generated even if unused (no DCE initially)

39. **Enum Folding in Constant Expressions**
    ```typescript
    const result = Direction.Up.getValue() + 1;
    ```
    **Strategy:** Fold at compile time if possible (optimization)

### Compatibility Edge Cases

40. **TypeScript Enum Transpiled to JavaScript**
    - TypeScript enums compile to objects with reverse mapping
    **Strategy:** Java enums are different (no automatic reverse mapping object)

41. **Interop with Existing Java Enums**
    - Calling Java enum from TypeScript
    **Strategy:** Support accessing Java enums from TS (future work)

42. **Export/Import Enums**
    ```typescript
    export enum Direction { }
    import { Direction } from './module';
    ```
    **Strategy:** Handle module system (future work)

---

## Implementation Tasks

### Core Files to Create

1. **TsEnumDeclGenerator.java**
   - Main generator for TypeScript enum declarations
   - Dispatch to appropriate enum type handler
   - Generate enum class structure
   - Generate static initializer
   - Generate helper methods (values, valueOf, getValue, fromValue)

2. **EnumClassWriter.java** (helper)
   - Write enum class structure
   - Extend Enum<E>
   - Add fields (constants, value, $VALUES)
   - Set access flags (public, final, super, enum)

3. **EnumStaticInitializerGenerator.java** (helper)
   - Generate <clinit>() method
   - Create enum constant instances
   - Initialize $VALUES array
   - Handle ordinal assignment

4. **EnumMethodGenerator.java** (helper)
   - Generate values() method
   - Generate valueOf(String) method
   - Generate getValue() method
   - Generate fromValue(<type>) method
   - Generate constructor

5. **EnumNameMapper.java** (helper)
   - Map TS member names to Java constant names (uppercase)
   - Handle name conflicts with Java keywords
   - Handle special characters
   - Handle Unicode identifiers

6. **EnumValueValidator.java** (helper)
   - Validate enum member values are constants (numeric or string)
   - Reject heterogeneous enums (mixed types)
   - Reject computed expressions (member references)
   - Reject invalid types (float, boolean, null)

### Core Files to Modify

1. **DeclGenerator.java** (or equivalent)
   - Add dispatch for Swc4jAstTsEnumDecl
   - Route to TsEnumDeclGenerator.generate()

2. **TypeResolver.java**
   - Add support for enum types
   - Resolve enum member types
   - Handle enum type names

3. **MemberAccessGenerator.java**
   - Handle enum constant access (Direction.Up)
   - Generate getstatic instruction
   - Handle enum method calls (getValue(), fromValue())

4. **IdentifierResolver.java**
   - Resolve enum type names
   - Resolve enum constant names
   - Track enum declarations in scope

5. **ClassRegistry.java** (or equivalent)
   - Register generated enum classes
   - Track enum types for type checking
   - Provide enum metadata

### Test Files to Create

1. **TestCompileTsEnumDeclBasic.java** - Phase 1 (10 tests)
2. **TestCompileTsEnumDeclString.java** - Phase 2 (8 tests)
3. **TestCompileTsEnumDeclMixed.java** - Phase 3 (10 tests)
4. **TestCompileTsEnumDeclConst.java** - Phase 4 (7 tests)
5. **TestCompileTsEnumDeclUsage.java** - Phase 5 (10 tests)
6. **TestCompileTsEnumDeclEdgeCases.java** - Phase 6 (21 tests)

**Total: 66 test cases**

---

## Success Criteria

- [ ] All 6 phases implemented
- [ ] 66+ comprehensive test cases covering all scenarios
- [ ] Proper enum class structure (extends Enum<E>)
- [ ] Static initializer creates all enum instances
- [ ] values() method returns array of all constants
- [ ] valueOf(String) method looks up by name
- [ ] getValue() method returns numeric/string value
- [ ] fromValue(<type>) method provides reverse lookup
- [ ] Support for numeric enums (auto-increment and explicit values)
- [ ] Support for string enums
- [ ] Support for const enums (treated as regular enums)
- [ ] Support for mixed explicit/implicit values
- [ ] Proper ordinal assignment (declaration order)
- [ ] Handle name mapping (TS to Java conventions)
- [ ] Reject invalid value types (float, boolean, null)
- [ ] Reject heterogeneous enums (mixed numeric/string)
- [ ] Reject computed enum values (member reference expressions)
- [ ] Handle ambient declarations (no codegen)
- [ ] Complete documentation
- [ ] All tests passing
- [ ] Javadoc builds successfully

---

## Implementation Estimate

**Effort:** HIGH (complex class generation, multiple enum types)

**Complexity:** HIGH
- Requires generating entire class structure
- Static initializer with instance creation
- Multiple helper methods
- Name mapping and conflict resolution
- Multiple enum types (numeric, string only)
- Heterogeneous and computed enums explicitly NOT supported (reduces complexity)

**Dependencies:**
- ClassWriter and class generation infrastructure
- ConstantPool for string/class references
- TypeResolver for enum types
- ExpressionGenerator for computed values
- StatementGenerator for declarations
- MemberAccessGenerator for enum constant access

---

## References

- **JVM Specification:** Section 4.3.2 - Enum Types
- **Java Language Specification:** Section 8.9 - Enum Types
- **TypeScript Handbook:** [Enums](https://www.typescriptlang.org/docs/handbook/enums.html)
- **TypeScript Specification:** Section 9 - Enums
- **Java Enum Guide:** [Oracle Tutorial](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html)
- **Effective Java (Joshua Bloch):** Item 34 - Use enums instead of int constants
- **SWC AST:** [Swc4jAstTsEnumDecl.java](../../../../../src/main/java/com/caoccao/javet/swc4j/ast/stmt/Swc4jAstTsEnumDecl.java)
- **SWC AST:** [Swc4jAstTsEnumMember.java](../../../../../src/main/java/com/caoccao/javet/swc4j/ast/ts/Swc4jAstTsEnumMember.java)

---

## Notes

### Critical Implementation Details

1. **Java Enum Structure:**
   - All enum types implicitly extend `java.lang.Enum<E>`
   - Cannot extend explicitly (compilation error)
   - Enum class has ACC_ENUM and ACC_FINAL flags
   - Constructor must call `super(name, ordinal)`

2. **Ordinal vs Value:**
   - `ordinal()` is the declaration order (0-indexed)
   - `getValue()` is the custom value (numeric/string)
   - These can differ: `A = 100` has ordinal 0, value 100

3. **Reverse Mapping:**
   - TypeScript numeric enums have automatic reverse mapping: `enum[0] = "name"`
   - Java enums do NOT have this (need explicit `fromValue()` method)
   - String enums never have reverse mapping in TypeScript

4. **Const Enums:**
   - Phase 1: Generate enum class (simpler, consistent)
   - Phase 2: Inline values at usage sites (optimization, matches TS behavior)
   - Ambient const enums generate no code

5. **Computed Values - NOT SUPPORTED:**
   - Expressions referencing other enum members are NOT supported
   - Only constant literal values (numeric or string) are allowed
   - Rationale: Simplifies implementation, avoids complex dependency resolution
   - Users should use explicit constant values instead

6. **Heterogeneous Enums - NOT SUPPORTED:**
   - Mixed numeric and string values in same enum NOT supported
   - Will produce compilation error
   - Rationale: Difficult to map cleanly to Java enums, encourages better design
   - Recommendation: Use separate enums for different value types

7. **Name Mapping:**
   - TypeScript: `Up`, Java: `UP` (uppercase by convention)
   - Handle conflicts with Java keywords (_class, _public)
   - Handle method name conflicts (values, valueOf - Java allows)

8. **Static Initializer Size:**
   - Static initializer (<clinit>) has 64KB method size limit
   - Very large enums (1000+ members) may need multiple initializer methods
   - Each enum constant creation: ~20 bytes of bytecode

9. **Ambient Declarations:**
   - `declare enum X { }` - declaration only, no implementation
   - Should not generate bytecode
   - Used for .d.ts type definitions

10. **Export/Module System:**
    - Exported enums should be `public`
    - Module-private enums should be package-private
    - Cross-module enum references (future work)

---

## Future Enhancements

1. **Const Enum Inlining (Phase 2)**
   - Replace `ConstEnum.Member` with literal value at compile time
   - No enum class generated
   - Matches TypeScript behavior
   - Requires usage site detection and replacement

2. **Enum Extension Methods**
   - Allow adding custom methods to enum classes
   - Useful for domain logic encapsulation
   - Requires additional method generation

3. **Enum Interfaces**
   - Allow enums to implement interfaces
   - Requires interface implementation generation

4. **Bitwise Flag Enums**
   - Special support for flag enums (powers of 2)
   - Generate helper methods for flag operations (hasFlag, addFlag, removeFlag)
   - Optimize fromValue() for bitwise OR combinations

5. **Enum Serialization**
   - Add Serializable interface
   - Generate serialization methods
   - Handle deserialization (readResolve)

6. **Enum in Annotations**
   - Support using enums in annotation values
   - Requires annotation attribute generation

7. **Interop with Java Enums**
   - Call existing Java enums from TypeScript
   - Map Java enum to TypeScript enum type
   - Access Java enum constants and methods

8. **Optimization: Dead Enum Elimination**
   - Detect unused enum values
   - Omit from generated class (if safe)
   - Reduces class file size

9. **Enhanced Error Messages**
   - Better diagnostics for enum errors
   - Suggest fixes for common mistakes
   - Show enum member declaration context

10. **Enum Documentation Generation**
    - Generate Javadoc for enum classes
    - Document each enum constant
    - Include value information in docs
